impl serde::Serialize for AggregateFunction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.function_reference != 0 {
            len += 1;
        }
        if !self.arguments.is_empty() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        if self.output_type.is_some() {
            len += 1;
        }
        if self.phase != 0 {
            len += 1;
        }
        if !self.sorts.is_empty() {
            len += 1;
        }
        if self.invocation != 0 {
            len += 1;
        }
        if !self.args.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.AggregateFunction", len)?;
        if self.function_reference != 0 {
            struct_ser.serialize_field("functionReference", &self.function_reference)?;
        }
        if !self.arguments.is_empty() {
            struct_ser.serialize_field("arguments", &self.arguments)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        if let Some(v) = self.output_type.as_ref() {
            struct_ser.serialize_field("outputType", v)?;
        }
        if self.phase != 0 {
            let v = AggregationPhase::try_from(self.phase)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.phase)))?;
            struct_ser.serialize_field("phase", &v)?;
        }
        if !self.sorts.is_empty() {
            struct_ser.serialize_field("sorts", &self.sorts)?;
        }
        if self.invocation != 0 {
            let v = aggregate_function::AggregationInvocation::try_from(self.invocation)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.invocation)))?;
            struct_ser.serialize_field("invocation", &v)?;
        }
        if !self.args.is_empty() {
            struct_ser.serialize_field("args", &self.args)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AggregateFunction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "function_reference",
            "functionReference",
            "arguments",
            "options",
            "output_type",
            "outputType",
            "phase",
            "sorts",
            "invocation",
            "args",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            FunctionReference,
            Arguments,
            Options,
            OutputType,
            Phase,
            Sorts,
            Invocation,
            Args,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "functionReference" | "function_reference" => Ok(GeneratedField::FunctionReference),
                            "arguments" => Ok(GeneratedField::Arguments),
                            "options" => Ok(GeneratedField::Options),
                            "outputType" | "output_type" => Ok(GeneratedField::OutputType),
                            "phase" => Ok(GeneratedField::Phase),
                            "sorts" => Ok(GeneratedField::Sorts),
                            "invocation" => Ok(GeneratedField::Invocation),
                            "args" => Ok(GeneratedField::Args),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AggregateFunction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.AggregateFunction")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AggregateFunction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut function_reference__ = None;
                let mut arguments__ = None;
                let mut options__ = None;
                let mut output_type__ = None;
                let mut phase__ = None;
                let mut sorts__ = None;
                let mut invocation__ = None;
                let mut args__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::FunctionReference => {
                            if function_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("functionReference"));
                            }
                            function_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Arguments => {
                            if arguments__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arguments"));
                            }
                            arguments__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OutputType => {
                            if output_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("outputType"));
                            }
                            output_type__ = map_.next_value()?;
                        }
                        GeneratedField::Phase => {
                            if phase__.is_some() {
                                return Err(serde::de::Error::duplicate_field("phase"));
                            }
                            phase__ = Some(map_.next_value::<AggregationPhase>()? as i32);
                        }
                        GeneratedField::Sorts => {
                            if sorts__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sorts"));
                            }
                            sorts__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Invocation => {
                            if invocation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("invocation"));
                            }
                            invocation__ = Some(map_.next_value::<aggregate_function::AggregationInvocation>()? as i32);
                        }
                        GeneratedField::Args => {
                            if args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("args"));
                            }
                            args__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AggregateFunction {
                    function_reference: function_reference__.unwrap_or_default(),
                    arguments: arguments__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                    output_type: output_type__,
                    phase: phase__.unwrap_or_default(),
                    sorts: sorts__.unwrap_or_default(),
                    invocation: invocation__.unwrap_or_default(),
                    args: args__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.AggregateFunction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for aggregate_function::AggregationInvocation {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unspecified => "AGGREGATION_INVOCATION_UNSPECIFIED",
            Self::All => "AGGREGATION_INVOCATION_ALL",
            Self::Distinct => "AGGREGATION_INVOCATION_DISTINCT",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for aggregate_function::AggregationInvocation {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "AGGREGATION_INVOCATION_UNSPECIFIED",
            "AGGREGATION_INVOCATION_ALL",
            "AGGREGATION_INVOCATION_DISTINCT",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = aggregate_function::AggregationInvocation;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "AGGREGATION_INVOCATION_UNSPECIFIED" => Ok(aggregate_function::AggregationInvocation::Unspecified),
                    "AGGREGATION_INVOCATION_ALL" => Ok(aggregate_function::AggregationInvocation::All),
                    "AGGREGATION_INVOCATION_DISTINCT" => Ok(aggregate_function::AggregationInvocation::Distinct),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for AggregateRel {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.common.is_some() {
            len += 1;
        }
        if self.input.is_some() {
            len += 1;
        }
        if !self.groupings.is_empty() {
            len += 1;
        }
        if !self.measures.is_empty() {
            len += 1;
        }
        if !self.grouping_expressions.is_empty() {
            len += 1;
        }
        if self.advanced_extension.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.AggregateRel", len)?;
        if let Some(v) = self.common.as_ref() {
            struct_ser.serialize_field("common", v)?;
        }
        if let Some(v) = self.input.as_ref() {
            struct_ser.serialize_field("input", v)?;
        }
        if !self.groupings.is_empty() {
            struct_ser.serialize_field("groupings", &self.groupings)?;
        }
        if !self.measures.is_empty() {
            struct_ser.serialize_field("measures", &self.measures)?;
        }
        if !self.grouping_expressions.is_empty() {
            struct_ser.serialize_field("groupingExpressions", &self.grouping_expressions)?;
        }
        if let Some(v) = self.advanced_extension.as_ref() {
            struct_ser.serialize_field("advancedExtension", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AggregateRel {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "common",
            "input",
            "groupings",
            "measures",
            "grouping_expressions",
            "groupingExpressions",
            "advanced_extension",
            "advancedExtension",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Common,
            Input,
            Groupings,
            Measures,
            GroupingExpressions,
            AdvancedExtension,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "common" => Ok(GeneratedField::Common),
                            "input" => Ok(GeneratedField::Input),
                            "groupings" => Ok(GeneratedField::Groupings),
                            "measures" => Ok(GeneratedField::Measures),
                            "groupingExpressions" | "grouping_expressions" => Ok(GeneratedField::GroupingExpressions),
                            "advancedExtension" | "advanced_extension" => Ok(GeneratedField::AdvancedExtension),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AggregateRel;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.AggregateRel")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AggregateRel, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut common__ = None;
                let mut input__ = None;
                let mut groupings__ = None;
                let mut measures__ = None;
                let mut grouping_expressions__ = None;
                let mut advanced_extension__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Common => {
                            if common__.is_some() {
                                return Err(serde::de::Error::duplicate_field("common"));
                            }
                            common__ = map_.next_value()?;
                        }
                        GeneratedField::Input => {
                            if input__.is_some() {
                                return Err(serde::de::Error::duplicate_field("input"));
                            }
                            input__ = map_.next_value()?;
                        }
                        GeneratedField::Groupings => {
                            if groupings__.is_some() {
                                return Err(serde::de::Error::duplicate_field("groupings"));
                            }
                            groupings__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Measures => {
                            if measures__.is_some() {
                                return Err(serde::de::Error::duplicate_field("measures"));
                            }
                            measures__ = Some(map_.next_value()?);
                        }
                        GeneratedField::GroupingExpressions => {
                            if grouping_expressions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("groupingExpressions"));
                            }
                            grouping_expressions__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AdvancedExtension => {
                            if advanced_extension__.is_some() {
                                return Err(serde::de::Error::duplicate_field("advancedExtension"));
                            }
                            advanced_extension__ = map_.next_value()?;
                        }
                    }
                }
                Ok(AggregateRel {
                    common: common__,
                    input: input__,
                    groupings: groupings__.unwrap_or_default(),
                    measures: measures__.unwrap_or_default(),
                    grouping_expressions: grouping_expressions__.unwrap_or_default(),
                    advanced_extension: advanced_extension__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.AggregateRel", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for aggregate_rel::Grouping {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.grouping_expressions.is_empty() {
            len += 1;
        }
        if !self.expression_references.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.AggregateRel.Grouping", len)?;
        if !self.grouping_expressions.is_empty() {
            struct_ser.serialize_field("groupingExpressions", &self.grouping_expressions)?;
        }
        if !self.expression_references.is_empty() {
            struct_ser.serialize_field("expressionReferences", &self.expression_references)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for aggregate_rel::Grouping {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "grouping_expressions",
            "groupingExpressions",
            "expression_references",
            "expressionReferences",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            GroupingExpressions,
            ExpressionReferences,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "groupingExpressions" | "grouping_expressions" => Ok(GeneratedField::GroupingExpressions),
                            "expressionReferences" | "expression_references" => Ok(GeneratedField::ExpressionReferences),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = aggregate_rel::Grouping;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.AggregateRel.Grouping")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<aggregate_rel::Grouping, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut grouping_expressions__ = None;
                let mut expression_references__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::GroupingExpressions => {
                            if grouping_expressions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("groupingExpressions"));
                            }
                            grouping_expressions__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ExpressionReferences => {
                            if expression_references__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expressionReferences"));
                            }
                            expression_references__ =
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(aggregate_rel::Grouping {
                    grouping_expressions: grouping_expressions__.unwrap_or_default(),
                    expression_references: expression_references__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.AggregateRel.Grouping", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for aggregate_rel::Measure {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.measure.is_some() {
            len += 1;
        }
        if self.filter.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.AggregateRel.Measure", len)?;
        if let Some(v) = self.measure.as_ref() {
            struct_ser.serialize_field("measure", v)?;
        }
        if let Some(v) = self.filter.as_ref() {
            struct_ser.serialize_field("filter", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for aggregate_rel::Measure {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "measure",
            "filter",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Measure,
            Filter,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "measure" => Ok(GeneratedField::Measure),
                            "filter" => Ok(GeneratedField::Filter),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = aggregate_rel::Measure;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.AggregateRel.Measure")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<aggregate_rel::Measure, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut measure__ = None;
                let mut filter__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Measure => {
                            if measure__.is_some() {
                                return Err(serde::de::Error::duplicate_field("measure"));
                            }
                            measure__ = map_.next_value()?;
                        }
                        GeneratedField::Filter => {
                            if filter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("filter"));
                            }
                            filter__ = map_.next_value()?;
                        }
                    }
                }
                Ok(aggregate_rel::Measure {
                    measure: measure__,
                    filter: filter__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.AggregateRel.Measure", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AggregationPhase {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unspecified => "AGGREGATION_PHASE_UNSPECIFIED",
            Self::InitialToIntermediate => "AGGREGATION_PHASE_INITIAL_TO_INTERMEDIATE",
            Self::IntermediateToIntermediate => "AGGREGATION_PHASE_INTERMEDIATE_TO_INTERMEDIATE",
            Self::InitialToResult => "AGGREGATION_PHASE_INITIAL_TO_RESULT",
            Self::IntermediateToResult => "AGGREGATION_PHASE_INTERMEDIATE_TO_RESULT",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for AggregationPhase {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "AGGREGATION_PHASE_UNSPECIFIED",
            "AGGREGATION_PHASE_INITIAL_TO_INTERMEDIATE",
            "AGGREGATION_PHASE_INTERMEDIATE_TO_INTERMEDIATE",
            "AGGREGATION_PHASE_INITIAL_TO_RESULT",
            "AGGREGATION_PHASE_INTERMEDIATE_TO_RESULT",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AggregationPhase;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "AGGREGATION_PHASE_UNSPECIFIED" => Ok(AggregationPhase::Unspecified),
                    "AGGREGATION_PHASE_INITIAL_TO_INTERMEDIATE" => Ok(AggregationPhase::InitialToIntermediate),
                    "AGGREGATION_PHASE_INTERMEDIATE_TO_INTERMEDIATE" => Ok(AggregationPhase::IntermediateToIntermediate),
                    "AGGREGATION_PHASE_INITIAL_TO_RESULT" => Ok(AggregationPhase::InitialToResult),
                    "AGGREGATION_PHASE_INTERMEDIATE_TO_RESULT" => Ok(AggregationPhase::IntermediateToResult),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for Capabilities {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.substrait_versions.is_empty() {
            len += 1;
        }
        if !self.advanced_extension_type_urls.is_empty() {
            len += 1;
        }
        if !self.simple_extensions.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Capabilities", len)?;
        if !self.substrait_versions.is_empty() {
            struct_ser.serialize_field("substraitVersions", &self.substrait_versions)?;
        }
        if !self.advanced_extension_type_urls.is_empty() {
            struct_ser.serialize_field("advancedExtensionTypeUrls", &self.advanced_extension_type_urls)?;
        }
        if !self.simple_extensions.is_empty() {
            struct_ser.serialize_field("simpleExtensions", &self.simple_extensions)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Capabilities {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "substrait_versions",
            "substraitVersions",
            "advanced_extension_type_urls",
            "advancedExtensionTypeUrls",
            "simple_extensions",
            "simpleExtensions",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubstraitVersions,
            AdvancedExtensionTypeUrls,
            SimpleExtensions,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "substraitVersions" | "substrait_versions" => Ok(GeneratedField::SubstraitVersions),
                            "advancedExtensionTypeUrls" | "advanced_extension_type_urls" => Ok(GeneratedField::AdvancedExtensionTypeUrls),
                            "simpleExtensions" | "simple_extensions" => Ok(GeneratedField::SimpleExtensions),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Capabilities;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Capabilities")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Capabilities, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut substrait_versions__ = None;
                let mut advanced_extension_type_urls__ = None;
                let mut simple_extensions__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubstraitVersions => {
                            if substrait_versions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("substraitVersions"));
                            }
                            substrait_versions__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AdvancedExtensionTypeUrls => {
                            if advanced_extension_type_urls__.is_some() {
                                return Err(serde::de::Error::duplicate_field("advancedExtensionTypeUrls"));
                            }
                            advanced_extension_type_urls__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SimpleExtensions => {
                            if simple_extensions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("simpleExtensions"));
                            }
                            simple_extensions__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(Capabilities {
                    substrait_versions: substrait_versions__.unwrap_or_default(),
                    advanced_extension_type_urls: advanced_extension_type_urls__.unwrap_or_default(),
                    simple_extensions: simple_extensions__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Capabilities", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for capabilities::SimpleExtension {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.uri.is_empty() {
            len += 1;
        }
        if !self.function_keys.is_empty() {
            len += 1;
        }
        if !self.type_keys.is_empty() {
            len += 1;
        }
        if !self.type_variation_keys.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Capabilities.SimpleExtension", len)?;
        if !self.uri.is_empty() {
            struct_ser.serialize_field("uri", &self.uri)?;
        }
        if !self.function_keys.is_empty() {
            struct_ser.serialize_field("functionKeys", &self.function_keys)?;
        }
        if !self.type_keys.is_empty() {
            struct_ser.serialize_field("typeKeys", &self.type_keys)?;
        }
        if !self.type_variation_keys.is_empty() {
            struct_ser.serialize_field("typeVariationKeys", &self.type_variation_keys)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for capabilities::SimpleExtension {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "uri",
            "function_keys",
            "functionKeys",
            "type_keys",
            "typeKeys",
            "type_variation_keys",
            "typeVariationKeys",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Uri,
            FunctionKeys,
            TypeKeys,
            TypeVariationKeys,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "uri" => Ok(GeneratedField::Uri),
                            "functionKeys" | "function_keys" => Ok(GeneratedField::FunctionKeys),
                            "typeKeys" | "type_keys" => Ok(GeneratedField::TypeKeys),
                            "typeVariationKeys" | "type_variation_keys" => Ok(GeneratedField::TypeVariationKeys),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = capabilities::SimpleExtension;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Capabilities.SimpleExtension")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<capabilities::SimpleExtension, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut uri__ = None;
                let mut function_keys__ = None;
                let mut type_keys__ = None;
                let mut type_variation_keys__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Uri => {
                            if uri__.is_some() {
                                return Err(serde::de::Error::duplicate_field("uri"));
                            }
                            uri__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FunctionKeys => {
                            if function_keys__.is_some() {
                                return Err(serde::de::Error::duplicate_field("functionKeys"));
                            }
                            function_keys__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TypeKeys => {
                            if type_keys__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeKeys"));
                            }
                            type_keys__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TypeVariationKeys => {
                            if type_variation_keys__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeVariationKeys"));
                            }
                            type_variation_keys__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(capabilities::SimpleExtension {
                    uri: uri__.unwrap_or_default(),
                    function_keys: function_keys__.unwrap_or_default(),
                    type_keys: type_keys__.unwrap_or_default(),
                    type_variation_keys: type_variation_keys__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Capabilities.SimpleExtension", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ComparisonJoinKey {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.left.is_some() {
            len += 1;
        }
        if self.right.is_some() {
            len += 1;
        }
        if self.comparison.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ComparisonJoinKey", len)?;
        if let Some(v) = self.left.as_ref() {
            struct_ser.serialize_field("left", v)?;
        }
        if let Some(v) = self.right.as_ref() {
            struct_ser.serialize_field("right", v)?;
        }
        if let Some(v) = self.comparison.as_ref() {
            struct_ser.serialize_field("comparison", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ComparisonJoinKey {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "left",
            "right",
            "comparison",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Left,
            Right,
            Comparison,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "left" => Ok(GeneratedField::Left),
                            "right" => Ok(GeneratedField::Right),
                            "comparison" => Ok(GeneratedField::Comparison),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ComparisonJoinKey;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ComparisonJoinKey")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ComparisonJoinKey, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut left__ = None;
                let mut right__ = None;
                let mut comparison__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Left => {
                            if left__.is_some() {
                                return Err(serde::de::Error::duplicate_field("left"));
                            }
                            left__ = map_.next_value()?;
                        }
                        GeneratedField::Right => {
                            if right__.is_some() {
                                return Err(serde::de::Error::duplicate_field("right"));
                            }
                            right__ = map_.next_value()?;
                        }
                        GeneratedField::Comparison => {
                            if comparison__.is_some() {
                                return Err(serde::de::Error::duplicate_field("comparison"));
                            }
                            comparison__ = map_.next_value()?;
                        }
                    }
                }
                Ok(ComparisonJoinKey {
                    left: left__,
                    right: right__,
                    comparison: comparison__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.ComparisonJoinKey", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for comparison_join_key::ComparisonType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.inner_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ComparisonJoinKey.ComparisonType", len)?;
        if let Some(v) = self.inner_type.as_ref() {
            match v {
                comparison_join_key::comparison_type::InnerType::Simple(v) => {
                    let v = comparison_join_key::SimpleComparisonType::try_from(*v)
                        .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
                    struct_ser.serialize_field("simple", &v)?;
                }
                comparison_join_key::comparison_type::InnerType::CustomFunctionReference(v) => {
                    struct_ser.serialize_field("customFunctionReference", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for comparison_join_key::ComparisonType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "simple",
            "custom_function_reference",
            "customFunctionReference",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Simple,
            CustomFunctionReference,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "simple" => Ok(GeneratedField::Simple),
                            "customFunctionReference" | "custom_function_reference" => Ok(GeneratedField::CustomFunctionReference),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = comparison_join_key::ComparisonType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ComparisonJoinKey.ComparisonType")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<comparison_join_key::ComparisonType, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut inner_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Simple => {
                            if inner_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("simple"));
                            }
                            inner_type__ = map_.next_value::<::std::option::Option<comparison_join_key::SimpleComparisonType>>()?.map(|x| comparison_join_key::comparison_type::InnerType::Simple(x as i32));
                        }
                        GeneratedField::CustomFunctionReference => {
                            if inner_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("customFunctionReference"));
                            }
                            inner_type__ = map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| comparison_join_key::comparison_type::InnerType::CustomFunctionReference(x.0));
                        }
                    }
                }
                Ok(comparison_join_key::ComparisonType {
                    inner_type: inner_type__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.ComparisonJoinKey.ComparisonType", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for comparison_join_key::SimpleComparisonType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unspecified => "SIMPLE_COMPARISON_TYPE_UNSPECIFIED",
            Self::Eq => "SIMPLE_COMPARISON_TYPE_EQ",
            Self::IsNotDistinctFrom => "SIMPLE_COMPARISON_TYPE_IS_NOT_DISTINCT_FROM",
            Self::MightEqual => "SIMPLE_COMPARISON_TYPE_MIGHT_EQUAL",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for comparison_join_key::SimpleComparisonType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SIMPLE_COMPARISON_TYPE_UNSPECIFIED",
            "SIMPLE_COMPARISON_TYPE_EQ",
            "SIMPLE_COMPARISON_TYPE_IS_NOT_DISTINCT_FROM",
            "SIMPLE_COMPARISON_TYPE_MIGHT_EQUAL",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = comparison_join_key::SimpleComparisonType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SIMPLE_COMPARISON_TYPE_UNSPECIFIED" => Ok(comparison_join_key::SimpleComparisonType::Unspecified),
                    "SIMPLE_COMPARISON_TYPE_EQ" => Ok(comparison_join_key::SimpleComparisonType::Eq),
                    "SIMPLE_COMPARISON_TYPE_IS_NOT_DISTINCT_FROM" => Ok(comparison_join_key::SimpleComparisonType::IsNotDistinctFrom),
                    "SIMPLE_COMPARISON_TYPE_MIGHT_EQUAL" => Ok(comparison_join_key::SimpleComparisonType::MightEqual),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ConsistentPartitionWindowRel {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.common.is_some() {
            len += 1;
        }
        if self.input.is_some() {
            len += 1;
        }
        if !self.window_functions.is_empty() {
            len += 1;
        }
        if !self.partition_expressions.is_empty() {
            len += 1;
        }
        if !self.sorts.is_empty() {
            len += 1;
        }
        if self.advanced_extension.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ConsistentPartitionWindowRel", len)?;
        if let Some(v) = self.common.as_ref() {
            struct_ser.serialize_field("common", v)?;
        }
        if let Some(v) = self.input.as_ref() {
            struct_ser.serialize_field("input", v)?;
        }
        if !self.window_functions.is_empty() {
            struct_ser.serialize_field("windowFunctions", &self.window_functions)?;
        }
        if !self.partition_expressions.is_empty() {
            struct_ser.serialize_field("partitionExpressions", &self.partition_expressions)?;
        }
        if !self.sorts.is_empty() {
            struct_ser.serialize_field("sorts", &self.sorts)?;
        }
        if let Some(v) = self.advanced_extension.as_ref() {
            struct_ser.serialize_field("advancedExtension", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ConsistentPartitionWindowRel {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "common",
            "input",
            "window_functions",
            "windowFunctions",
            "partition_expressions",
            "partitionExpressions",
            "sorts",
            "advanced_extension",
            "advancedExtension",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Common,
            Input,
            WindowFunctions,
            PartitionExpressions,
            Sorts,
            AdvancedExtension,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "common" => Ok(GeneratedField::Common),
                            "input" => Ok(GeneratedField::Input),
                            "windowFunctions" | "window_functions" => Ok(GeneratedField::WindowFunctions),
                            "partitionExpressions" | "partition_expressions" => Ok(GeneratedField::PartitionExpressions),
                            "sorts" => Ok(GeneratedField::Sorts),
                            "advancedExtension" | "advanced_extension" => Ok(GeneratedField::AdvancedExtension),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ConsistentPartitionWindowRel;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ConsistentPartitionWindowRel")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ConsistentPartitionWindowRel, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut common__ = None;
                let mut input__ = None;
                let mut window_functions__ = None;
                let mut partition_expressions__ = None;
                let mut sorts__ = None;
                let mut advanced_extension__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Common => {
                            if common__.is_some() {
                                return Err(serde::de::Error::duplicate_field("common"));
                            }
                            common__ = map_.next_value()?;
                        }
                        GeneratedField::Input => {
                            if input__.is_some() {
                                return Err(serde::de::Error::duplicate_field("input"));
                            }
                            input__ = map_.next_value()?;
                        }
                        GeneratedField::WindowFunctions => {
                            if window_functions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("windowFunctions"));
                            }
                            window_functions__ = Some(map_.next_value()?);
                        }
                        GeneratedField::PartitionExpressions => {
                            if partition_expressions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("partitionExpressions"));
                            }
                            partition_expressions__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Sorts => {
                            if sorts__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sorts"));
                            }
                            sorts__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AdvancedExtension => {
                            if advanced_extension__.is_some() {
                                return Err(serde::de::Error::duplicate_field("advancedExtension"));
                            }
                            advanced_extension__ = map_.next_value()?;
                        }
                    }
                }
                Ok(ConsistentPartitionWindowRel {
                    common: common__,
                    input: input__,
                    window_functions: window_functions__.unwrap_or_default(),
                    partition_expressions: partition_expressions__.unwrap_or_default(),
                    sorts: sorts__.unwrap_or_default(),
                    advanced_extension: advanced_extension__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.ConsistentPartitionWindowRel", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for consistent_partition_window_rel::WindowRelFunction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.function_reference != 0 {
            len += 1;
        }
        if !self.arguments.is_empty() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        if self.output_type.is_some() {
            len += 1;
        }
        if self.phase != 0 {
            len += 1;
        }
        if self.invocation != 0 {
            len += 1;
        }
        if self.lower_bound.is_some() {
            len += 1;
        }
        if self.upper_bound.is_some() {
            len += 1;
        }
        if self.bounds_type != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ConsistentPartitionWindowRel.WindowRelFunction", len)?;
        if self.function_reference != 0 {
            struct_ser.serialize_field("functionReference", &self.function_reference)?;
        }
        if !self.arguments.is_empty() {
            struct_ser.serialize_field("arguments", &self.arguments)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        if let Some(v) = self.output_type.as_ref() {
            struct_ser.serialize_field("outputType", v)?;
        }
        if self.phase != 0 {
            let v = AggregationPhase::try_from(self.phase)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.phase)))?;
            struct_ser.serialize_field("phase", &v)?;
        }
        if self.invocation != 0 {
            let v = aggregate_function::AggregationInvocation::try_from(self.invocation)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.invocation)))?;
            struct_ser.serialize_field("invocation", &v)?;
        }
        if let Some(v) = self.lower_bound.as_ref() {
            struct_ser.serialize_field("lowerBound", v)?;
        }
        if let Some(v) = self.upper_bound.as_ref() {
            struct_ser.serialize_field("upperBound", v)?;
        }
        if self.bounds_type != 0 {
            let v = expression::window_function::BoundsType::try_from(self.bounds_type)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.bounds_type)))?;
            struct_ser.serialize_field("boundsType", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for consistent_partition_window_rel::WindowRelFunction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "function_reference",
            "functionReference",
            "arguments",
            "options",
            "output_type",
            "outputType",
            "phase",
            "invocation",
            "lower_bound",
            "lowerBound",
            "upper_bound",
            "upperBound",
            "bounds_type",
            "boundsType",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            FunctionReference,
            Arguments,
            Options,
            OutputType,
            Phase,
            Invocation,
            LowerBound,
            UpperBound,
            BoundsType,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "functionReference" | "function_reference" => Ok(GeneratedField::FunctionReference),
                            "arguments" => Ok(GeneratedField::Arguments),
                            "options" => Ok(GeneratedField::Options),
                            "outputType" | "output_type" => Ok(GeneratedField::OutputType),
                            "phase" => Ok(GeneratedField::Phase),
                            "invocation" => Ok(GeneratedField::Invocation),
                            "lowerBound" | "lower_bound" => Ok(GeneratedField::LowerBound),
                            "upperBound" | "upper_bound" => Ok(GeneratedField::UpperBound),
                            "boundsType" | "bounds_type" => Ok(GeneratedField::BoundsType),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = consistent_partition_window_rel::WindowRelFunction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ConsistentPartitionWindowRel.WindowRelFunction")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<consistent_partition_window_rel::WindowRelFunction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut function_reference__ = None;
                let mut arguments__ = None;
                let mut options__ = None;
                let mut output_type__ = None;
                let mut phase__ = None;
                let mut invocation__ = None;
                let mut lower_bound__ = None;
                let mut upper_bound__ = None;
                let mut bounds_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::FunctionReference => {
                            if function_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("functionReference"));
                            }
                            function_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Arguments => {
                            if arguments__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arguments"));
                            }
                            arguments__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OutputType => {
                            if output_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("outputType"));
                            }
                            output_type__ = map_.next_value()?;
                        }
                        GeneratedField::Phase => {
                            if phase__.is_some() {
                                return Err(serde::de::Error::duplicate_field("phase"));
                            }
                            phase__ = Some(map_.next_value::<AggregationPhase>()? as i32);
                        }
                        GeneratedField::Invocation => {
                            if invocation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("invocation"));
                            }
                            invocation__ = Some(map_.next_value::<aggregate_function::AggregationInvocation>()? as i32);
                        }
                        GeneratedField::LowerBound => {
                            if lower_bound__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lowerBound"));
                            }
                            lower_bound__ = map_.next_value()?;
                        }
                        GeneratedField::UpperBound => {
                            if upper_bound__.is_some() {
                                return Err(serde::de::Error::duplicate_field("upperBound"));
                            }
                            upper_bound__ = map_.next_value()?;
                        }
                        GeneratedField::BoundsType => {
                            if bounds_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("boundsType"));
                            }
                            bounds_type__ = Some(map_.next_value::<expression::window_function::BoundsType>()? as i32);
                        }
                    }
                }
                Ok(consistent_partition_window_rel::WindowRelFunction {
                    function_reference: function_reference__.unwrap_or_default(),
                    arguments: arguments__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                    output_type: output_type__,
                    phase: phase__.unwrap_or_default(),
                    invocation: invocation__.unwrap_or_default(),
                    lower_bound: lower_bound__,
                    upper_bound: upper_bound__,
                    bounds_type: bounds_type__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.ConsistentPartitionWindowRel.WindowRelFunction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CrossRel {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.common.is_some() {
            len += 1;
        }
        if self.left.is_some() {
            len += 1;
        }
        if self.right.is_some() {
            len += 1;
        }
        if self.advanced_extension.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.CrossRel", len)?;
        if let Some(v) = self.common.as_ref() {
            struct_ser.serialize_field("common", v)?;
        }
        if let Some(v) = self.left.as_ref() {
            struct_ser.serialize_field("left", v)?;
        }
        if let Some(v) = self.right.as_ref() {
            struct_ser.serialize_field("right", v)?;
        }
        if let Some(v) = self.advanced_extension.as_ref() {
            struct_ser.serialize_field("advancedExtension", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CrossRel {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "common",
            "left",
            "right",
            "advanced_extension",
            "advancedExtension",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Common,
            Left,
            Right,
            AdvancedExtension,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "common" => Ok(GeneratedField::Common),
                            "left" => Ok(GeneratedField::Left),
                            "right" => Ok(GeneratedField::Right),
                            "advancedExtension" | "advanced_extension" => Ok(GeneratedField::AdvancedExtension),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CrossRel;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.CrossRel")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CrossRel, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut common__ = None;
                let mut left__ = None;
                let mut right__ = None;
                let mut advanced_extension__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Common => {
                            if common__.is_some() {
                                return Err(serde::de::Error::duplicate_field("common"));
                            }
                            common__ = map_.next_value()?;
                        }
                        GeneratedField::Left => {
                            if left__.is_some() {
                                return Err(serde::de::Error::duplicate_field("left"));
                            }
                            left__ = map_.next_value()?;
                        }
                        GeneratedField::Right => {
                            if right__.is_some() {
                                return Err(serde::de::Error::duplicate_field("right"));
                            }
                            right__ = map_.next_value()?;
                        }
                        GeneratedField::AdvancedExtension => {
                            if advanced_extension__.is_some() {
                                return Err(serde::de::Error::duplicate_field("advancedExtension"));
                            }
                            advanced_extension__ = map_.next_value()?;
                        }
                    }
                }
                Ok(CrossRel {
                    common: common__,
                    left: left__,
                    right: right__,
                    advanced_extension: advanced_extension__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.CrossRel", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DdlRel {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.table_schema.is_some() {
            len += 1;
        }
        if self.table_defaults.is_some() {
            len += 1;
        }
        if self.object != 0 {
            len += 1;
        }
        if self.op != 0 {
            len += 1;
        }
        if self.view_definition.is_some() {
            len += 1;
        }
        if self.common.is_some() {
            len += 1;
        }
        if self.advanced_extension.is_some() {
            len += 1;
        }
        if self.write_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.DdlRel", len)?;
        if let Some(v) = self.table_schema.as_ref() {
            struct_ser.serialize_field("tableSchema", v)?;
        }
        if let Some(v) = self.table_defaults.as_ref() {
            struct_ser.serialize_field("tableDefaults", v)?;
        }
        if self.object != 0 {
            let v = ddl_rel::DdlObject::try_from(self.object)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.object)))?;
            struct_ser.serialize_field("object", &v)?;
        }
        if self.op != 0 {
            let v = ddl_rel::DdlOp::try_from(self.op)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.op)))?;
            struct_ser.serialize_field("op", &v)?;
        }
        if let Some(v) = self.view_definition.as_ref() {
            struct_ser.serialize_field("viewDefinition", v)?;
        }
        if let Some(v) = self.common.as_ref() {
            struct_ser.serialize_field("common", v)?;
        }
        if let Some(v) = self.advanced_extension.as_ref() {
            struct_ser.serialize_field("advancedExtension", v)?;
        }
        if let Some(v) = self.write_type.as_ref() {
            match v {
                ddl_rel::WriteType::NamedObject(v) => {
                    struct_ser.serialize_field("namedObject", v)?;
                }
                ddl_rel::WriteType::ExtensionObject(v) => {
                    struct_ser.serialize_field("extensionObject", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DdlRel {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "table_schema",
            "tableSchema",
            "table_defaults",
            "tableDefaults",
            "object",
            "op",
            "view_definition",
            "viewDefinition",
            "common",
            "advanced_extension",
            "advancedExtension",
            "named_object",
            "namedObject",
            "extension_object",
            "extensionObject",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TableSchema,
            TableDefaults,
            Object,
            Op,
            ViewDefinition,
            Common,
            AdvancedExtension,
            NamedObject,
            ExtensionObject,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "tableSchema" | "table_schema" => Ok(GeneratedField::TableSchema),
                            "tableDefaults" | "table_defaults" => Ok(GeneratedField::TableDefaults),
                            "object" => Ok(GeneratedField::Object),
                            "op" => Ok(GeneratedField::Op),
                            "viewDefinition" | "view_definition" => Ok(GeneratedField::ViewDefinition),
                            "common" => Ok(GeneratedField::Common),
                            "advancedExtension" | "advanced_extension" => Ok(GeneratedField::AdvancedExtension),
                            "namedObject" | "named_object" => Ok(GeneratedField::NamedObject),
                            "extensionObject" | "extension_object" => Ok(GeneratedField::ExtensionObject),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DdlRel;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.DdlRel")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DdlRel, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut table_schema__ = None;
                let mut table_defaults__ = None;
                let mut object__ = None;
                let mut op__ = None;
                let mut view_definition__ = None;
                let mut common__ = None;
                let mut advanced_extension__ = None;
                let mut write_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TableSchema => {
                            if table_schema__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tableSchema"));
                            }
                            table_schema__ = map_.next_value()?;
                        }
                        GeneratedField::TableDefaults => {
                            if table_defaults__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tableDefaults"));
                            }
                            table_defaults__ = map_.next_value()?;
                        }
                        GeneratedField::Object => {
                            if object__.is_some() {
                                return Err(serde::de::Error::duplicate_field("object"));
                            }
                            object__ = Some(map_.next_value::<ddl_rel::DdlObject>()? as i32);
                        }
                        GeneratedField::Op => {
                            if op__.is_some() {
                                return Err(serde::de::Error::duplicate_field("op"));
                            }
                            op__ = Some(map_.next_value::<ddl_rel::DdlOp>()? as i32);
                        }
                        GeneratedField::ViewDefinition => {
                            if view_definition__.is_some() {
                                return Err(serde::de::Error::duplicate_field("viewDefinition"));
                            }
                            view_definition__ = map_.next_value()?;
                        }
                        GeneratedField::Common => {
                            if common__.is_some() {
                                return Err(serde::de::Error::duplicate_field("common"));
                            }
                            common__ = map_.next_value()?;
                        }
                        GeneratedField::AdvancedExtension => {
                            if advanced_extension__.is_some() {
                                return Err(serde::de::Error::duplicate_field("advancedExtension"));
                            }
                            advanced_extension__ = map_.next_value()?;
                        }
                        GeneratedField::NamedObject => {
                            if write_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("namedObject"));
                            }
                            write_type__ = map_.next_value::<::std::option::Option<_>>()?.map(ddl_rel::WriteType::NamedObject)
;
                        }
                        GeneratedField::ExtensionObject => {
                            if write_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("extensionObject"));
                            }
                            write_type__ = map_.next_value::<::std::option::Option<_>>()?.map(ddl_rel::WriteType::ExtensionObject)
;
                        }
                    }
                }
                Ok(DdlRel {
                    table_schema: table_schema__,
                    table_defaults: table_defaults__,
                    object: object__.unwrap_or_default(),
                    op: op__.unwrap_or_default(),
                    view_definition: view_definition__,
                    common: common__,
                    advanced_extension: advanced_extension__,
                    write_type: write_type__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.DdlRel", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ddl_rel::DdlObject {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unspecified => "DDL_OBJECT_UNSPECIFIED",
            Self::Table => "DDL_OBJECT_TABLE",
            Self::View => "DDL_OBJECT_VIEW",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for ddl_rel::DdlObject {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DDL_OBJECT_UNSPECIFIED",
            "DDL_OBJECT_TABLE",
            "DDL_OBJECT_VIEW",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ddl_rel::DdlObject;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "DDL_OBJECT_UNSPECIFIED" => Ok(ddl_rel::DdlObject::Unspecified),
                    "DDL_OBJECT_TABLE" => Ok(ddl_rel::DdlObject::Table),
                    "DDL_OBJECT_VIEW" => Ok(ddl_rel::DdlObject::View),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ddl_rel::DdlOp {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unspecified => "DDL_OP_UNSPECIFIED",
            Self::Create => "DDL_OP_CREATE",
            Self::CreateOrReplace => "DDL_OP_CREATE_OR_REPLACE",
            Self::Alter => "DDL_OP_ALTER",
            Self::Drop => "DDL_OP_DROP",
            Self::DropIfExist => "DDL_OP_DROP_IF_EXIST",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for ddl_rel::DdlOp {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DDL_OP_UNSPECIFIED",
            "DDL_OP_CREATE",
            "DDL_OP_CREATE_OR_REPLACE",
            "DDL_OP_ALTER",
            "DDL_OP_DROP",
            "DDL_OP_DROP_IF_EXIST",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ddl_rel::DdlOp;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "DDL_OP_UNSPECIFIED" => Ok(ddl_rel::DdlOp::Unspecified),
                    "DDL_OP_CREATE" => Ok(ddl_rel::DdlOp::Create),
                    "DDL_OP_CREATE_OR_REPLACE" => Ok(ddl_rel::DdlOp::CreateOrReplace),
                    "DDL_OP_ALTER" => Ok(ddl_rel::DdlOp::Alter),
                    "DDL_OP_DROP" => Ok(ddl_rel::DdlOp::Drop),
                    "DDL_OP_DROP_IF_EXIST" => Ok(ddl_rel::DdlOp::DropIfExist),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for DerivationExpression {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.kind.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.DerivationExpression", len)?;
        if let Some(v) = self.kind.as_ref() {
            match v {
                derivation_expression::Kind::Bool(v) => {
                    struct_ser.serialize_field("bool", v)?;
                }
                derivation_expression::Kind::I8(v) => {
                    struct_ser.serialize_field("i8", v)?;
                }
                derivation_expression::Kind::I16(v) => {
                    struct_ser.serialize_field("i16", v)?;
                }
                derivation_expression::Kind::I32(v) => {
                    struct_ser.serialize_field("i32", v)?;
                }
                derivation_expression::Kind::I64(v) => {
                    struct_ser.serialize_field("i64", v)?;
                }
                derivation_expression::Kind::Fp32(v) => {
                    struct_ser.serialize_field("fp32", v)?;
                }
                derivation_expression::Kind::Fp64(v) => {
                    struct_ser.serialize_field("fp64", v)?;
                }
                derivation_expression::Kind::String(v) => {
                    struct_ser.serialize_field("string", v)?;
                }
                derivation_expression::Kind::Binary(v) => {
                    struct_ser.serialize_field("binary", v)?;
                }
                derivation_expression::Kind::Timestamp(v) => {
                    struct_ser.serialize_field("timestamp", v)?;
                }
                derivation_expression::Kind::Date(v) => {
                    struct_ser.serialize_field("date", v)?;
                }
                derivation_expression::Kind::Time(v) => {
                    struct_ser.serialize_field("time", v)?;
                }
                derivation_expression::Kind::IntervalYear(v) => {
                    struct_ser.serialize_field("intervalYear", v)?;
                }
                derivation_expression::Kind::TimestampTz(v) => {
                    struct_ser.serialize_field("timestampTz", v)?;
                }
                derivation_expression::Kind::Uuid(v) => {
                    struct_ser.serialize_field("uuid", v)?;
                }
                derivation_expression::Kind::IntervalDay(v) => {
                    struct_ser.serialize_field("intervalDay", v)?;
                }
                derivation_expression::Kind::IntervalCompound(v) => {
                    struct_ser.serialize_field("intervalCompound", v)?;
                }
                derivation_expression::Kind::FixedChar(v) => {
                    struct_ser.serialize_field("fixedChar", v)?;
                }
                derivation_expression::Kind::Varchar(v) => {
                    struct_ser.serialize_field("varchar", v)?;
                }
                derivation_expression::Kind::FixedBinary(v) => {
                    struct_ser.serialize_field("fixedBinary", v)?;
                }
                derivation_expression::Kind::Decimal(v) => {
                    struct_ser.serialize_field("decimal", v)?;
                }
                derivation_expression::Kind::PrecisionTime(v) => {
                    struct_ser.serialize_field("precisionTime", v)?;
                }
                derivation_expression::Kind::PrecisionTimestamp(v) => {
                    struct_ser.serialize_field("precisionTimestamp", v)?;
                }
                derivation_expression::Kind::PrecisionTimestampTz(v) => {
                    struct_ser.serialize_field("precisionTimestampTz", v)?;
                }
                derivation_expression::Kind::Struct(v) => {
                    struct_ser.serialize_field("struct", v)?;
                }
                derivation_expression::Kind::List(v) => {
                    struct_ser.serialize_field("list", v)?;
                }
                derivation_expression::Kind::Map(v) => {
                    struct_ser.serialize_field("map", v)?;
                }
                derivation_expression::Kind::UserDefined(v) => {
                    struct_ser.serialize_field("userDefined", v)?;
                }
                derivation_expression::Kind::UserDefinedPointer(v) => {
                    struct_ser.serialize_field("userDefinedPointer", v)?;
                }
                derivation_expression::Kind::TypeParameterName(v) => {
                    struct_ser.serialize_field("typeParameterName", v)?;
                }
                derivation_expression::Kind::IntegerParameterName(v) => {
                    struct_ser.serialize_field("integerParameterName", v)?;
                }
                derivation_expression::Kind::IntegerLiteral(v) => {
                    struct_ser.serialize_field("integerLiteral", v)?;
                }
                derivation_expression::Kind::UnaryOp(v) => {
                    struct_ser.serialize_field("unaryOp", v)?;
                }
                derivation_expression::Kind::BinaryOp(v) => {
                    struct_ser.serialize_field("binaryOp", v)?;
                }
                derivation_expression::Kind::IfElse(v) => {
                    struct_ser.serialize_field("ifElse", v)?;
                }
                derivation_expression::Kind::ReturnProgram(v) => {
                    struct_ser.serialize_field("returnProgram", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DerivationExpression {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "bool",
            "i8",
            "i16",
            "i32",
            "i64",
            "fp32",
            "fp64",
            "string",
            "binary",
            "timestamp",
            "date",
            "time",
            "interval_year",
            "intervalYear",
            "timestamp_tz",
            "timestampTz",
            "uuid",
            "interval_day",
            "intervalDay",
            "interval_compound",
            "intervalCompound",
            "fixed_char",
            "fixedChar",
            "varchar",
            "fixed_binary",
            "fixedBinary",
            "decimal",
            "precision_time",
            "precisionTime",
            "precision_timestamp",
            "precisionTimestamp",
            "precision_timestamp_tz",
            "precisionTimestampTz",
            "struct",
            "list",
            "map",
            "user_defined",
            "userDefined",
            "user_defined_pointer",
            "userDefinedPointer",
            "type_parameter_name",
            "typeParameterName",
            "integer_parameter_name",
            "integerParameterName",
            "integer_literal",
            "integerLiteral",
            "unary_op",
            "unaryOp",
            "binary_op",
            "binaryOp",
            "if_else",
            "ifElse",
            "return_program",
            "returnProgram",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Bool,
            I8,
            I16,
            I32,
            I64,
            Fp32,
            Fp64,
            String,
            Binary,
            Timestamp,
            Date,
            Time,
            IntervalYear,
            TimestampTz,
            Uuid,
            IntervalDay,
            IntervalCompound,
            FixedChar,
            Varchar,
            FixedBinary,
            Decimal,
            PrecisionTime,
            PrecisionTimestamp,
            PrecisionTimestampTz,
            Struct,
            List,
            Map,
            UserDefined,
            UserDefinedPointer,
            TypeParameterName,
            IntegerParameterName,
            IntegerLiteral,
            UnaryOp,
            BinaryOp,
            IfElse,
            ReturnProgram,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "bool" => Ok(GeneratedField::Bool),
                            "i8" => Ok(GeneratedField::I8),
                            "i16" => Ok(GeneratedField::I16),
                            "i32" => Ok(GeneratedField::I32),
                            "i64" => Ok(GeneratedField::I64),
                            "fp32" => Ok(GeneratedField::Fp32),
                            "fp64" => Ok(GeneratedField::Fp64),
                            "string" => Ok(GeneratedField::String),
                            "binary" => Ok(GeneratedField::Binary),
                            "timestamp" => Ok(GeneratedField::Timestamp),
                            "date" => Ok(GeneratedField::Date),
                            "time" => Ok(GeneratedField::Time),
                            "intervalYear" | "interval_year" => Ok(GeneratedField::IntervalYear),
                            "timestampTz" | "timestamp_tz" => Ok(GeneratedField::TimestampTz),
                            "uuid" => Ok(GeneratedField::Uuid),
                            "intervalDay" | "interval_day" => Ok(GeneratedField::IntervalDay),
                            "intervalCompound" | "interval_compound" => Ok(GeneratedField::IntervalCompound),
                            "fixedChar" | "fixed_char" => Ok(GeneratedField::FixedChar),
                            "varchar" => Ok(GeneratedField::Varchar),
                            "fixedBinary" | "fixed_binary" => Ok(GeneratedField::FixedBinary),
                            "decimal" => Ok(GeneratedField::Decimal),
                            "precisionTime" | "precision_time" => Ok(GeneratedField::PrecisionTime),
                            "precisionTimestamp" | "precision_timestamp" => Ok(GeneratedField::PrecisionTimestamp),
                            "precisionTimestampTz" | "precision_timestamp_tz" => Ok(GeneratedField::PrecisionTimestampTz),
                            "struct" => Ok(GeneratedField::Struct),
                            "list" => Ok(GeneratedField::List),
                            "map" => Ok(GeneratedField::Map),
                            "userDefined" | "user_defined" => Ok(GeneratedField::UserDefined),
                            "userDefinedPointer" | "user_defined_pointer" => Ok(GeneratedField::UserDefinedPointer),
                            "typeParameterName" | "type_parameter_name" => Ok(GeneratedField::TypeParameterName),
                            "integerParameterName" | "integer_parameter_name" => Ok(GeneratedField::IntegerParameterName),
                            "integerLiteral" | "integer_literal" => Ok(GeneratedField::IntegerLiteral),
                            "unaryOp" | "unary_op" => Ok(GeneratedField::UnaryOp),
                            "binaryOp" | "binary_op" => Ok(GeneratedField::BinaryOp),
                            "ifElse" | "if_else" => Ok(GeneratedField::IfElse),
                            "returnProgram" | "return_program" => Ok(GeneratedField::ReturnProgram),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DerivationExpression;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.DerivationExpression")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DerivationExpression, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut kind__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Bool => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bool"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::Bool)
;
                        }
                        GeneratedField::I8 => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("i8"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::I8)
;
                        }
                        GeneratedField::I16 => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("i16"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::I16)
;
                        }
                        GeneratedField::I32 => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("i32"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::I32)
;
                        }
                        GeneratedField::I64 => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("i64"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::I64)
;
                        }
                        GeneratedField::Fp32 => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fp32"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::Fp32)
;
                        }
                        GeneratedField::Fp64 => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fp64"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::Fp64)
;
                        }
                        GeneratedField::String => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("string"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::String)
;
                        }
                        GeneratedField::Binary => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("binary"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::Binary)
;
                        }
                        GeneratedField::Timestamp => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestamp"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::Timestamp)
;
                        }
                        GeneratedField::Date => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("date"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::Date)
;
                        }
                        GeneratedField::Time => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("time"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::Time)
;
                        }
                        GeneratedField::IntervalYear => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("intervalYear"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::IntervalYear)
;
                        }
                        GeneratedField::TimestampTz => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestampTz"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::TimestampTz)
;
                        }
                        GeneratedField::Uuid => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("uuid"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::Uuid)
;
                        }
                        GeneratedField::IntervalDay => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("intervalDay"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::IntervalDay)
;
                        }
                        GeneratedField::IntervalCompound => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("intervalCompound"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::IntervalCompound)
;
                        }
                        GeneratedField::FixedChar => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fixedChar"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::FixedChar)
;
                        }
                        GeneratedField::Varchar => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("varchar"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::Varchar)
;
                        }
                        GeneratedField::FixedBinary => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fixedBinary"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::FixedBinary)
;
                        }
                        GeneratedField::Decimal => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("decimal"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::Decimal)
;
                        }
                        GeneratedField::PrecisionTime => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precisionTime"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::PrecisionTime)
;
                        }
                        GeneratedField::PrecisionTimestamp => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precisionTimestamp"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::PrecisionTimestamp)
;
                        }
                        GeneratedField::PrecisionTimestampTz => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precisionTimestampTz"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::PrecisionTimestampTz)
;
                        }
                        GeneratedField::Struct => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("struct"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::Struct)
;
                        }
                        GeneratedField::List => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::List)
;
                        }
                        GeneratedField::Map => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("map"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::Map)
;
                        }
                        GeneratedField::UserDefined => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("userDefined"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::UserDefined)
;
                        }
                        GeneratedField::UserDefinedPointer => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("userDefinedPointer"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| derivation_expression::Kind::UserDefinedPointer(x.0));
                        }
                        GeneratedField::TypeParameterName => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeParameterName"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::TypeParameterName);
                        }
                        GeneratedField::IntegerParameterName => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("integerParameterName"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::IntegerParameterName);
                        }
                        GeneratedField::IntegerLiteral => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("integerLiteral"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| derivation_expression::Kind::IntegerLiteral(x.0));
                        }
                        GeneratedField::UnaryOp => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("unaryOp"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::UnaryOp)
;
                        }
                        GeneratedField::BinaryOp => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("binaryOp"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::BinaryOp)
;
                        }
                        GeneratedField::IfElse => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ifElse"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::IfElse)
;
                        }
                        GeneratedField::ReturnProgram => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("returnProgram"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(derivation_expression::Kind::ReturnProgram)
;
                        }
                    }
                }
                Ok(DerivationExpression {
                    kind: kind__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.DerivationExpression", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for derivation_expression::BinaryOp {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.op_type != 0 {
            len += 1;
        }
        if self.arg1.is_some() {
            len += 1;
        }
        if self.arg2.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.DerivationExpression.BinaryOp", len)?;
        if self.op_type != 0 {
            let v = derivation_expression::binary_op::BinaryOpType::try_from(self.op_type)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.op_type)))?;
            struct_ser.serialize_field("opType", &v)?;
        }
        if let Some(v) = self.arg1.as_ref() {
            struct_ser.serialize_field("arg1", v)?;
        }
        if let Some(v) = self.arg2.as_ref() {
            struct_ser.serialize_field("arg2", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for derivation_expression::BinaryOp {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "op_type",
            "opType",
            "arg1",
            "arg2",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            OpType,
            Arg1,
            Arg2,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "opType" | "op_type" => Ok(GeneratedField::OpType),
                            "arg1" => Ok(GeneratedField::Arg1),
                            "arg2" => Ok(GeneratedField::Arg2),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = derivation_expression::BinaryOp;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.DerivationExpression.BinaryOp")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<derivation_expression::BinaryOp, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut op_type__ = None;
                let mut arg1__ = None;
                let mut arg2__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::OpType => {
                            if op_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("opType"));
                            }
                            op_type__ = Some(map_.next_value::<derivation_expression::binary_op::BinaryOpType>()? as i32);
                        }
                        GeneratedField::Arg1 => {
                            if arg1__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arg1"));
                            }
                            arg1__ = map_.next_value()?;
                        }
                        GeneratedField::Arg2 => {
                            if arg2__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arg2"));
                            }
                            arg2__ = map_.next_value()?;
                        }
                    }
                }
                Ok(derivation_expression::BinaryOp {
                    op_type: op_type__.unwrap_or_default(),
                    arg1: arg1__,
                    arg2: arg2__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.DerivationExpression.BinaryOp", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for derivation_expression::binary_op::BinaryOpType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unspecified => "BINARY_OP_TYPE_UNSPECIFIED",
            Self::Plus => "BINARY_OP_TYPE_PLUS",
            Self::Minus => "BINARY_OP_TYPE_MINUS",
            Self::Multiply => "BINARY_OP_TYPE_MULTIPLY",
            Self::Divide => "BINARY_OP_TYPE_DIVIDE",
            Self::Min => "BINARY_OP_TYPE_MIN",
            Self::Max => "BINARY_OP_TYPE_MAX",
            Self::GreaterThan => "BINARY_OP_TYPE_GREATER_THAN",
            Self::LessThan => "BINARY_OP_TYPE_LESS_THAN",
            Self::And => "BINARY_OP_TYPE_AND",
            Self::Or => "BINARY_OP_TYPE_OR",
            Self::Equals => "BINARY_OP_TYPE_EQUALS",
            Self::Covers => "BINARY_OP_TYPE_COVERS",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for derivation_expression::binary_op::BinaryOpType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BINARY_OP_TYPE_UNSPECIFIED",
            "BINARY_OP_TYPE_PLUS",
            "BINARY_OP_TYPE_MINUS",
            "BINARY_OP_TYPE_MULTIPLY",
            "BINARY_OP_TYPE_DIVIDE",
            "BINARY_OP_TYPE_MIN",
            "BINARY_OP_TYPE_MAX",
            "BINARY_OP_TYPE_GREATER_THAN",
            "BINARY_OP_TYPE_LESS_THAN",
            "BINARY_OP_TYPE_AND",
            "BINARY_OP_TYPE_OR",
            "BINARY_OP_TYPE_EQUALS",
            "BINARY_OP_TYPE_COVERS",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = derivation_expression::binary_op::BinaryOpType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "BINARY_OP_TYPE_UNSPECIFIED" => Ok(derivation_expression::binary_op::BinaryOpType::Unspecified),
                    "BINARY_OP_TYPE_PLUS" => Ok(derivation_expression::binary_op::BinaryOpType::Plus),
                    "BINARY_OP_TYPE_MINUS" => Ok(derivation_expression::binary_op::BinaryOpType::Minus),
                    "BINARY_OP_TYPE_MULTIPLY" => Ok(derivation_expression::binary_op::BinaryOpType::Multiply),
                    "BINARY_OP_TYPE_DIVIDE" => Ok(derivation_expression::binary_op::BinaryOpType::Divide),
                    "BINARY_OP_TYPE_MIN" => Ok(derivation_expression::binary_op::BinaryOpType::Min),
                    "BINARY_OP_TYPE_MAX" => Ok(derivation_expression::binary_op::BinaryOpType::Max),
                    "BINARY_OP_TYPE_GREATER_THAN" => Ok(derivation_expression::binary_op::BinaryOpType::GreaterThan),
                    "BINARY_OP_TYPE_LESS_THAN" => Ok(derivation_expression::binary_op::BinaryOpType::LessThan),
                    "BINARY_OP_TYPE_AND" => Ok(derivation_expression::binary_op::BinaryOpType::And),
                    "BINARY_OP_TYPE_OR" => Ok(derivation_expression::binary_op::BinaryOpType::Or),
                    "BINARY_OP_TYPE_EQUALS" => Ok(derivation_expression::binary_op::BinaryOpType::Equals),
                    "BINARY_OP_TYPE_COVERS" => Ok(derivation_expression::binary_op::BinaryOpType::Covers),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for derivation_expression::ExpressionDecimal {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.scale.is_some() {
            len += 1;
        }
        if self.precision.is_some() {
            len += 1;
        }
        if self.variation_pointer != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.DerivationExpression.ExpressionDecimal", len)?;
        if let Some(v) = self.scale.as_ref() {
            struct_ser.serialize_field("scale", v)?;
        }
        if let Some(v) = self.precision.as_ref() {
            struct_ser.serialize_field("precision", v)?;
        }
        if self.variation_pointer != 0 {
            struct_ser.serialize_field("variationPointer", &self.variation_pointer)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for derivation_expression::ExpressionDecimal {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "scale",
            "precision",
            "variation_pointer",
            "variationPointer",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Scale,
            Precision,
            VariationPointer,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "scale" => Ok(GeneratedField::Scale),
                            "precision" => Ok(GeneratedField::Precision),
                            "variationPointer" | "variation_pointer" => Ok(GeneratedField::VariationPointer),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = derivation_expression::ExpressionDecimal;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.DerivationExpression.ExpressionDecimal")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<derivation_expression::ExpressionDecimal, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut scale__ = None;
                let mut precision__ = None;
                let mut variation_pointer__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Scale => {
                            if scale__.is_some() {
                                return Err(serde::de::Error::duplicate_field("scale"));
                            }
                            scale__ = map_.next_value()?;
                        }
                        GeneratedField::Precision => {
                            if precision__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precision"));
                            }
                            precision__ = map_.next_value()?;
                        }
                        GeneratedField::VariationPointer => {
                            if variation_pointer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("variationPointer"));
                            }
                            variation_pointer__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(derivation_expression::ExpressionDecimal {
                    scale: scale__,
                    precision: precision__,
                    variation_pointer: variation_pointer__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.DerivationExpression.ExpressionDecimal", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for derivation_expression::ExpressionFixedBinary {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.length.is_some() {
            len += 1;
        }
        if self.variation_pointer != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.DerivationExpression.ExpressionFixedBinary", len)?;
        if let Some(v) = self.length.as_ref() {
            struct_ser.serialize_field("length", v)?;
        }
        if self.variation_pointer != 0 {
            struct_ser.serialize_field("variationPointer", &self.variation_pointer)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for derivation_expression::ExpressionFixedBinary {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "length",
            "variation_pointer",
            "variationPointer",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Length,
            VariationPointer,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "length" => Ok(GeneratedField::Length),
                            "variationPointer" | "variation_pointer" => Ok(GeneratedField::VariationPointer),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = derivation_expression::ExpressionFixedBinary;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.DerivationExpression.ExpressionFixedBinary")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<derivation_expression::ExpressionFixedBinary, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut length__ = None;
                let mut variation_pointer__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Length => {
                            if length__.is_some() {
                                return Err(serde::de::Error::duplicate_field("length"));
                            }
                            length__ = map_.next_value()?;
                        }
                        GeneratedField::VariationPointer => {
                            if variation_pointer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("variationPointer"));
                            }
                            variation_pointer__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(derivation_expression::ExpressionFixedBinary {
                    length: length__,
                    variation_pointer: variation_pointer__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.DerivationExpression.ExpressionFixedBinary", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for derivation_expression::ExpressionFixedChar {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.length.is_some() {
            len += 1;
        }
        if self.variation_pointer != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.DerivationExpression.ExpressionFixedChar", len)?;
        if let Some(v) = self.length.as_ref() {
            struct_ser.serialize_field("length", v)?;
        }
        if self.variation_pointer != 0 {
            struct_ser.serialize_field("variationPointer", &self.variation_pointer)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for derivation_expression::ExpressionFixedChar {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "length",
            "variation_pointer",
            "variationPointer",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Length,
            VariationPointer,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "length" => Ok(GeneratedField::Length),
                            "variationPointer" | "variation_pointer" => Ok(GeneratedField::VariationPointer),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = derivation_expression::ExpressionFixedChar;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.DerivationExpression.ExpressionFixedChar")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<derivation_expression::ExpressionFixedChar, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut length__ = None;
                let mut variation_pointer__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Length => {
                            if length__.is_some() {
                                return Err(serde::de::Error::duplicate_field("length"));
                            }
                            length__ = map_.next_value()?;
                        }
                        GeneratedField::VariationPointer => {
                            if variation_pointer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("variationPointer"));
                            }
                            variation_pointer__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(derivation_expression::ExpressionFixedChar {
                    length: length__,
                    variation_pointer: variation_pointer__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.DerivationExpression.ExpressionFixedChar", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for derivation_expression::ExpressionIntervalCompound {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.precision.is_some() {
            len += 1;
        }
        if self.variation_pointer != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.DerivationExpression.ExpressionIntervalCompound", len)?;
        if let Some(v) = self.precision.as_ref() {
            struct_ser.serialize_field("precision", v)?;
        }
        if self.variation_pointer != 0 {
            struct_ser.serialize_field("variationPointer", &self.variation_pointer)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for derivation_expression::ExpressionIntervalCompound {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "precision",
            "variation_pointer",
            "variationPointer",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Precision,
            VariationPointer,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "precision" => Ok(GeneratedField::Precision),
                            "variationPointer" | "variation_pointer" => Ok(GeneratedField::VariationPointer),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = derivation_expression::ExpressionIntervalCompound;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.DerivationExpression.ExpressionIntervalCompound")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<derivation_expression::ExpressionIntervalCompound, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut precision__ = None;
                let mut variation_pointer__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Precision => {
                            if precision__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precision"));
                            }
                            precision__ = map_.next_value()?;
                        }
                        GeneratedField::VariationPointer => {
                            if variation_pointer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("variationPointer"));
                            }
                            variation_pointer__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(derivation_expression::ExpressionIntervalCompound {
                    precision: precision__,
                    variation_pointer: variation_pointer__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.DerivationExpression.ExpressionIntervalCompound", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for derivation_expression::ExpressionIntervalDay {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.precision.is_some() {
            len += 1;
        }
        if self.variation_pointer != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.DerivationExpression.ExpressionIntervalDay", len)?;
        if let Some(v) = self.precision.as_ref() {
            struct_ser.serialize_field("precision", v)?;
        }
        if self.variation_pointer != 0 {
            struct_ser.serialize_field("variationPointer", &self.variation_pointer)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for derivation_expression::ExpressionIntervalDay {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "precision",
            "variation_pointer",
            "variationPointer",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Precision,
            VariationPointer,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "precision" => Ok(GeneratedField::Precision),
                            "variationPointer" | "variation_pointer" => Ok(GeneratedField::VariationPointer),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = derivation_expression::ExpressionIntervalDay;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.DerivationExpression.ExpressionIntervalDay")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<derivation_expression::ExpressionIntervalDay, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut precision__ = None;
                let mut variation_pointer__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Precision => {
                            if precision__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precision"));
                            }
                            precision__ = map_.next_value()?;
                        }
                        GeneratedField::VariationPointer => {
                            if variation_pointer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("variationPointer"));
                            }
                            variation_pointer__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(derivation_expression::ExpressionIntervalDay {
                    precision: precision__,
                    variation_pointer: variation_pointer__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.DerivationExpression.ExpressionIntervalDay", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for derivation_expression::ExpressionList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.r#type.is_some() {
            len += 1;
        }
        if self.variation_pointer != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.DerivationExpression.ExpressionList", len)?;
        if let Some(v) = self.r#type.as_ref() {
            struct_ser.serialize_field("type", v)?;
        }
        if self.variation_pointer != 0 {
            struct_ser.serialize_field("variationPointer", &self.variation_pointer)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for derivation_expression::ExpressionList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "variation_pointer",
            "variationPointer",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            VariationPointer,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "variationPointer" | "variation_pointer" => Ok(GeneratedField::VariationPointer),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = derivation_expression::ExpressionList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.DerivationExpression.ExpressionList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<derivation_expression::ExpressionList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut variation_pointer__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = map_.next_value()?;
                        }
                        GeneratedField::VariationPointer => {
                            if variation_pointer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("variationPointer"));
                            }
                            variation_pointer__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(derivation_expression::ExpressionList {
                    r#type: r#type__,
                    variation_pointer: variation_pointer__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.DerivationExpression.ExpressionList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for derivation_expression::ExpressionMap {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.key.is_some() {
            len += 1;
        }
        if self.value.is_some() {
            len += 1;
        }
        if self.variation_pointer != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.DerivationExpression.ExpressionMap", len)?;
        if let Some(v) = self.key.as_ref() {
            struct_ser.serialize_field("key", v)?;
        }
        if let Some(v) = self.value.as_ref() {
            struct_ser.serialize_field("value", v)?;
        }
        if self.variation_pointer != 0 {
            struct_ser.serialize_field("variationPointer", &self.variation_pointer)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for derivation_expression::ExpressionMap {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "key",
            "value",
            "variation_pointer",
            "variationPointer",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Key,
            Value,
            VariationPointer,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "key" => Ok(GeneratedField::Key),
                            "value" => Ok(GeneratedField::Value),
                            "variationPointer" | "variation_pointer" => Ok(GeneratedField::VariationPointer),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = derivation_expression::ExpressionMap;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.DerivationExpression.ExpressionMap")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<derivation_expression::ExpressionMap, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut key__ = None;
                let mut value__ = None;
                let mut variation_pointer__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Key => {
                            if key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("key"));
                            }
                            key__ = map_.next_value()?;
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ = map_.next_value()?;
                        }
                        GeneratedField::VariationPointer => {
                            if variation_pointer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("variationPointer"));
                            }
                            variation_pointer__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(derivation_expression::ExpressionMap {
                    key: key__,
                    value: value__,
                    variation_pointer: variation_pointer__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.DerivationExpression.ExpressionMap", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for derivation_expression::ExpressionNamedStruct {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.names.is_empty() {
            len += 1;
        }
        if self.r#struct.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.DerivationExpression.ExpressionNamedStruct", len)?;
        if !self.names.is_empty() {
            struct_ser.serialize_field("names", &self.names)?;
        }
        if let Some(v) = self.r#struct.as_ref() {
            struct_ser.serialize_field("struct", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for derivation_expression::ExpressionNamedStruct {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "names",
            "struct",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Names,
            Struct,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "names" => Ok(GeneratedField::Names),
                            "struct" => Ok(GeneratedField::Struct),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = derivation_expression::ExpressionNamedStruct;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.DerivationExpression.ExpressionNamedStruct")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<derivation_expression::ExpressionNamedStruct, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut names__ = None;
                let mut r#struct__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Names => {
                            if names__.is_some() {
                                return Err(serde::de::Error::duplicate_field("names"));
                            }
                            names__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Struct => {
                            if r#struct__.is_some() {
                                return Err(serde::de::Error::duplicate_field("struct"));
                            }
                            r#struct__ = map_.next_value()?;
                        }
                    }
                }
                Ok(derivation_expression::ExpressionNamedStruct {
                    names: names__.unwrap_or_default(),
                    r#struct: r#struct__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.DerivationExpression.ExpressionNamedStruct", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for derivation_expression::ExpressionPrecisionTime {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.precision.is_some() {
            len += 1;
        }
        if self.variation_pointer != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.DerivationExpression.ExpressionPrecisionTime", len)?;
        if let Some(v) = self.precision.as_ref() {
            struct_ser.serialize_field("precision", v)?;
        }
        if self.variation_pointer != 0 {
            struct_ser.serialize_field("variationPointer", &self.variation_pointer)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for derivation_expression::ExpressionPrecisionTime {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "precision",
            "variation_pointer",
            "variationPointer",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Precision,
            VariationPointer,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "precision" => Ok(GeneratedField::Precision),
                            "variationPointer" | "variation_pointer" => Ok(GeneratedField::VariationPointer),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = derivation_expression::ExpressionPrecisionTime;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.DerivationExpression.ExpressionPrecisionTime")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<derivation_expression::ExpressionPrecisionTime, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut precision__ = None;
                let mut variation_pointer__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Precision => {
                            if precision__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precision"));
                            }
                            precision__ = map_.next_value()?;
                        }
                        GeneratedField::VariationPointer => {
                            if variation_pointer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("variationPointer"));
                            }
                            variation_pointer__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(derivation_expression::ExpressionPrecisionTime {
                    precision: precision__,
                    variation_pointer: variation_pointer__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.DerivationExpression.ExpressionPrecisionTime", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for derivation_expression::ExpressionPrecisionTimestamp {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.precision.is_some() {
            len += 1;
        }
        if self.variation_pointer != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.DerivationExpression.ExpressionPrecisionTimestamp", len)?;
        if let Some(v) = self.precision.as_ref() {
            struct_ser.serialize_field("precision", v)?;
        }
        if self.variation_pointer != 0 {
            struct_ser.serialize_field("variationPointer", &self.variation_pointer)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for derivation_expression::ExpressionPrecisionTimestamp {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "precision",
            "variation_pointer",
            "variationPointer",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Precision,
            VariationPointer,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "precision" => Ok(GeneratedField::Precision),
                            "variationPointer" | "variation_pointer" => Ok(GeneratedField::VariationPointer),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = derivation_expression::ExpressionPrecisionTimestamp;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.DerivationExpression.ExpressionPrecisionTimestamp")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<derivation_expression::ExpressionPrecisionTimestamp, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut precision__ = None;
                let mut variation_pointer__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Precision => {
                            if precision__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precision"));
                            }
                            precision__ = map_.next_value()?;
                        }
                        GeneratedField::VariationPointer => {
                            if variation_pointer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("variationPointer"));
                            }
                            variation_pointer__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(derivation_expression::ExpressionPrecisionTimestamp {
                    precision: precision__,
                    variation_pointer: variation_pointer__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.DerivationExpression.ExpressionPrecisionTimestamp", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for derivation_expression::ExpressionPrecisionTimestampTz {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.precision.is_some() {
            len += 1;
        }
        if self.variation_pointer != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.DerivationExpression.ExpressionPrecisionTimestampTZ", len)?;
        if let Some(v) = self.precision.as_ref() {
            struct_ser.serialize_field("precision", v)?;
        }
        if self.variation_pointer != 0 {
            struct_ser.serialize_field("variationPointer", &self.variation_pointer)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for derivation_expression::ExpressionPrecisionTimestampTz {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "precision",
            "variation_pointer",
            "variationPointer",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Precision,
            VariationPointer,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "precision" => Ok(GeneratedField::Precision),
                            "variationPointer" | "variation_pointer" => Ok(GeneratedField::VariationPointer),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = derivation_expression::ExpressionPrecisionTimestampTz;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.DerivationExpression.ExpressionPrecisionTimestampTZ")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<derivation_expression::ExpressionPrecisionTimestampTz, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut precision__ = None;
                let mut variation_pointer__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Precision => {
                            if precision__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precision"));
                            }
                            precision__ = map_.next_value()?;
                        }
                        GeneratedField::VariationPointer => {
                            if variation_pointer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("variationPointer"));
                            }
                            variation_pointer__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(derivation_expression::ExpressionPrecisionTimestampTz {
                    precision: precision__,
                    variation_pointer: variation_pointer__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.DerivationExpression.ExpressionPrecisionTimestampTZ", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for derivation_expression::ExpressionStruct {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.types.is_empty() {
            len += 1;
        }
        if self.variation_pointer != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.DerivationExpression.ExpressionStruct", len)?;
        if !self.types.is_empty() {
            struct_ser.serialize_field("types", &self.types)?;
        }
        if self.variation_pointer != 0 {
            struct_ser.serialize_field("variationPointer", &self.variation_pointer)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for derivation_expression::ExpressionStruct {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "types",
            "variation_pointer",
            "variationPointer",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Types,
            VariationPointer,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "types" => Ok(GeneratedField::Types),
                            "variationPointer" | "variation_pointer" => Ok(GeneratedField::VariationPointer),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = derivation_expression::ExpressionStruct;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.DerivationExpression.ExpressionStruct")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<derivation_expression::ExpressionStruct, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut types__ = None;
                let mut variation_pointer__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Types => {
                            if types__.is_some() {
                                return Err(serde::de::Error::duplicate_field("types"));
                            }
                            types__ = Some(map_.next_value()?);
                        }
                        GeneratedField::VariationPointer => {
                            if variation_pointer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("variationPointer"));
                            }
                            variation_pointer__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(derivation_expression::ExpressionStruct {
                    types: types__.unwrap_or_default(),
                    variation_pointer: variation_pointer__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.DerivationExpression.ExpressionStruct", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for derivation_expression::ExpressionUserDefined {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.type_pointer != 0 {
            len += 1;
        }
        if self.variation_pointer != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.DerivationExpression.ExpressionUserDefined", len)?;
        if self.type_pointer != 0 {
            struct_ser.serialize_field("typePointer", &self.type_pointer)?;
        }
        if self.variation_pointer != 0 {
            struct_ser.serialize_field("variationPointer", &self.variation_pointer)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for derivation_expression::ExpressionUserDefined {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type_pointer",
            "typePointer",
            "variation_pointer",
            "variationPointer",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TypePointer,
            VariationPointer,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "typePointer" | "type_pointer" => Ok(GeneratedField::TypePointer),
                            "variationPointer" | "variation_pointer" => Ok(GeneratedField::VariationPointer),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = derivation_expression::ExpressionUserDefined;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.DerivationExpression.ExpressionUserDefined")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<derivation_expression::ExpressionUserDefined, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut type_pointer__ = None;
                let mut variation_pointer__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TypePointer => {
                            if type_pointer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typePointer"));
                            }
                            type_pointer__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::VariationPointer => {
                            if variation_pointer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("variationPointer"));
                            }
                            variation_pointer__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(derivation_expression::ExpressionUserDefined {
                    type_pointer: type_pointer__.unwrap_or_default(),
                    variation_pointer: variation_pointer__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.DerivationExpression.ExpressionUserDefined", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for derivation_expression::ExpressionVarChar {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.length.is_some() {
            len += 1;
        }
        if self.variation_pointer != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.DerivationExpression.ExpressionVarChar", len)?;
        if let Some(v) = self.length.as_ref() {
            struct_ser.serialize_field("length", v)?;
        }
        if self.variation_pointer != 0 {
            struct_ser.serialize_field("variationPointer", &self.variation_pointer)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for derivation_expression::ExpressionVarChar {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "length",
            "variation_pointer",
            "variationPointer",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Length,
            VariationPointer,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "length" => Ok(GeneratedField::Length),
                            "variationPointer" | "variation_pointer" => Ok(GeneratedField::VariationPointer),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = derivation_expression::ExpressionVarChar;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.DerivationExpression.ExpressionVarChar")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<derivation_expression::ExpressionVarChar, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut length__ = None;
                let mut variation_pointer__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Length => {
                            if length__.is_some() {
                                return Err(serde::de::Error::duplicate_field("length"));
                            }
                            length__ = map_.next_value()?;
                        }
                        GeneratedField::VariationPointer => {
                            if variation_pointer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("variationPointer"));
                            }
                            variation_pointer__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(derivation_expression::ExpressionVarChar {
                    length: length__,
                    variation_pointer: variation_pointer__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.DerivationExpression.ExpressionVarChar", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for derivation_expression::IfElse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.if_condition.is_some() {
            len += 1;
        }
        if self.if_return.is_some() {
            len += 1;
        }
        if self.else_return.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.DerivationExpression.IfElse", len)?;
        if let Some(v) = self.if_condition.as_ref() {
            struct_ser.serialize_field("ifCondition", v)?;
        }
        if let Some(v) = self.if_return.as_ref() {
            struct_ser.serialize_field("ifReturn", v)?;
        }
        if let Some(v) = self.else_return.as_ref() {
            struct_ser.serialize_field("elseReturn", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for derivation_expression::IfElse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "if_condition",
            "ifCondition",
            "if_return",
            "ifReturn",
            "else_return",
            "elseReturn",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            IfCondition,
            IfReturn,
            ElseReturn,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ifCondition" | "if_condition" => Ok(GeneratedField::IfCondition),
                            "ifReturn" | "if_return" => Ok(GeneratedField::IfReturn),
                            "elseReturn" | "else_return" => Ok(GeneratedField::ElseReturn),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = derivation_expression::IfElse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.DerivationExpression.IfElse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<derivation_expression::IfElse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut if_condition__ = None;
                let mut if_return__ = None;
                let mut else_return__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::IfCondition => {
                            if if_condition__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ifCondition"));
                            }
                            if_condition__ = map_.next_value()?;
                        }
                        GeneratedField::IfReturn => {
                            if if_return__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ifReturn"));
                            }
                            if_return__ = map_.next_value()?;
                        }
                        GeneratedField::ElseReturn => {
                            if else_return__.is_some() {
                                return Err(serde::de::Error::duplicate_field("elseReturn"));
                            }
                            else_return__ = map_.next_value()?;
                        }
                    }
                }
                Ok(derivation_expression::IfElse {
                    if_condition: if_condition__,
                    if_return: if_return__,
                    else_return: else_return__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.DerivationExpression.IfElse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for derivation_expression::ReturnProgram {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.assignments.is_empty() {
            len += 1;
        }
        if self.final_expression.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.DerivationExpression.ReturnProgram", len)?;
        if !self.assignments.is_empty() {
            struct_ser.serialize_field("assignments", &self.assignments)?;
        }
        if let Some(v) = self.final_expression.as_ref() {
            struct_ser.serialize_field("finalExpression", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for derivation_expression::ReturnProgram {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "assignments",
            "final_expression",
            "finalExpression",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Assignments,
            FinalExpression,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "assignments" => Ok(GeneratedField::Assignments),
                            "finalExpression" | "final_expression" => Ok(GeneratedField::FinalExpression),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = derivation_expression::ReturnProgram;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.DerivationExpression.ReturnProgram")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<derivation_expression::ReturnProgram, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut assignments__ = None;
                let mut final_expression__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Assignments => {
                            if assignments__.is_some() {
                                return Err(serde::de::Error::duplicate_field("assignments"));
                            }
                            assignments__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FinalExpression => {
                            if final_expression__.is_some() {
                                return Err(serde::de::Error::duplicate_field("finalExpression"));
                            }
                            final_expression__ = map_.next_value()?;
                        }
                    }
                }
                Ok(derivation_expression::ReturnProgram {
                    assignments: assignments__.unwrap_or_default(),
                    final_expression: final_expression__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.DerivationExpression.ReturnProgram", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for derivation_expression::return_program::Assignment {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.name.is_empty() {
            len += 1;
        }
        if self.expression.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.DerivationExpression.ReturnProgram.Assignment", len)?;
        if !self.name.is_empty() {
            struct_ser.serialize_field("name", &self.name)?;
        }
        if let Some(v) = self.expression.as_ref() {
            struct_ser.serialize_field("expression", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for derivation_expression::return_program::Assignment {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "expression",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Expression,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "expression" => Ok(GeneratedField::Expression),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = derivation_expression::return_program::Assignment;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.DerivationExpression.ReturnProgram.Assignment")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<derivation_expression::return_program::Assignment, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut expression__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Expression => {
                            if expression__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expression"));
                            }
                            expression__ = map_.next_value()?;
                        }
                    }
                }
                Ok(derivation_expression::return_program::Assignment {
                    name: name__.unwrap_or_default(),
                    expression: expression__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.DerivationExpression.ReturnProgram.Assignment", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for derivation_expression::UnaryOp {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.op_type != 0 {
            len += 1;
        }
        if self.arg.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.DerivationExpression.UnaryOp", len)?;
        if self.op_type != 0 {
            let v = derivation_expression::unary_op::UnaryOpType::try_from(self.op_type)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.op_type)))?;
            struct_ser.serialize_field("opType", &v)?;
        }
        if let Some(v) = self.arg.as_ref() {
            struct_ser.serialize_field("arg", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for derivation_expression::UnaryOp {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "op_type",
            "opType",
            "arg",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            OpType,
            Arg,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "opType" | "op_type" => Ok(GeneratedField::OpType),
                            "arg" => Ok(GeneratedField::Arg),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = derivation_expression::UnaryOp;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.DerivationExpression.UnaryOp")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<derivation_expression::UnaryOp, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut op_type__ = None;
                let mut arg__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::OpType => {
                            if op_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("opType"));
                            }
                            op_type__ = Some(map_.next_value::<derivation_expression::unary_op::UnaryOpType>()? as i32);
                        }
                        GeneratedField::Arg => {
                            if arg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arg"));
                            }
                            arg__ = map_.next_value()?;
                        }
                    }
                }
                Ok(derivation_expression::UnaryOp {
                    op_type: op_type__.unwrap_or_default(),
                    arg: arg__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.DerivationExpression.UnaryOp", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for derivation_expression::unary_op::UnaryOpType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unspecified => "UNARY_OP_TYPE_UNSPECIFIED",
            Self::BooleanNot => "UNARY_OP_TYPE_BOOLEAN_NOT",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for derivation_expression::unary_op::UnaryOpType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "UNARY_OP_TYPE_UNSPECIFIED",
            "UNARY_OP_TYPE_BOOLEAN_NOT",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = derivation_expression::unary_op::UnaryOpType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "UNARY_OP_TYPE_UNSPECIFIED" => Ok(derivation_expression::unary_op::UnaryOpType::Unspecified),
                    "UNARY_OP_TYPE_BOOLEAN_NOT" => Ok(derivation_expression::unary_op::UnaryOpType::BooleanNot),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for DynamicParameter {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.r#type.is_some() {
            len += 1;
        }
        if self.parameter_reference != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.DynamicParameter", len)?;
        if let Some(v) = self.r#type.as_ref() {
            struct_ser.serialize_field("type", v)?;
        }
        if self.parameter_reference != 0 {
            struct_ser.serialize_field("parameterReference", &self.parameter_reference)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DynamicParameter {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "parameter_reference",
            "parameterReference",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            ParameterReference,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "parameterReference" | "parameter_reference" => Ok(GeneratedField::ParameterReference),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DynamicParameter;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.DynamicParameter")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DynamicParameter, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut parameter_reference__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = map_.next_value()?;
                        }
                        GeneratedField::ParameterReference => {
                            if parameter_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("parameterReference"));
                            }
                            parameter_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(DynamicParameter {
                    r#type: r#type__,
                    parameter_reference: parameter_reference__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.DynamicParameter", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DynamicParameterBinding {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.parameter_anchor != 0 {
            len += 1;
        }
        if self.value.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.DynamicParameterBinding", len)?;
        if self.parameter_anchor != 0 {
            struct_ser.serialize_field("parameterAnchor", &self.parameter_anchor)?;
        }
        if let Some(v) = self.value.as_ref() {
            struct_ser.serialize_field("value", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DynamicParameterBinding {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "parameter_anchor",
            "parameterAnchor",
            "value",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ParameterAnchor,
            Value,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "parameterAnchor" | "parameter_anchor" => Ok(GeneratedField::ParameterAnchor),
                            "value" => Ok(GeneratedField::Value),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DynamicParameterBinding;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.DynamicParameterBinding")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DynamicParameterBinding, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut parameter_anchor__ = None;
                let mut value__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ParameterAnchor => {
                            if parameter_anchor__.is_some() {
                                return Err(serde::de::Error::duplicate_field("parameterAnchor"));
                            }
                            parameter_anchor__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ = map_.next_value()?;
                        }
                    }
                }
                Ok(DynamicParameterBinding {
                    parameter_anchor: parameter_anchor__.unwrap_or_default(),
                    value: value__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.DynamicParameterBinding", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ExchangeRel {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.common.is_some() {
            len += 1;
        }
        if self.input.is_some() {
            len += 1;
        }
        if self.partition_count != 0 {
            len += 1;
        }
        if !self.targets.is_empty() {
            len += 1;
        }
        if self.advanced_extension.is_some() {
            len += 1;
        }
        if self.exchange_kind.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ExchangeRel", len)?;
        if let Some(v) = self.common.as_ref() {
            struct_ser.serialize_field("common", v)?;
        }
        if let Some(v) = self.input.as_ref() {
            struct_ser.serialize_field("input", v)?;
        }
        if self.partition_count != 0 {
            struct_ser.serialize_field("partitionCount", &self.partition_count)?;
        }
        if !self.targets.is_empty() {
            struct_ser.serialize_field("targets", &self.targets)?;
        }
        if let Some(v) = self.advanced_extension.as_ref() {
            struct_ser.serialize_field("advancedExtension", v)?;
        }
        if let Some(v) = self.exchange_kind.as_ref() {
            match v {
                exchange_rel::ExchangeKind::ScatterByFields(v) => {
                    struct_ser.serialize_field("scatterByFields", v)?;
                }
                exchange_rel::ExchangeKind::SingleTarget(v) => {
                    struct_ser.serialize_field("singleTarget", v)?;
                }
                exchange_rel::ExchangeKind::MultiTarget(v) => {
                    struct_ser.serialize_field("multiTarget", v)?;
                }
                exchange_rel::ExchangeKind::RoundRobin(v) => {
                    struct_ser.serialize_field("roundRobin", v)?;
                }
                exchange_rel::ExchangeKind::Broadcast(v) => {
                    struct_ser.serialize_field("broadcast", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ExchangeRel {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "common",
            "input",
            "partition_count",
            "partitionCount",
            "targets",
            "advanced_extension",
            "advancedExtension",
            "scatter_by_fields",
            "scatterByFields",
            "single_target",
            "singleTarget",
            "multi_target",
            "multiTarget",
            "round_robin",
            "roundRobin",
            "broadcast",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Common,
            Input,
            PartitionCount,
            Targets,
            AdvancedExtension,
            ScatterByFields,
            SingleTarget,
            MultiTarget,
            RoundRobin,
            Broadcast,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "common" => Ok(GeneratedField::Common),
                            "input" => Ok(GeneratedField::Input),
                            "partitionCount" | "partition_count" => Ok(GeneratedField::PartitionCount),
                            "targets" => Ok(GeneratedField::Targets),
                            "advancedExtension" | "advanced_extension" => Ok(GeneratedField::AdvancedExtension),
                            "scatterByFields" | "scatter_by_fields" => Ok(GeneratedField::ScatterByFields),
                            "singleTarget" | "single_target" => Ok(GeneratedField::SingleTarget),
                            "multiTarget" | "multi_target" => Ok(GeneratedField::MultiTarget),
                            "roundRobin" | "round_robin" => Ok(GeneratedField::RoundRobin),
                            "broadcast" => Ok(GeneratedField::Broadcast),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ExchangeRel;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ExchangeRel")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ExchangeRel, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut common__ = None;
                let mut input__ = None;
                let mut partition_count__ = None;
                let mut targets__ = None;
                let mut advanced_extension__ = None;
                let mut exchange_kind__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Common => {
                            if common__.is_some() {
                                return Err(serde::de::Error::duplicate_field("common"));
                            }
                            common__ = map_.next_value()?;
                        }
                        GeneratedField::Input => {
                            if input__.is_some() {
                                return Err(serde::de::Error::duplicate_field("input"));
                            }
                            input__ = map_.next_value()?;
                        }
                        GeneratedField::PartitionCount => {
                            if partition_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("partitionCount"));
                            }
                            partition_count__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Targets => {
                            if targets__.is_some() {
                                return Err(serde::de::Error::duplicate_field("targets"));
                            }
                            targets__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AdvancedExtension => {
                            if advanced_extension__.is_some() {
                                return Err(serde::de::Error::duplicate_field("advancedExtension"));
                            }
                            advanced_extension__ = map_.next_value()?;
                        }
                        GeneratedField::ScatterByFields => {
                            if exchange_kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("scatterByFields"));
                            }
                            exchange_kind__ = map_.next_value::<::std::option::Option<_>>()?.map(exchange_rel::ExchangeKind::ScatterByFields)
;
                        }
                        GeneratedField::SingleTarget => {
                            if exchange_kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("singleTarget"));
                            }
                            exchange_kind__ = map_.next_value::<::std::option::Option<_>>()?.map(exchange_rel::ExchangeKind::SingleTarget)
;
                        }
                        GeneratedField::MultiTarget => {
                            if exchange_kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("multiTarget"));
                            }
                            exchange_kind__ = map_.next_value::<::std::option::Option<_>>()?.map(exchange_rel::ExchangeKind::MultiTarget)
;
                        }
                        GeneratedField::RoundRobin => {
                            if exchange_kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("roundRobin"));
                            }
                            exchange_kind__ = map_.next_value::<::std::option::Option<_>>()?.map(exchange_rel::ExchangeKind::RoundRobin)
;
                        }
                        GeneratedField::Broadcast => {
                            if exchange_kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("broadcast"));
                            }
                            exchange_kind__ = map_.next_value::<::std::option::Option<_>>()?.map(exchange_rel::ExchangeKind::Broadcast)
;
                        }
                    }
                }
                Ok(ExchangeRel {
                    common: common__,
                    input: input__,
                    partition_count: partition_count__.unwrap_or_default(),
                    targets: targets__.unwrap_or_default(),
                    advanced_extension: advanced_extension__,
                    exchange_kind: exchange_kind__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.ExchangeRel", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for exchange_rel::Broadcast {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("substrait.ExchangeRel.Broadcast", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for exchange_rel::Broadcast {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = exchange_rel::Broadcast;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ExchangeRel.Broadcast")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<exchange_rel::Broadcast, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(exchange_rel::Broadcast {
                })
            }
        }
        deserializer.deserialize_struct("substrait.ExchangeRel.Broadcast", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for exchange_rel::ExchangeTarget {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.partition_id.is_empty() {
            len += 1;
        }
        if self.target_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ExchangeRel.ExchangeTarget", len)?;
        if !self.partition_id.is_empty() {
            struct_ser.serialize_field("partitionId", &self.partition_id)?;
        }
        if let Some(v) = self.target_type.as_ref() {
            match v {
                exchange_rel::exchange_target::TargetType::Uri(v) => {
                    struct_ser.serialize_field("uri", v)?;
                }
                exchange_rel::exchange_target::TargetType::Extended(v) => {
                    struct_ser.serialize_field("extended", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for exchange_rel::ExchangeTarget {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "partition_id",
            "partitionId",
            "uri",
            "extended",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PartitionId,
            Uri,
            Extended,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "partitionId" | "partition_id" => Ok(GeneratedField::PartitionId),
                            "uri" => Ok(GeneratedField::Uri),
                            "extended" => Ok(GeneratedField::Extended),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = exchange_rel::ExchangeTarget;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ExchangeRel.ExchangeTarget")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<exchange_rel::ExchangeTarget, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut partition_id__ = None;
                let mut target_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PartitionId => {
                            if partition_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("partitionId"));
                            }
                            partition_id__ =
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::Uri => {
                            if target_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("uri"));
                            }
                            target_type__ = map_.next_value::<::std::option::Option<_>>()?.map(exchange_rel::exchange_target::TargetType::Uri);
                        }
                        GeneratedField::Extended => {
                            if target_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("extended"));
                            }
                            target_type__ = map_.next_value::<::std::option::Option<_>>()?.map(exchange_rel::exchange_target::TargetType::Extended)
;
                        }
                    }
                }
                Ok(exchange_rel::ExchangeTarget {
                    partition_id: partition_id__.unwrap_or_default(),
                    target_type: target_type__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.ExchangeRel.ExchangeTarget", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for exchange_rel::MultiBucketExpression {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.expression.is_some() {
            len += 1;
        }
        if self.constrained_to_count {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ExchangeRel.MultiBucketExpression", len)?;
        if let Some(v) = self.expression.as_ref() {
            struct_ser.serialize_field("expression", v)?;
        }
        if self.constrained_to_count {
            struct_ser.serialize_field("constrainedToCount", &self.constrained_to_count)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for exchange_rel::MultiBucketExpression {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "expression",
            "constrained_to_count",
            "constrainedToCount",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Expression,
            ConstrainedToCount,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "expression" => Ok(GeneratedField::Expression),
                            "constrainedToCount" | "constrained_to_count" => Ok(GeneratedField::ConstrainedToCount),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = exchange_rel::MultiBucketExpression;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ExchangeRel.MultiBucketExpression")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<exchange_rel::MultiBucketExpression, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut expression__ = None;
                let mut constrained_to_count__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Expression => {
                            if expression__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expression"));
                            }
                            expression__ = map_.next_value()?;
                        }
                        GeneratedField::ConstrainedToCount => {
                            if constrained_to_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("constrainedToCount"));
                            }
                            constrained_to_count__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(exchange_rel::MultiBucketExpression {
                    expression: expression__,
                    constrained_to_count: constrained_to_count__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.ExchangeRel.MultiBucketExpression", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for exchange_rel::RoundRobin {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.exact {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ExchangeRel.RoundRobin", len)?;
        if self.exact {
            struct_ser.serialize_field("exact", &self.exact)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for exchange_rel::RoundRobin {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "exact",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Exact,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "exact" => Ok(GeneratedField::Exact),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = exchange_rel::RoundRobin;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ExchangeRel.RoundRobin")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<exchange_rel::RoundRobin, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut exact__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Exact => {
                            if exact__.is_some() {
                                return Err(serde::de::Error::duplicate_field("exact"));
                            }
                            exact__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(exchange_rel::RoundRobin {
                    exact: exact__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.ExchangeRel.RoundRobin", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for exchange_rel::ScatterFields {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.fields.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ExchangeRel.ScatterFields", len)?;
        if !self.fields.is_empty() {
            struct_ser.serialize_field("fields", &self.fields)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for exchange_rel::ScatterFields {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "fields",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Fields,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "fields" => Ok(GeneratedField::Fields),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = exchange_rel::ScatterFields;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ExchangeRel.ScatterFields")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<exchange_rel::ScatterFields, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut fields__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Fields => {
                            if fields__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fields"));
                            }
                            fields__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(exchange_rel::ScatterFields {
                    fields: fields__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.ExchangeRel.ScatterFields", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for exchange_rel::SingleBucketExpression {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.expression.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ExchangeRel.SingleBucketExpression", len)?;
        if let Some(v) = self.expression.as_ref() {
            struct_ser.serialize_field("expression", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for exchange_rel::SingleBucketExpression {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "expression",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Expression,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "expression" => Ok(GeneratedField::Expression),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = exchange_rel::SingleBucketExpression;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ExchangeRel.SingleBucketExpression")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<exchange_rel::SingleBucketExpression, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut expression__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Expression => {
                            if expression__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expression"));
                            }
                            expression__ = map_.next_value()?;
                        }
                    }
                }
                Ok(exchange_rel::SingleBucketExpression {
                    expression: expression__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.ExchangeRel.SingleBucketExpression", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ExpandRel {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.common.is_some() {
            len += 1;
        }
        if self.input.is_some() {
            len += 1;
        }
        if !self.fields.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ExpandRel", len)?;
        if let Some(v) = self.common.as_ref() {
            struct_ser.serialize_field("common", v)?;
        }
        if let Some(v) = self.input.as_ref() {
            struct_ser.serialize_field("input", v)?;
        }
        if !self.fields.is_empty() {
            struct_ser.serialize_field("fields", &self.fields)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ExpandRel {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "common",
            "input",
            "fields",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Common,
            Input,
            Fields,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "common" => Ok(GeneratedField::Common),
                            "input" => Ok(GeneratedField::Input),
                            "fields" => Ok(GeneratedField::Fields),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ExpandRel;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ExpandRel")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ExpandRel, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut common__ = None;
                let mut input__ = None;
                let mut fields__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Common => {
                            if common__.is_some() {
                                return Err(serde::de::Error::duplicate_field("common"));
                            }
                            common__ = map_.next_value()?;
                        }
                        GeneratedField::Input => {
                            if input__.is_some() {
                                return Err(serde::de::Error::duplicate_field("input"));
                            }
                            input__ = map_.next_value()?;
                        }
                        GeneratedField::Fields => {
                            if fields__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fields"));
                            }
                            fields__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(ExpandRel {
                    common: common__,
                    input: input__,
                    fields: fields__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.ExpandRel", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expand_rel::ExpandField {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.field_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ExpandRel.ExpandField", len)?;
        if let Some(v) = self.field_type.as_ref() {
            match v {
                expand_rel::expand_field::FieldType::SwitchingField(v) => {
                    struct_ser.serialize_field("switchingField", v)?;
                }
                expand_rel::expand_field::FieldType::ConsistentField(v) => {
                    struct_ser.serialize_field("consistentField", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expand_rel::ExpandField {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "switching_field",
            "switchingField",
            "consistent_field",
            "consistentField",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SwitchingField,
            ConsistentField,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "switchingField" | "switching_field" => Ok(GeneratedField::SwitchingField),
                            "consistentField" | "consistent_field" => Ok(GeneratedField::ConsistentField),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expand_rel::ExpandField;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ExpandRel.ExpandField")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expand_rel::ExpandField, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut field_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SwitchingField => {
                            if field_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("switchingField"));
                            }
                            field_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expand_rel::expand_field::FieldType::SwitchingField)
;
                        }
                        GeneratedField::ConsistentField => {
                            if field_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("consistentField"));
                            }
                            field_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expand_rel::expand_field::FieldType::ConsistentField)
;
                        }
                    }
                }
                Ok(expand_rel::ExpandField {
                    field_type: field_type__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.ExpandRel.ExpandField", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expand_rel::SwitchingField {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.duplicates.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ExpandRel.SwitchingField", len)?;
        if !self.duplicates.is_empty() {
            struct_ser.serialize_field("duplicates", &self.duplicates)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expand_rel::SwitchingField {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "duplicates",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Duplicates,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "duplicates" => Ok(GeneratedField::Duplicates),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expand_rel::SwitchingField;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ExpandRel.SwitchingField")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expand_rel::SwitchingField, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut duplicates__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Duplicates => {
                            if duplicates__.is_some() {
                                return Err(serde::de::Error::duplicate_field("duplicates"));
                            }
                            duplicates__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(expand_rel::SwitchingField {
                    duplicates: duplicates__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.ExpandRel.SwitchingField", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Expression {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.rex_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression", len)?;
        if let Some(v) = self.rex_type.as_ref() {
            match v {
                expression::RexType::Literal(v) => {
                    struct_ser.serialize_field("literal", v)?;
                }
                expression::RexType::Selection(v) => {
                    struct_ser.serialize_field("selection", v)?;
                }
                expression::RexType::ScalarFunction(v) => {
                    struct_ser.serialize_field("scalarFunction", v)?;
                }
                expression::RexType::WindowFunction(v) => {
                    struct_ser.serialize_field("windowFunction", v)?;
                }
                expression::RexType::IfThen(v) => {
                    struct_ser.serialize_field("ifThen", v)?;
                }
                expression::RexType::SwitchExpression(v) => {
                    struct_ser.serialize_field("switchExpression", v)?;
                }
                expression::RexType::SingularOrList(v) => {
                    struct_ser.serialize_field("singularOrList", v)?;
                }
                expression::RexType::MultiOrList(v) => {
                    struct_ser.serialize_field("multiOrList", v)?;
                }
                expression::RexType::Cast(v) => {
                    struct_ser.serialize_field("cast", v)?;
                }
                expression::RexType::Subquery(v) => {
                    struct_ser.serialize_field("subquery", v)?;
                }
                expression::RexType::Nested(v) => {
                    struct_ser.serialize_field("nested", v)?;
                }
                expression::RexType::DynamicParameter(v) => {
                    struct_ser.serialize_field("dynamicParameter", v)?;
                }
                expression::RexType::Enum(v) => {
                    struct_ser.serialize_field("enum", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Expression {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "literal",
            "selection",
            "scalar_function",
            "scalarFunction",
            "window_function",
            "windowFunction",
            "if_then",
            "ifThen",
            "switch_expression",
            "switchExpression",
            "singular_or_list",
            "singularOrList",
            "multi_or_list",
            "multiOrList",
            "cast",
            "subquery",
            "nested",
            "dynamic_parameter",
            "dynamicParameter",
            "enum",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Literal,
            Selection,
            ScalarFunction,
            WindowFunction,
            IfThen,
            SwitchExpression,
            SingularOrList,
            MultiOrList,
            Cast,
            Subquery,
            Nested,
            DynamicParameter,
            Enum,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "literal" => Ok(GeneratedField::Literal),
                            "selection" => Ok(GeneratedField::Selection),
                            "scalarFunction" | "scalar_function" => Ok(GeneratedField::ScalarFunction),
                            "windowFunction" | "window_function" => Ok(GeneratedField::WindowFunction),
                            "ifThen" | "if_then" => Ok(GeneratedField::IfThen),
                            "switchExpression" | "switch_expression" => Ok(GeneratedField::SwitchExpression),
                            "singularOrList" | "singular_or_list" => Ok(GeneratedField::SingularOrList),
                            "multiOrList" | "multi_or_list" => Ok(GeneratedField::MultiOrList),
                            "cast" => Ok(GeneratedField::Cast),
                            "subquery" => Ok(GeneratedField::Subquery),
                            "nested" => Ok(GeneratedField::Nested),
                            "dynamicParameter" | "dynamic_parameter" => Ok(GeneratedField::DynamicParameter),
                            "enum" => Ok(GeneratedField::Enum),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Expression;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Expression, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut rex_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Literal => {
                            if rex_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("literal"));
                            }
                            rex_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::RexType::Literal)
;
                        }
                        GeneratedField::Selection => {
                            if rex_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("selection"));
                            }
                            rex_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::RexType::Selection)
;
                        }
                        GeneratedField::ScalarFunction => {
                            if rex_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("scalarFunction"));
                            }
                            rex_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::RexType::ScalarFunction)
;
                        }
                        GeneratedField::WindowFunction => {
                            if rex_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("windowFunction"));
                            }
                            rex_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::RexType::WindowFunction)
;
                        }
                        GeneratedField::IfThen => {
                            if rex_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ifThen"));
                            }
                            rex_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::RexType::IfThen)
;
                        }
                        GeneratedField::SwitchExpression => {
                            if rex_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("switchExpression"));
                            }
                            rex_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::RexType::SwitchExpression)
;
                        }
                        GeneratedField::SingularOrList => {
                            if rex_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("singularOrList"));
                            }
                            rex_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::RexType::SingularOrList)
;
                        }
                        GeneratedField::MultiOrList => {
                            if rex_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("multiOrList"));
                            }
                            rex_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::RexType::MultiOrList)
;
                        }
                        GeneratedField::Cast => {
                            if rex_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cast"));
                            }
                            rex_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::RexType::Cast)
;
                        }
                        GeneratedField::Subquery => {
                            if rex_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subquery"));
                            }
                            rex_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::RexType::Subquery)
;
                        }
                        GeneratedField::Nested => {
                            if rex_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nested"));
                            }
                            rex_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::RexType::Nested)
;
                        }
                        GeneratedField::DynamicParameter => {
                            if rex_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dynamicParameter"));
                            }
                            rex_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::RexType::DynamicParameter)
;
                        }
                        GeneratedField::Enum => {
                            if rex_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("enum"));
                            }
                            rex_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::RexType::Enum)
;
                        }
                    }
                }
                Ok(Expression {
                    rex_type: rex_type__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::Cast {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.r#type.is_some() {
            len += 1;
        }
        if self.input.is_some() {
            len += 1;
        }
        if self.failure_behavior != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.Cast", len)?;
        if let Some(v) = self.r#type.as_ref() {
            struct_ser.serialize_field("type", v)?;
        }
        if let Some(v) = self.input.as_ref() {
            struct_ser.serialize_field("input", v)?;
        }
        if self.failure_behavior != 0 {
            let v = expression::cast::FailureBehavior::try_from(self.failure_behavior)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.failure_behavior)))?;
            struct_ser.serialize_field("failureBehavior", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::Cast {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "input",
            "failure_behavior",
            "failureBehavior",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Input,
            FailureBehavior,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "input" => Ok(GeneratedField::Input),
                            "failureBehavior" | "failure_behavior" => Ok(GeneratedField::FailureBehavior),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::Cast;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.Cast")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::Cast, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut input__ = None;
                let mut failure_behavior__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = map_.next_value()?;
                        }
                        GeneratedField::Input => {
                            if input__.is_some() {
                                return Err(serde::de::Error::duplicate_field("input"));
                            }
                            input__ = map_.next_value()?;
                        }
                        GeneratedField::FailureBehavior => {
                            if failure_behavior__.is_some() {
                                return Err(serde::de::Error::duplicate_field("failureBehavior"));
                            }
                            failure_behavior__ = Some(map_.next_value::<expression::cast::FailureBehavior>()? as i32);
                        }
                    }
                }
                Ok(expression::Cast {
                    r#type: r#type__,
                    input: input__,
                    failure_behavior: failure_behavior__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.Cast", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::cast::FailureBehavior {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unspecified => "FAILURE_BEHAVIOR_UNSPECIFIED",
            Self::ReturnNull => "FAILURE_BEHAVIOR_RETURN_NULL",
            Self::ThrowException => "FAILURE_BEHAVIOR_THROW_EXCEPTION",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for expression::cast::FailureBehavior {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "FAILURE_BEHAVIOR_UNSPECIFIED",
            "FAILURE_BEHAVIOR_RETURN_NULL",
            "FAILURE_BEHAVIOR_THROW_EXCEPTION",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::cast::FailureBehavior;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "FAILURE_BEHAVIOR_UNSPECIFIED" => Ok(expression::cast::FailureBehavior::Unspecified),
                    "FAILURE_BEHAVIOR_RETURN_NULL" => Ok(expression::cast::FailureBehavior::ReturnNull),
                    "FAILURE_BEHAVIOR_THROW_EXCEPTION" => Ok(expression::cast::FailureBehavior::ThrowException),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for expression::EmbeddedFunction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.arguments.is_empty() {
            len += 1;
        }
        if self.output_type.is_some() {
            len += 1;
        }
        if self.kind.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.EmbeddedFunction", len)?;
        if !self.arguments.is_empty() {
            struct_ser.serialize_field("arguments", &self.arguments)?;
        }
        if let Some(v) = self.output_type.as_ref() {
            struct_ser.serialize_field("outputType", v)?;
        }
        if let Some(v) = self.kind.as_ref() {
            match v {
                expression::embedded_function::Kind::PythonPickleFunction(v) => {
                    struct_ser.serialize_field("pythonPickleFunction", v)?;
                }
                expression::embedded_function::Kind::WebAssemblyFunction(v) => {
                    struct_ser.serialize_field("webAssemblyFunction", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::EmbeddedFunction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "arguments",
            "output_type",
            "outputType",
            "python_pickle_function",
            "pythonPickleFunction",
            "web_assembly_function",
            "webAssemblyFunction",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Arguments,
            OutputType,
            PythonPickleFunction,
            WebAssemblyFunction,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "arguments" => Ok(GeneratedField::Arguments),
                            "outputType" | "output_type" => Ok(GeneratedField::OutputType),
                            "pythonPickleFunction" | "python_pickle_function" => Ok(GeneratedField::PythonPickleFunction),
                            "webAssemblyFunction" | "web_assembly_function" => Ok(GeneratedField::WebAssemblyFunction),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::EmbeddedFunction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.EmbeddedFunction")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::EmbeddedFunction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut arguments__ = None;
                let mut output_type__ = None;
                let mut kind__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Arguments => {
                            if arguments__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arguments"));
                            }
                            arguments__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OutputType => {
                            if output_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("outputType"));
                            }
                            output_type__ = map_.next_value()?;
                        }
                        GeneratedField::PythonPickleFunction => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pythonPickleFunction"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::embedded_function::Kind::PythonPickleFunction)
;
                        }
                        GeneratedField::WebAssemblyFunction => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("webAssemblyFunction"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::embedded_function::Kind::WebAssemblyFunction)
;
                        }
                    }
                }
                Ok(expression::EmbeddedFunction {
                    arguments: arguments__.unwrap_or_default(),
                    output_type: output_type__,
                    kind: kind__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.EmbeddedFunction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::embedded_function::PythonPickleFunction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.function.is_empty() {
            len += 1;
        }
        if !self.prerequisite.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.EmbeddedFunction.PythonPickleFunction", len)?;
        if !self.function.is_empty() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("function", pbjson::private::base64::encode(&self.function).as_str())?;
        }
        if !self.prerequisite.is_empty() {
            struct_ser.serialize_field("prerequisite", &self.prerequisite)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::embedded_function::PythonPickleFunction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "function",
            "prerequisite",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Function,
            Prerequisite,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "function" => Ok(GeneratedField::Function),
                            "prerequisite" => Ok(GeneratedField::Prerequisite),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::embedded_function::PythonPickleFunction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.EmbeddedFunction.PythonPickleFunction")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::embedded_function::PythonPickleFunction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut function__ = None;
                let mut prerequisite__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Function => {
                            if function__.is_some() {
                                return Err(serde::de::Error::duplicate_field("function"));
                            }
                            function__ =
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Prerequisite => {
                            if prerequisite__.is_some() {
                                return Err(serde::de::Error::duplicate_field("prerequisite"));
                            }
                            prerequisite__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(expression::embedded_function::PythonPickleFunction {
                    function: function__.unwrap_or_default(),
                    prerequisite: prerequisite__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.EmbeddedFunction.PythonPickleFunction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::embedded_function::WebAssemblyFunction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.script.is_empty() {
            len += 1;
        }
        if !self.prerequisite.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.EmbeddedFunction.WebAssemblyFunction", len)?;
        if !self.script.is_empty() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("script", pbjson::private::base64::encode(&self.script).as_str())?;
        }
        if !self.prerequisite.is_empty() {
            struct_ser.serialize_field("prerequisite", &self.prerequisite)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::embedded_function::WebAssemblyFunction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "script",
            "prerequisite",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Script,
            Prerequisite,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "script" => Ok(GeneratedField::Script),
                            "prerequisite" => Ok(GeneratedField::Prerequisite),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::embedded_function::WebAssemblyFunction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.EmbeddedFunction.WebAssemblyFunction")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::embedded_function::WebAssemblyFunction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut script__ = None;
                let mut prerequisite__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Script => {
                            if script__.is_some() {
                                return Err(serde::de::Error::duplicate_field("script"));
                            }
                            script__ =
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Prerequisite => {
                            if prerequisite__.is_some() {
                                return Err(serde::de::Error::duplicate_field("prerequisite"));
                            }
                            prerequisite__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(expression::embedded_function::WebAssemblyFunction {
                    script: script__.unwrap_or_default(),
                    prerequisite: prerequisite__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.EmbeddedFunction.WebAssemblyFunction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::Enum {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.enum_kind.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.Enum", len)?;
        if let Some(v) = self.enum_kind.as_ref() {
            match v {
                expression::r#enum::EnumKind::Specified(v) => {
                    struct_ser.serialize_field("specified", v)?;
                }
                expression::r#enum::EnumKind::Unspecified(v) => {
                    struct_ser.serialize_field("unspecified", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::Enum {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "specified",
            "unspecified",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Specified,
            Unspecified,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "specified" => Ok(GeneratedField::Specified),
                            "unspecified" => Ok(GeneratedField::Unspecified),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::Enum;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.Enum")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::Enum, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut enum_kind__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Specified => {
                            if enum_kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("specified"));
                            }
                            enum_kind__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::r#enum::EnumKind::Specified);
                        }
                        GeneratedField::Unspecified => {
                            if enum_kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("unspecified"));
                            }
                            enum_kind__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::r#enum::EnumKind::Unspecified)
;
                        }
                    }
                }
                Ok(expression::Enum {
                    enum_kind: enum_kind__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.Enum", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::r#enum::Empty {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("substrait.Expression.Enum.Empty", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::r#enum::Empty {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::r#enum::Empty;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.Enum.Empty")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::r#enum::Empty, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(expression::r#enum::Empty {
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.Enum.Empty", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::FieldReference {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.reference_type.is_some() {
            len += 1;
        }
        if self.root_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.FieldReference", len)?;
        if let Some(v) = self.reference_type.as_ref() {
            match v {
                expression::field_reference::ReferenceType::DirectReference(v) => {
                    struct_ser.serialize_field("directReference", v)?;
                }
                expression::field_reference::ReferenceType::MaskedReference(v) => {
                    struct_ser.serialize_field("maskedReference", v)?;
                }
            }
        }
        if let Some(v) = self.root_type.as_ref() {
            match v {
                expression::field_reference::RootType::Expression(v) => {
                    struct_ser.serialize_field("expression", v)?;
                }
                expression::field_reference::RootType::RootReference(v) => {
                    struct_ser.serialize_field("rootReference", v)?;
                }
                expression::field_reference::RootType::OuterReference(v) => {
                    struct_ser.serialize_field("outerReference", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::FieldReference {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "direct_reference",
            "directReference",
            "masked_reference",
            "maskedReference",
            "expression",
            "root_reference",
            "rootReference",
            "outer_reference",
            "outerReference",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DirectReference,
            MaskedReference,
            Expression,
            RootReference,
            OuterReference,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "directReference" | "direct_reference" => Ok(GeneratedField::DirectReference),
                            "maskedReference" | "masked_reference" => Ok(GeneratedField::MaskedReference),
                            "expression" => Ok(GeneratedField::Expression),
                            "rootReference" | "root_reference" => Ok(GeneratedField::RootReference),
                            "outerReference" | "outer_reference" => Ok(GeneratedField::OuterReference),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::FieldReference;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.FieldReference")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::FieldReference, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut reference_type__ = None;
                let mut root_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DirectReference => {
                            if reference_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("directReference"));
                            }
                            reference_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::field_reference::ReferenceType::DirectReference)
;
                        }
                        GeneratedField::MaskedReference => {
                            if reference_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("maskedReference"));
                            }
                            reference_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::field_reference::ReferenceType::MaskedReference)
;
                        }
                        GeneratedField::Expression => {
                            if root_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expression"));
                            }
                            root_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::field_reference::RootType::Expression)
;
                        }
                        GeneratedField::RootReference => {
                            if root_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rootReference"));
                            }
                            root_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::field_reference::RootType::RootReference)
;
                        }
                        GeneratedField::OuterReference => {
                            if root_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("outerReference"));
                            }
                            root_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::field_reference::RootType::OuterReference)
;
                        }
                    }
                }
                Ok(expression::FieldReference {
                    reference_type: reference_type__,
                    root_type: root_type__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.FieldReference", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::field_reference::OuterReference {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.steps_out != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.FieldReference.OuterReference", len)?;
        if self.steps_out != 0 {
            struct_ser.serialize_field("stepsOut", &self.steps_out)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::field_reference::OuterReference {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "steps_out",
            "stepsOut",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            StepsOut,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "stepsOut" | "steps_out" => Ok(GeneratedField::StepsOut),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::field_reference::OuterReference;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.FieldReference.OuterReference")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::field_reference::OuterReference, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut steps_out__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::StepsOut => {
                            if steps_out__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stepsOut"));
                            }
                            steps_out__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(expression::field_reference::OuterReference {
                    steps_out: steps_out__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.FieldReference.OuterReference", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::field_reference::RootReference {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("substrait.Expression.FieldReference.RootReference", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::field_reference::RootReference {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::field_reference::RootReference;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.FieldReference.RootReference")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::field_reference::RootReference, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(expression::field_reference::RootReference {
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.FieldReference.RootReference", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::IfThen {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.ifs.is_empty() {
            len += 1;
        }
        if self.r#else.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.IfThen", len)?;
        if !self.ifs.is_empty() {
            struct_ser.serialize_field("ifs", &self.ifs)?;
        }
        if let Some(v) = self.r#else.as_ref() {
            struct_ser.serialize_field("else", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::IfThen {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ifs",
            "else",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Ifs,
            Else,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ifs" => Ok(GeneratedField::Ifs),
                            "else" => Ok(GeneratedField::Else),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::IfThen;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.IfThen")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::IfThen, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut ifs__ = None;
                let mut r#else__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Ifs => {
                            if ifs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ifs"));
                            }
                            ifs__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Else => {
                            if r#else__.is_some() {
                                return Err(serde::de::Error::duplicate_field("else"));
                            }
                            r#else__ = map_.next_value()?;
                        }
                    }
                }
                Ok(expression::IfThen {
                    ifs: ifs__.unwrap_or_default(),
                    r#else: r#else__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.IfThen", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::if_then::IfClause {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.r#if.is_some() {
            len += 1;
        }
        if self.then.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.IfThen.IfClause", len)?;
        if let Some(v) = self.r#if.as_ref() {
            struct_ser.serialize_field("if", v)?;
        }
        if let Some(v) = self.then.as_ref() {
            struct_ser.serialize_field("then", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::if_then::IfClause {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "if",
            "then",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            If,
            Then,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "if" => Ok(GeneratedField::If),
                            "then" => Ok(GeneratedField::Then),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::if_then::IfClause;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.IfThen.IfClause")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::if_then::IfClause, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#if__ = None;
                let mut then__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::If => {
                            if r#if__.is_some() {
                                return Err(serde::de::Error::duplicate_field("if"));
                            }
                            r#if__ = map_.next_value()?;
                        }
                        GeneratedField::Then => {
                            if then__.is_some() {
                                return Err(serde::de::Error::duplicate_field("then"));
                            }
                            then__ = map_.next_value()?;
                        }
                    }
                }
                Ok(expression::if_then::IfClause {
                    r#if: r#if__,
                    then: then__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.IfThen.IfClause", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::Literal {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.nullable {
            len += 1;
        }
        if self.type_variation_reference != 0 {
            len += 1;
        }
        if self.literal_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.Literal", len)?;
        if self.nullable {
            struct_ser.serialize_field("nullable", &self.nullable)?;
        }
        if self.type_variation_reference != 0 {
            struct_ser.serialize_field("typeVariationReference", &self.type_variation_reference)?;
        }
        if let Some(v) = self.literal_type.as_ref() {
            match v {
                expression::literal::LiteralType::Boolean(v) => {
                    struct_ser.serialize_field("boolean", v)?;
                }
                expression::literal::LiteralType::I8(v) => {
                    struct_ser.serialize_field("i8", v)?;
                }
                expression::literal::LiteralType::I16(v) => {
                    struct_ser.serialize_field("i16", v)?;
                }
                expression::literal::LiteralType::I32(v) => {
                    struct_ser.serialize_field("i32", v)?;
                }
                expression::literal::LiteralType::I64(v) => {
                    #[allow(clippy::needless_borrow)]
                    #[allow(clippy::needless_borrows_for_generic_args)]
                    struct_ser.serialize_field("i64", ToString::to_string(&v).as_str())?;
                }
                expression::literal::LiteralType::Fp32(v) => {
                    struct_ser.serialize_field("fp32", v)?;
                }
                expression::literal::LiteralType::Fp64(v) => {
                    struct_ser.serialize_field("fp64", v)?;
                }
                expression::literal::LiteralType::String(v) => {
                    struct_ser.serialize_field("string", v)?;
                }
                expression::literal::LiteralType::Binary(v) => {
                    #[allow(clippy::needless_borrow)]
                    #[allow(clippy::needless_borrows_for_generic_args)]
                    struct_ser.serialize_field("binary", pbjson::private::base64::encode(&v).as_str())?;
                }
                expression::literal::LiteralType::Timestamp(v) => {
                    #[allow(clippy::needless_borrow)]
                    #[allow(clippy::needless_borrows_for_generic_args)]
                    struct_ser.serialize_field("timestamp", ToString::to_string(&v).as_str())?;
                }
                expression::literal::LiteralType::Date(v) => {
                    struct_ser.serialize_field("date", v)?;
                }
                expression::literal::LiteralType::Time(v) => {
                    #[allow(clippy::needless_borrow)]
                    #[allow(clippy::needless_borrows_for_generic_args)]
                    struct_ser.serialize_field("time", ToString::to_string(&v).as_str())?;
                }
                expression::literal::LiteralType::IntervalYearToMonth(v) => {
                    struct_ser.serialize_field("intervalYearToMonth", v)?;
                }
                expression::literal::LiteralType::IntervalDayToSecond(v) => {
                    struct_ser.serialize_field("intervalDayToSecond", v)?;
                }
                expression::literal::LiteralType::IntervalCompound(v) => {
                    struct_ser.serialize_field("intervalCompound", v)?;
                }
                expression::literal::LiteralType::FixedChar(v) => {
                    struct_ser.serialize_field("fixedChar", v)?;
                }
                expression::literal::LiteralType::VarChar(v) => {
                    struct_ser.serialize_field("varChar", v)?;
                }
                expression::literal::LiteralType::FixedBinary(v) => {
                    #[allow(clippy::needless_borrow)]
                    #[allow(clippy::needless_borrows_for_generic_args)]
                    struct_ser.serialize_field("fixedBinary", pbjson::private::base64::encode(&v).as_str())?;
                }
                expression::literal::LiteralType::Decimal(v) => {
                    struct_ser.serialize_field("decimal", v)?;
                }
                expression::literal::LiteralType::PrecisionTime(v) => {
                    struct_ser.serialize_field("precisionTime", v)?;
                }
                expression::literal::LiteralType::PrecisionTimestamp(v) => {
                    struct_ser.serialize_field("precisionTimestamp", v)?;
                }
                expression::literal::LiteralType::PrecisionTimestampTz(v) => {
                    struct_ser.serialize_field("precisionTimestampTz", v)?;
                }
                expression::literal::LiteralType::Struct(v) => {
                    struct_ser.serialize_field("struct", v)?;
                }
                expression::literal::LiteralType::Map(v) => {
                    struct_ser.serialize_field("map", v)?;
                }
                expression::literal::LiteralType::TimestampTz(v) => {
                    #[allow(clippy::needless_borrow)]
                    #[allow(clippy::needless_borrows_for_generic_args)]
                    struct_ser.serialize_field("timestampTz", ToString::to_string(&v).as_str())?;
                }
                expression::literal::LiteralType::Uuid(v) => {
                    #[allow(clippy::needless_borrow)]
                    #[allow(clippy::needless_borrows_for_generic_args)]
                    struct_ser.serialize_field("uuid", pbjson::private::base64::encode(&v).as_str())?;
                }
                expression::literal::LiteralType::Null(v) => {
                    struct_ser.serialize_field("null", v)?;
                }
                expression::literal::LiteralType::List(v) => {
                    struct_ser.serialize_field("list", v)?;
                }
                expression::literal::LiteralType::EmptyList(v) => {
                    struct_ser.serialize_field("emptyList", v)?;
                }
                expression::literal::LiteralType::EmptyMap(v) => {
                    struct_ser.serialize_field("emptyMap", v)?;
                }
                expression::literal::LiteralType::UserDefined(v) => {
                    struct_ser.serialize_field("userDefined", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::Literal {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "nullable",
            "type_variation_reference",
            "typeVariationReference",
            "boolean",
            "i8",
            "i16",
            "i32",
            "i64",
            "fp32",
            "fp64",
            "string",
            "binary",
            "timestamp",
            "date",
            "time",
            "interval_year_to_month",
            "intervalYearToMonth",
            "interval_day_to_second",
            "intervalDayToSecond",
            "interval_compound",
            "intervalCompound",
            "fixed_char",
            "fixedChar",
            "var_char",
            "varChar",
            "fixed_binary",
            "fixedBinary",
            "decimal",
            "precision_time",
            "precisionTime",
            "precision_timestamp",
            "precisionTimestamp",
            "precision_timestamp_tz",
            "precisionTimestampTz",
            "struct",
            "map",
            "timestamp_tz",
            "timestampTz",
            "uuid",
            "null",
            "list",
            "empty_list",
            "emptyList",
            "empty_map",
            "emptyMap",
            "user_defined",
            "userDefined",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Nullable,
            TypeVariationReference,
            Boolean,
            I8,
            I16,
            I32,
            I64,
            Fp32,
            Fp64,
            String,
            Binary,
            Timestamp,
            Date,
            Time,
            IntervalYearToMonth,
            IntervalDayToSecond,
            IntervalCompound,
            FixedChar,
            VarChar,
            FixedBinary,
            Decimal,
            PrecisionTime,
            PrecisionTimestamp,
            PrecisionTimestampTz,
            Struct,
            Map,
            TimestampTz,
            Uuid,
            Null,
            List,
            EmptyList,
            EmptyMap,
            UserDefined,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "nullable" => Ok(GeneratedField::Nullable),
                            "typeVariationReference" | "type_variation_reference" => Ok(GeneratedField::TypeVariationReference),
                            "boolean" => Ok(GeneratedField::Boolean),
                            "i8" => Ok(GeneratedField::I8),
                            "i16" => Ok(GeneratedField::I16),
                            "i32" => Ok(GeneratedField::I32),
                            "i64" => Ok(GeneratedField::I64),
                            "fp32" => Ok(GeneratedField::Fp32),
                            "fp64" => Ok(GeneratedField::Fp64),
                            "string" => Ok(GeneratedField::String),
                            "binary" => Ok(GeneratedField::Binary),
                            "timestamp" => Ok(GeneratedField::Timestamp),
                            "date" => Ok(GeneratedField::Date),
                            "time" => Ok(GeneratedField::Time),
                            "intervalYearToMonth" | "interval_year_to_month" => Ok(GeneratedField::IntervalYearToMonth),
                            "intervalDayToSecond" | "interval_day_to_second" => Ok(GeneratedField::IntervalDayToSecond),
                            "intervalCompound" | "interval_compound" => Ok(GeneratedField::IntervalCompound),
                            "fixedChar" | "fixed_char" => Ok(GeneratedField::FixedChar),
                            "varChar" | "var_char" => Ok(GeneratedField::VarChar),
                            "fixedBinary" | "fixed_binary" => Ok(GeneratedField::FixedBinary),
                            "decimal" => Ok(GeneratedField::Decimal),
                            "precisionTime" | "precision_time" => Ok(GeneratedField::PrecisionTime),
                            "precisionTimestamp" | "precision_timestamp" => Ok(GeneratedField::PrecisionTimestamp),
                            "precisionTimestampTz" | "precision_timestamp_tz" => Ok(GeneratedField::PrecisionTimestampTz),
                            "struct" => Ok(GeneratedField::Struct),
                            "map" => Ok(GeneratedField::Map),
                            "timestampTz" | "timestamp_tz" => Ok(GeneratedField::TimestampTz),
                            "uuid" => Ok(GeneratedField::Uuid),
                            "null" => Ok(GeneratedField::Null),
                            "list" => Ok(GeneratedField::List),
                            "emptyList" | "empty_list" => Ok(GeneratedField::EmptyList),
                            "emptyMap" | "empty_map" => Ok(GeneratedField::EmptyMap),
                            "userDefined" | "user_defined" => Ok(GeneratedField::UserDefined),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::Literal;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.Literal")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::Literal, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut nullable__ = None;
                let mut type_variation_reference__ = None;
                let mut literal_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Nullable => {
                            if nullable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullable"));
                            }
                            nullable__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TypeVariationReference => {
                            if type_variation_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeVariationReference"));
                            }
                            type_variation_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Boolean => {
                            if literal_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("boolean"));
                            }
                            literal_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::literal::LiteralType::Boolean);
                        }
                        GeneratedField::I8 => {
                            if literal_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("i8"));
                            }
                            literal_type__ = map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| expression::literal::LiteralType::I8(x.0));
                        }
                        GeneratedField::I16 => {
                            if literal_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("i16"));
                            }
                            literal_type__ = map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| expression::literal::LiteralType::I16(x.0));
                        }
                        GeneratedField::I32 => {
                            if literal_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("i32"));
                            }
                            literal_type__ = map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| expression::literal::LiteralType::I32(x.0));
                        }
                        GeneratedField::I64 => {
                            if literal_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("i64"));
                            }
                            literal_type__ = map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| expression::literal::LiteralType::I64(x.0));
                        }
                        GeneratedField::Fp32 => {
                            if literal_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fp32"));
                            }
                            literal_type__ = map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| expression::literal::LiteralType::Fp32(x.0));
                        }
                        GeneratedField::Fp64 => {
                            if literal_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fp64"));
                            }
                            literal_type__ = map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| expression::literal::LiteralType::Fp64(x.0));
                        }
                        GeneratedField::String => {
                            if literal_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("string"));
                            }
                            literal_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::literal::LiteralType::String);
                        }
                        GeneratedField::Binary => {
                            if literal_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("binary"));
                            }
                            literal_type__ = map_.next_value::<::std::option::Option<::pbjson::private::BytesDeserialize<_>>>()?.map(|x| expression::literal::LiteralType::Binary(x.0));
                        }
                        GeneratedField::Timestamp => {
                            if literal_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestamp"));
                            }
                            literal_type__ = map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| expression::literal::LiteralType::Timestamp(x.0));
                        }
                        GeneratedField::Date => {
                            if literal_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("date"));
                            }
                            literal_type__ = map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| expression::literal::LiteralType::Date(x.0));
                        }
                        GeneratedField::Time => {
                            if literal_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("time"));
                            }
                            literal_type__ = map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| expression::literal::LiteralType::Time(x.0));
                        }
                        GeneratedField::IntervalYearToMonth => {
                            if literal_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("intervalYearToMonth"));
                            }
                            literal_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::literal::LiteralType::IntervalYearToMonth)
;
                        }
                        GeneratedField::IntervalDayToSecond => {
                            if literal_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("intervalDayToSecond"));
                            }
                            literal_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::literal::LiteralType::IntervalDayToSecond)
;
                        }
                        GeneratedField::IntervalCompound => {
                            if literal_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("intervalCompound"));
                            }
                            literal_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::literal::LiteralType::IntervalCompound)
;
                        }
                        GeneratedField::FixedChar => {
                            if literal_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fixedChar"));
                            }
                            literal_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::literal::LiteralType::FixedChar);
                        }
                        GeneratedField::VarChar => {
                            if literal_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("varChar"));
                            }
                            literal_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::literal::LiteralType::VarChar)
;
                        }
                        GeneratedField::FixedBinary => {
                            if literal_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fixedBinary"));
                            }
                            literal_type__ = map_.next_value::<::std::option::Option<::pbjson::private::BytesDeserialize<_>>>()?.map(|x| expression::literal::LiteralType::FixedBinary(x.0));
                        }
                        GeneratedField::Decimal => {
                            if literal_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("decimal"));
                            }
                            literal_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::literal::LiteralType::Decimal)
;
                        }
                        GeneratedField::PrecisionTime => {
                            if literal_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precisionTime"));
                            }
                            literal_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::literal::LiteralType::PrecisionTime)
;
                        }
                        GeneratedField::PrecisionTimestamp => {
                            if literal_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precisionTimestamp"));
                            }
                            literal_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::literal::LiteralType::PrecisionTimestamp)
;
                        }
                        GeneratedField::PrecisionTimestampTz => {
                            if literal_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precisionTimestampTz"));
                            }
                            literal_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::literal::LiteralType::PrecisionTimestampTz)
;
                        }
                        GeneratedField::Struct => {
                            if literal_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("struct"));
                            }
                            literal_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::literal::LiteralType::Struct)
;
                        }
                        GeneratedField::Map => {
                            if literal_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("map"));
                            }
                            literal_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::literal::LiteralType::Map)
;
                        }
                        GeneratedField::TimestampTz => {
                            if literal_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestampTz"));
                            }
                            literal_type__ = map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| expression::literal::LiteralType::TimestampTz(x.0));
                        }
                        GeneratedField::Uuid => {
                            if literal_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("uuid"));
                            }
                            literal_type__ = map_.next_value::<::std::option::Option<::pbjson::private::BytesDeserialize<_>>>()?.map(|x| expression::literal::LiteralType::Uuid(x.0));
                        }
                        GeneratedField::Null => {
                            if literal_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("null"));
                            }
                            literal_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::literal::LiteralType::Null)
;
                        }
                        GeneratedField::List => {
                            if literal_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            literal_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::literal::LiteralType::List)
;
                        }
                        GeneratedField::EmptyList => {
                            if literal_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("emptyList"));
                            }
                            literal_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::literal::LiteralType::EmptyList)
;
                        }
                        GeneratedField::EmptyMap => {
                            if literal_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("emptyMap"));
                            }
                            literal_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::literal::LiteralType::EmptyMap)
;
                        }
                        GeneratedField::UserDefined => {
                            if literal_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("userDefined"));
                            }
                            literal_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::literal::LiteralType::UserDefined)
;
                        }
                    }
                }
                Ok(expression::Literal {
                    nullable: nullable__.unwrap_or_default(),
                    type_variation_reference: type_variation_reference__.unwrap_or_default(),
                    literal_type: literal_type__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.Literal", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::literal::Decimal {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.value.is_empty() {
            len += 1;
        }
        if self.precision != 0 {
            len += 1;
        }
        if self.scale != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.Literal.Decimal", len)?;
        if !self.value.is_empty() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("value", pbjson::private::base64::encode(&self.value).as_str())?;
        }
        if self.precision != 0 {
            struct_ser.serialize_field("precision", &self.precision)?;
        }
        if self.scale != 0 {
            struct_ser.serialize_field("scale", &self.scale)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::literal::Decimal {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "value",
            "precision",
            "scale",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Value,
            Precision,
            Scale,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "value" => Ok(GeneratedField::Value),
                            "precision" => Ok(GeneratedField::Precision),
                            "scale" => Ok(GeneratedField::Scale),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::literal::Decimal;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.Literal.Decimal")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::literal::Decimal, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut value__ = None;
                let mut precision__ = None;
                let mut scale__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ =
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Precision => {
                            if precision__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precision"));
                            }
                            precision__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Scale => {
                            if scale__.is_some() {
                                return Err(serde::de::Error::duplicate_field("scale"));
                            }
                            scale__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(expression::literal::Decimal {
                    value: value__.unwrap_or_default(),
                    precision: precision__.unwrap_or_default(),
                    scale: scale__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.Literal.Decimal", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::literal::IntervalCompound {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.interval_year_to_month.is_some() {
            len += 1;
        }
        if self.interval_day_to_second.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.Literal.IntervalCompound", len)?;
        if let Some(v) = self.interval_year_to_month.as_ref() {
            struct_ser.serialize_field("intervalYearToMonth", v)?;
        }
        if let Some(v) = self.interval_day_to_second.as_ref() {
            struct_ser.serialize_field("intervalDayToSecond", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::literal::IntervalCompound {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "interval_year_to_month",
            "intervalYearToMonth",
            "interval_day_to_second",
            "intervalDayToSecond",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            IntervalYearToMonth,
            IntervalDayToSecond,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "intervalYearToMonth" | "interval_year_to_month" => Ok(GeneratedField::IntervalYearToMonth),
                            "intervalDayToSecond" | "interval_day_to_second" => Ok(GeneratedField::IntervalDayToSecond),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::literal::IntervalCompound;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.Literal.IntervalCompound")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::literal::IntervalCompound, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut interval_year_to_month__ = None;
                let mut interval_day_to_second__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::IntervalYearToMonth => {
                            if interval_year_to_month__.is_some() {
                                return Err(serde::de::Error::duplicate_field("intervalYearToMonth"));
                            }
                            interval_year_to_month__ = map_.next_value()?;
                        }
                        GeneratedField::IntervalDayToSecond => {
                            if interval_day_to_second__.is_some() {
                                return Err(serde::de::Error::duplicate_field("intervalDayToSecond"));
                            }
                            interval_day_to_second__ = map_.next_value()?;
                        }
                    }
                }
                Ok(expression::literal::IntervalCompound {
                    interval_year_to_month: interval_year_to_month__,
                    interval_day_to_second: interval_day_to_second__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.Literal.IntervalCompound", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::literal::IntervalDayToSecond {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.days != 0 {
            len += 1;
        }
        if self.seconds != 0 {
            len += 1;
        }
        if self.subseconds != 0 {
            len += 1;
        }
        if self.precision_mode.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.Literal.IntervalDayToSecond", len)?;
        if self.days != 0 {
            struct_ser.serialize_field("days", &self.days)?;
        }
        if self.seconds != 0 {
            struct_ser.serialize_field("seconds", &self.seconds)?;
        }
        if self.subseconds != 0 {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("subseconds", ToString::to_string(&self.subseconds).as_str())?;
        }
        if let Some(v) = self.precision_mode.as_ref() {
            match v {
                expression::literal::interval_day_to_second::PrecisionMode::Microseconds(v) => {
                    struct_ser.serialize_field("microseconds", v)?;
                }
                expression::literal::interval_day_to_second::PrecisionMode::Precision(v) => {
                    struct_ser.serialize_field("precision", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::literal::IntervalDayToSecond {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "days",
            "seconds",
            "subseconds",
            "microseconds",
            "precision",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Days,
            Seconds,
            Subseconds,
            Microseconds,
            Precision,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "days" => Ok(GeneratedField::Days),
                            "seconds" => Ok(GeneratedField::Seconds),
                            "subseconds" => Ok(GeneratedField::Subseconds),
                            "microseconds" => Ok(GeneratedField::Microseconds),
                            "precision" => Ok(GeneratedField::Precision),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::literal::IntervalDayToSecond;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.Literal.IntervalDayToSecond")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::literal::IntervalDayToSecond, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut days__ = None;
                let mut seconds__ = None;
                let mut subseconds__ = None;
                let mut precision_mode__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Days => {
                            if days__.is_some() {
                                return Err(serde::de::Error::duplicate_field("days"));
                            }
                            days__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Seconds => {
                            if seconds__.is_some() {
                                return Err(serde::de::Error::duplicate_field("seconds"));
                            }
                            seconds__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Subseconds => {
                            if subseconds__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subseconds"));
                            }
                            subseconds__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Microseconds => {
                            if precision_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("microseconds"));
                            }
                            precision_mode__ = map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| expression::literal::interval_day_to_second::PrecisionMode::Microseconds(x.0));
                        }
                        GeneratedField::Precision => {
                            if precision_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precision"));
                            }
                            precision_mode__ = map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| expression::literal::interval_day_to_second::PrecisionMode::Precision(x.0));
                        }
                    }
                }
                Ok(expression::literal::IntervalDayToSecond {
                    days: days__.unwrap_or_default(),
                    seconds: seconds__.unwrap_or_default(),
                    subseconds: subseconds__.unwrap_or_default(),
                    precision_mode: precision_mode__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.Literal.IntervalDayToSecond", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::literal::IntervalYearToMonth {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.years != 0 {
            len += 1;
        }
        if self.months != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.Literal.IntervalYearToMonth", len)?;
        if self.years != 0 {
            struct_ser.serialize_field("years", &self.years)?;
        }
        if self.months != 0 {
            struct_ser.serialize_field("months", &self.months)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::literal::IntervalYearToMonth {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "years",
            "months",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Years,
            Months,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "years" => Ok(GeneratedField::Years),
                            "months" => Ok(GeneratedField::Months),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::literal::IntervalYearToMonth;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.Literal.IntervalYearToMonth")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::literal::IntervalYearToMonth, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut years__ = None;
                let mut months__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Years => {
                            if years__.is_some() {
                                return Err(serde::de::Error::duplicate_field("years"));
                            }
                            years__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Months => {
                            if months__.is_some() {
                                return Err(serde::de::Error::duplicate_field("months"));
                            }
                            months__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(expression::literal::IntervalYearToMonth {
                    years: years__.unwrap_or_default(),
                    months: months__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.Literal.IntervalYearToMonth", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::literal::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.values.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.Literal.List", len)?;
        if !self.values.is_empty() {
            struct_ser.serialize_field("values", &self.values)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::literal::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "values",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Values,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "values" => Ok(GeneratedField::Values),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::literal::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.Literal.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::literal::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut values__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Values => {
                            if values__.is_some() {
                                return Err(serde::de::Error::duplicate_field("values"));
                            }
                            values__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(expression::literal::List {
                    values: values__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.Literal.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::literal::Map {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.key_values.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.Literal.Map", len)?;
        if !self.key_values.is_empty() {
            struct_ser.serialize_field("keyValues", &self.key_values)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::literal::Map {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "key_values",
            "keyValues",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            KeyValues,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "keyValues" | "key_values" => Ok(GeneratedField::KeyValues),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::literal::Map;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.Literal.Map")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::literal::Map, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut key_values__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::KeyValues => {
                            if key_values__.is_some() {
                                return Err(serde::de::Error::duplicate_field("keyValues"));
                            }
                            key_values__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(expression::literal::Map {
                    key_values: key_values__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.Literal.Map", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::literal::map::KeyValue {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.key.is_some() {
            len += 1;
        }
        if self.value.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.Literal.Map.KeyValue", len)?;
        if let Some(v) = self.key.as_ref() {
            struct_ser.serialize_field("key", v)?;
        }
        if let Some(v) = self.value.as_ref() {
            struct_ser.serialize_field("value", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::literal::map::KeyValue {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "key",
            "value",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Key,
            Value,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "key" => Ok(GeneratedField::Key),
                            "value" => Ok(GeneratedField::Value),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::literal::map::KeyValue;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.Literal.Map.KeyValue")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::literal::map::KeyValue, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut key__ = None;
                let mut value__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Key => {
                            if key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("key"));
                            }
                            key__ = map_.next_value()?;
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ = map_.next_value()?;
                        }
                    }
                }
                Ok(expression::literal::map::KeyValue {
                    key: key__,
                    value: value__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.Literal.Map.KeyValue", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::literal::PrecisionTime {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.precision != 0 {
            len += 1;
        }
        if self.value != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.Literal.PrecisionTime", len)?;
        if self.precision != 0 {
            struct_ser.serialize_field("precision", &self.precision)?;
        }
        if self.value != 0 {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("value", ToString::to_string(&self.value).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::literal::PrecisionTime {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "precision",
            "value",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Precision,
            Value,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "precision" => Ok(GeneratedField::Precision),
                            "value" => Ok(GeneratedField::Value),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::literal::PrecisionTime;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.Literal.PrecisionTime")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::literal::PrecisionTime, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut precision__ = None;
                let mut value__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Precision => {
                            if precision__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precision"));
                            }
                            precision__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(expression::literal::PrecisionTime {
                    precision: precision__.unwrap_or_default(),
                    value: value__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.Literal.PrecisionTime", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::literal::PrecisionTimestamp {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.precision != 0 {
            len += 1;
        }
        if self.value != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.Literal.PrecisionTimestamp", len)?;
        if self.precision != 0 {
            struct_ser.serialize_field("precision", &self.precision)?;
        }
        if self.value != 0 {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("value", ToString::to_string(&self.value).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::literal::PrecisionTimestamp {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "precision",
            "value",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Precision,
            Value,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "precision" => Ok(GeneratedField::Precision),
                            "value" => Ok(GeneratedField::Value),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::literal::PrecisionTimestamp;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.Literal.PrecisionTimestamp")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::literal::PrecisionTimestamp, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut precision__ = None;
                let mut value__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Precision => {
                            if precision__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precision"));
                            }
                            precision__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(expression::literal::PrecisionTimestamp {
                    precision: precision__.unwrap_or_default(),
                    value: value__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.Literal.PrecisionTimestamp", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::literal::Struct {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.fields.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.Literal.Struct", len)?;
        if !self.fields.is_empty() {
            struct_ser.serialize_field("fields", &self.fields)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::literal::Struct {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "fields",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Fields,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "fields" => Ok(GeneratedField::Fields),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::literal::Struct;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.Literal.Struct")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::literal::Struct, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut fields__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Fields => {
                            if fields__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fields"));
                            }
                            fields__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(expression::literal::Struct {
                    fields: fields__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.Literal.Struct", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::literal::UserDefined {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.type_reference != 0 {
            len += 1;
        }
        if !self.type_parameters.is_empty() {
            len += 1;
        }
        if self.val.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.Literal.UserDefined", len)?;
        if self.type_reference != 0 {
            struct_ser.serialize_field("typeReference", &self.type_reference)?;
        }
        if !self.type_parameters.is_empty() {
            struct_ser.serialize_field("typeParameters", &self.type_parameters)?;
        }
        if let Some(v) = self.val.as_ref() {
            match v {
                expression::literal::user_defined::Val::Value(v) => {
                    struct_ser.serialize_field("value", v)?;
                }
                expression::literal::user_defined::Val::Struct(v) => {
                    struct_ser.serialize_field("struct", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::literal::UserDefined {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type_reference",
            "typeReference",
            "type_parameters",
            "typeParameters",
            "value",
            "struct",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TypeReference,
            TypeParameters,
            Value,
            Struct,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "typeReference" | "type_reference" => Ok(GeneratedField::TypeReference),
                            "typeParameters" | "type_parameters" => Ok(GeneratedField::TypeParameters),
                            "value" => Ok(GeneratedField::Value),
                            "struct" => Ok(GeneratedField::Struct),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::literal::UserDefined;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.Literal.UserDefined")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::literal::UserDefined, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut type_reference__ = None;
                let mut type_parameters__ = None;
                let mut val__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TypeReference => {
                            if type_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeReference"));
                            }
                            type_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::TypeParameters => {
                            if type_parameters__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeParameters"));
                            }
                            type_parameters__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Value => {
                            if val__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            val__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::literal::user_defined::Val::Value)
;
                        }
                        GeneratedField::Struct => {
                            if val__.is_some() {
                                return Err(serde::de::Error::duplicate_field("struct"));
                            }
                            val__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::literal::user_defined::Val::Struct)
;
                        }
                    }
                }
                Ok(expression::literal::UserDefined {
                    type_reference: type_reference__.unwrap_or_default(),
                    type_parameters: type_parameters__.unwrap_or_default(),
                    val: val__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.Literal.UserDefined", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::literal::VarChar {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.value.is_empty() {
            len += 1;
        }
        if self.length != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.Literal.VarChar", len)?;
        if !self.value.is_empty() {
            struct_ser.serialize_field("value", &self.value)?;
        }
        if self.length != 0 {
            struct_ser.serialize_field("length", &self.length)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::literal::VarChar {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "value",
            "length",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Value,
            Length,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "value" => Ok(GeneratedField::Value),
                            "length" => Ok(GeneratedField::Length),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::literal::VarChar;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.Literal.VarChar")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::literal::VarChar, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut value__ = None;
                let mut length__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Length => {
                            if length__.is_some() {
                                return Err(serde::de::Error::duplicate_field("length"));
                            }
                            length__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(expression::literal::VarChar {
                    value: value__.unwrap_or_default(),
                    length: length__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.Literal.VarChar", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::MaskExpression {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.select.is_some() {
            len += 1;
        }
        if self.maintain_singular_struct {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.MaskExpression", len)?;
        if let Some(v) = self.select.as_ref() {
            struct_ser.serialize_field("select", v)?;
        }
        if self.maintain_singular_struct {
            struct_ser.serialize_field("maintainSingularStruct", &self.maintain_singular_struct)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::MaskExpression {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "select",
            "maintain_singular_struct",
            "maintainSingularStruct",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Select,
            MaintainSingularStruct,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "select" => Ok(GeneratedField::Select),
                            "maintainSingularStruct" | "maintain_singular_struct" => Ok(GeneratedField::MaintainSingularStruct),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::MaskExpression;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.MaskExpression")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::MaskExpression, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut select__ = None;
                let mut maintain_singular_struct__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Select => {
                            if select__.is_some() {
                                return Err(serde::de::Error::duplicate_field("select"));
                            }
                            select__ = map_.next_value()?;
                        }
                        GeneratedField::MaintainSingularStruct => {
                            if maintain_singular_struct__.is_some() {
                                return Err(serde::de::Error::duplicate_field("maintainSingularStruct"));
                            }
                            maintain_singular_struct__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(expression::MaskExpression {
                    select: select__,
                    maintain_singular_struct: maintain_singular_struct__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.MaskExpression", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::mask_expression::ListSelect {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.selection.is_empty() {
            len += 1;
        }
        if self.child.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.MaskExpression.ListSelect", len)?;
        if !self.selection.is_empty() {
            struct_ser.serialize_field("selection", &self.selection)?;
        }
        if let Some(v) = self.child.as_ref() {
            struct_ser.serialize_field("child", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::mask_expression::ListSelect {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "selection",
            "child",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Selection,
            Child,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "selection" => Ok(GeneratedField::Selection),
                            "child" => Ok(GeneratedField::Child),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::mask_expression::ListSelect;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.MaskExpression.ListSelect")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::mask_expression::ListSelect, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut selection__ = None;
                let mut child__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Selection => {
                            if selection__.is_some() {
                                return Err(serde::de::Error::duplicate_field("selection"));
                            }
                            selection__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Child => {
                            if child__.is_some() {
                                return Err(serde::de::Error::duplicate_field("child"));
                            }
                            child__ = map_.next_value()?;
                        }
                    }
                }
                Ok(expression::mask_expression::ListSelect {
                    selection: selection__.unwrap_or_default(),
                    child: child__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.MaskExpression.ListSelect", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::mask_expression::list_select::ListSelectItem {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.r#type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.MaskExpression.ListSelect.ListSelectItem", len)?;
        if let Some(v) = self.r#type.as_ref() {
            match v {
                expression::mask_expression::list_select::list_select_item::Type::Item(v) => {
                    struct_ser.serialize_field("item", v)?;
                }
                expression::mask_expression::list_select::list_select_item::Type::Slice(v) => {
                    struct_ser.serialize_field("slice", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::mask_expression::list_select::ListSelectItem {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "item",
            "slice",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Item,
            Slice,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "item" => Ok(GeneratedField::Item),
                            "slice" => Ok(GeneratedField::Slice),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::mask_expression::list_select::ListSelectItem;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.MaskExpression.ListSelect.ListSelectItem")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::mask_expression::list_select::ListSelectItem, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Item => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("item"));
                            }
                            r#type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::mask_expression::list_select::list_select_item::Type::Item)
;
                        }
                        GeneratedField::Slice => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("slice"));
                            }
                            r#type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::mask_expression::list_select::list_select_item::Type::Slice)
;
                        }
                    }
                }
                Ok(expression::mask_expression::list_select::ListSelectItem {
                    r#type: r#type__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.MaskExpression.ListSelect.ListSelectItem", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::mask_expression::list_select::list_select_item::ListElement {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.field != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement", len)?;
        if self.field != 0 {
            struct_ser.serialize_field("field", &self.field)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::mask_expression::list_select::list_select_item::ListElement {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "field",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Field,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "field" => Ok(GeneratedField::Field),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::mask_expression::list_select::list_select_item::ListElement;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::mask_expression::list_select::list_select_item::ListElement, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut field__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Field => {
                            if field__.is_some() {
                                return Err(serde::de::Error::duplicate_field("field"));
                            }
                            field__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(expression::mask_expression::list_select::list_select_item::ListElement {
                    field: field__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::mask_expression::list_select::list_select_item::ListSlice {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.start != 0 {
            len += 1;
        }
        if self.end != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice", len)?;
        if self.start != 0 {
            struct_ser.serialize_field("start", &self.start)?;
        }
        if self.end != 0 {
            struct_ser.serialize_field("end", &self.end)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::mask_expression::list_select::list_select_item::ListSlice {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "start",
            "end",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Start,
            End,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "start" => Ok(GeneratedField::Start),
                            "end" => Ok(GeneratedField::End),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::mask_expression::list_select::list_select_item::ListSlice;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::mask_expression::list_select::list_select_item::ListSlice, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut start__ = None;
                let mut end__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Start => {
                            if start__.is_some() {
                                return Err(serde::de::Error::duplicate_field("start"));
                            }
                            start__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::End => {
                            if end__.is_some() {
                                return Err(serde::de::Error::duplicate_field("end"));
                            }
                            end__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(expression::mask_expression::list_select::list_select_item::ListSlice {
                    start: start__.unwrap_or_default(),
                    end: end__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::mask_expression::MapSelect {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.child.is_some() {
            len += 1;
        }
        if self.select.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.MaskExpression.MapSelect", len)?;
        if let Some(v) = self.child.as_ref() {
            struct_ser.serialize_field("child", v)?;
        }
        if let Some(v) = self.select.as_ref() {
            match v {
                expression::mask_expression::map_select::Select::Key(v) => {
                    struct_ser.serialize_field("key", v)?;
                }
                expression::mask_expression::map_select::Select::Expression(v) => {
                    struct_ser.serialize_field("expression", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::mask_expression::MapSelect {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "child",
            "key",
            "expression",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Child,
            Key,
            Expression,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "child" => Ok(GeneratedField::Child),
                            "key" => Ok(GeneratedField::Key),
                            "expression" => Ok(GeneratedField::Expression),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::mask_expression::MapSelect;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.MaskExpression.MapSelect")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::mask_expression::MapSelect, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut child__ = None;
                let mut select__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Child => {
                            if child__.is_some() {
                                return Err(serde::de::Error::duplicate_field("child"));
                            }
                            child__ = map_.next_value()?;
                        }
                        GeneratedField::Key => {
                            if select__.is_some() {
                                return Err(serde::de::Error::duplicate_field("key"));
                            }
                            select__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::mask_expression::map_select::Select::Key)
;
                        }
                        GeneratedField::Expression => {
                            if select__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expression"));
                            }
                            select__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::mask_expression::map_select::Select::Expression)
;
                        }
                    }
                }
                Ok(expression::mask_expression::MapSelect {
                    child: child__,
                    select: select__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.MaskExpression.MapSelect", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::mask_expression::map_select::MapKey {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.map_key.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.MaskExpression.MapSelect.MapKey", len)?;
        if !self.map_key.is_empty() {
            struct_ser.serialize_field("mapKey", &self.map_key)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::mask_expression::map_select::MapKey {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "map_key",
            "mapKey",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MapKey,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "mapKey" | "map_key" => Ok(GeneratedField::MapKey),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::mask_expression::map_select::MapKey;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.MaskExpression.MapSelect.MapKey")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::mask_expression::map_select::MapKey, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut map_key__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MapKey => {
                            if map_key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mapKey"));
                            }
                            map_key__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(expression::mask_expression::map_select::MapKey {
                    map_key: map_key__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.MaskExpression.MapSelect.MapKey", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::mask_expression::map_select::MapKeyExpression {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.map_key_expression.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.MaskExpression.MapSelect.MapKeyExpression", len)?;
        if !self.map_key_expression.is_empty() {
            struct_ser.serialize_field("mapKeyExpression", &self.map_key_expression)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::mask_expression::map_select::MapKeyExpression {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "map_key_expression",
            "mapKeyExpression",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MapKeyExpression,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "mapKeyExpression" | "map_key_expression" => Ok(GeneratedField::MapKeyExpression),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::mask_expression::map_select::MapKeyExpression;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.MaskExpression.MapSelect.MapKeyExpression")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::mask_expression::map_select::MapKeyExpression, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut map_key_expression__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MapKeyExpression => {
                            if map_key_expression__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mapKeyExpression"));
                            }
                            map_key_expression__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(expression::mask_expression::map_select::MapKeyExpression {
                    map_key_expression: map_key_expression__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.MaskExpression.MapSelect.MapKeyExpression", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::mask_expression::Select {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.r#type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.MaskExpression.Select", len)?;
        if let Some(v) = self.r#type.as_ref() {
            match v {
                expression::mask_expression::select::Type::Struct(v) => {
                    struct_ser.serialize_field("struct", v)?;
                }
                expression::mask_expression::select::Type::List(v) => {
                    struct_ser.serialize_field("list", v)?;
                }
                expression::mask_expression::select::Type::Map(v) => {
                    struct_ser.serialize_field("map", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::mask_expression::Select {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "struct",
            "list",
            "map",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Struct,
            List,
            Map,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "struct" => Ok(GeneratedField::Struct),
                            "list" => Ok(GeneratedField::List),
                            "map" => Ok(GeneratedField::Map),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::mask_expression::Select;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.MaskExpression.Select")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::mask_expression::Select, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Struct => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("struct"));
                            }
                            r#type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::mask_expression::select::Type::Struct)
;
                        }
                        GeneratedField::List => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            r#type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::mask_expression::select::Type::List)
;
                        }
                        GeneratedField::Map => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("map"));
                            }
                            r#type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::mask_expression::select::Type::Map)
;
                        }
                    }
                }
                Ok(expression::mask_expression::Select {
                    r#type: r#type__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.MaskExpression.Select", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::mask_expression::StructItem {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.field != 0 {
            len += 1;
        }
        if self.child.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.MaskExpression.StructItem", len)?;
        if self.field != 0 {
            struct_ser.serialize_field("field", &self.field)?;
        }
        if let Some(v) = self.child.as_ref() {
            struct_ser.serialize_field("child", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::mask_expression::StructItem {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "field",
            "child",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Field,
            Child,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "field" => Ok(GeneratedField::Field),
                            "child" => Ok(GeneratedField::Child),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::mask_expression::StructItem;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.MaskExpression.StructItem")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::mask_expression::StructItem, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut field__ = None;
                let mut child__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Field => {
                            if field__.is_some() {
                                return Err(serde::de::Error::duplicate_field("field"));
                            }
                            field__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Child => {
                            if child__.is_some() {
                                return Err(serde::de::Error::duplicate_field("child"));
                            }
                            child__ = map_.next_value()?;
                        }
                    }
                }
                Ok(expression::mask_expression::StructItem {
                    field: field__.unwrap_or_default(),
                    child: child__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.MaskExpression.StructItem", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::mask_expression::StructSelect {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.struct_items.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.MaskExpression.StructSelect", len)?;
        if !self.struct_items.is_empty() {
            struct_ser.serialize_field("structItems", &self.struct_items)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::mask_expression::StructSelect {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "struct_items",
            "structItems",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            StructItems,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "structItems" | "struct_items" => Ok(GeneratedField::StructItems),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::mask_expression::StructSelect;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.MaskExpression.StructSelect")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::mask_expression::StructSelect, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut struct_items__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::StructItems => {
                            if struct_items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("structItems"));
                            }
                            struct_items__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(expression::mask_expression::StructSelect {
                    struct_items: struct_items__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.MaskExpression.StructSelect", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::MultiOrList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.value.is_empty() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.MultiOrList", len)?;
        if !self.value.is_empty() {
            struct_ser.serialize_field("value", &self.value)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::MultiOrList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "value",
            "options",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Value,
            Options,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "value" => Ok(GeneratedField::Value),
                            "options" => Ok(GeneratedField::Options),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::MultiOrList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.MultiOrList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::MultiOrList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut value__ = None;
                let mut options__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(expression::MultiOrList {
                    value: value__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.MultiOrList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::multi_or_list::Record {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.fields.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.MultiOrList.Record", len)?;
        if !self.fields.is_empty() {
            struct_ser.serialize_field("fields", &self.fields)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::multi_or_list::Record {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "fields",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Fields,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "fields" => Ok(GeneratedField::Fields),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::multi_or_list::Record;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.MultiOrList.Record")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::multi_or_list::Record, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut fields__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Fields => {
                            if fields__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fields"));
                            }
                            fields__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(expression::multi_or_list::Record {
                    fields: fields__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.MultiOrList.Record", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::Nested {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.nullable {
            len += 1;
        }
        if self.type_variation_reference != 0 {
            len += 1;
        }
        if self.nested_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.Nested", len)?;
        if self.nullable {
            struct_ser.serialize_field("nullable", &self.nullable)?;
        }
        if self.type_variation_reference != 0 {
            struct_ser.serialize_field("typeVariationReference", &self.type_variation_reference)?;
        }
        if let Some(v) = self.nested_type.as_ref() {
            match v {
                expression::nested::NestedType::Struct(v) => {
                    struct_ser.serialize_field("struct", v)?;
                }
                expression::nested::NestedType::List(v) => {
                    struct_ser.serialize_field("list", v)?;
                }
                expression::nested::NestedType::Map(v) => {
                    struct_ser.serialize_field("map", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::Nested {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "nullable",
            "type_variation_reference",
            "typeVariationReference",
            "struct",
            "list",
            "map",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Nullable,
            TypeVariationReference,
            Struct,
            List,
            Map,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "nullable" => Ok(GeneratedField::Nullable),
                            "typeVariationReference" | "type_variation_reference" => Ok(GeneratedField::TypeVariationReference),
                            "struct" => Ok(GeneratedField::Struct),
                            "list" => Ok(GeneratedField::List),
                            "map" => Ok(GeneratedField::Map),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::Nested;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.Nested")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::Nested, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut nullable__ = None;
                let mut type_variation_reference__ = None;
                let mut nested_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Nullable => {
                            if nullable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullable"));
                            }
                            nullable__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TypeVariationReference => {
                            if type_variation_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeVariationReference"));
                            }
                            type_variation_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Struct => {
                            if nested_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("struct"));
                            }
                            nested_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::nested::NestedType::Struct)
;
                        }
                        GeneratedField::List => {
                            if nested_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            nested_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::nested::NestedType::List)
;
                        }
                        GeneratedField::Map => {
                            if nested_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("map"));
                            }
                            nested_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::nested::NestedType::Map)
;
                        }
                    }
                }
                Ok(expression::Nested {
                    nullable: nullable__.unwrap_or_default(),
                    type_variation_reference: type_variation_reference__.unwrap_or_default(),
                    nested_type: nested_type__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.Nested", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::nested::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.values.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.Nested.List", len)?;
        if !self.values.is_empty() {
            struct_ser.serialize_field("values", &self.values)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::nested::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "values",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Values,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "values" => Ok(GeneratedField::Values),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::nested::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.Nested.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::nested::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut values__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Values => {
                            if values__.is_some() {
                                return Err(serde::de::Error::duplicate_field("values"));
                            }
                            values__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(expression::nested::List {
                    values: values__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.Nested.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::nested::Map {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.key_values.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.Nested.Map", len)?;
        if !self.key_values.is_empty() {
            struct_ser.serialize_field("keyValues", &self.key_values)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::nested::Map {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "key_values",
            "keyValues",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            KeyValues,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "keyValues" | "key_values" => Ok(GeneratedField::KeyValues),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::nested::Map;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.Nested.Map")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::nested::Map, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut key_values__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::KeyValues => {
                            if key_values__.is_some() {
                                return Err(serde::de::Error::duplicate_field("keyValues"));
                            }
                            key_values__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(expression::nested::Map {
                    key_values: key_values__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.Nested.Map", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::nested::map::KeyValue {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.key.is_some() {
            len += 1;
        }
        if self.value.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.Nested.Map.KeyValue", len)?;
        if let Some(v) = self.key.as_ref() {
            struct_ser.serialize_field("key", v)?;
        }
        if let Some(v) = self.value.as_ref() {
            struct_ser.serialize_field("value", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::nested::map::KeyValue {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "key",
            "value",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Key,
            Value,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "key" => Ok(GeneratedField::Key),
                            "value" => Ok(GeneratedField::Value),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::nested::map::KeyValue;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.Nested.Map.KeyValue")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::nested::map::KeyValue, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut key__ = None;
                let mut value__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Key => {
                            if key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("key"));
                            }
                            key__ = map_.next_value()?;
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ = map_.next_value()?;
                        }
                    }
                }
                Ok(expression::nested::map::KeyValue {
                    key: key__,
                    value: value__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.Nested.Map.KeyValue", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::nested::Struct {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.fields.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.Nested.Struct", len)?;
        if !self.fields.is_empty() {
            struct_ser.serialize_field("fields", &self.fields)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::nested::Struct {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "fields",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Fields,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "fields" => Ok(GeneratedField::Fields),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::nested::Struct;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.Nested.Struct")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::nested::Struct, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut fields__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Fields => {
                            if fields__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fields"));
                            }
                            fields__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(expression::nested::Struct {
                    fields: fields__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.Nested.Struct", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::ReferenceSegment {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.reference_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.ReferenceSegment", len)?;
        if let Some(v) = self.reference_type.as_ref() {
            match v {
                expression::reference_segment::ReferenceType::MapKey(v) => {
                    struct_ser.serialize_field("mapKey", v)?;
                }
                expression::reference_segment::ReferenceType::StructField(v) => {
                    struct_ser.serialize_field("structField", v)?;
                }
                expression::reference_segment::ReferenceType::ListElement(v) => {
                    struct_ser.serialize_field("listElement", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::ReferenceSegment {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "map_key",
            "mapKey",
            "struct_field",
            "structField",
            "list_element",
            "listElement",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MapKey,
            StructField,
            ListElement,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "mapKey" | "map_key" => Ok(GeneratedField::MapKey),
                            "structField" | "struct_field" => Ok(GeneratedField::StructField),
                            "listElement" | "list_element" => Ok(GeneratedField::ListElement),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::ReferenceSegment;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.ReferenceSegment")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::ReferenceSegment, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut reference_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MapKey => {
                            if reference_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mapKey"));
                            }
                            reference_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::reference_segment::ReferenceType::MapKey)
;
                        }
                        GeneratedField::StructField => {
                            if reference_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("structField"));
                            }
                            reference_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::reference_segment::ReferenceType::StructField)
;
                        }
                        GeneratedField::ListElement => {
                            if reference_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("listElement"));
                            }
                            reference_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::reference_segment::ReferenceType::ListElement)
;
                        }
                    }
                }
                Ok(expression::ReferenceSegment {
                    reference_type: reference_type__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.ReferenceSegment", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::reference_segment::ListElement {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.offset != 0 {
            len += 1;
        }
        if self.child.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.ReferenceSegment.ListElement", len)?;
        if self.offset != 0 {
            struct_ser.serialize_field("offset", &self.offset)?;
        }
        if let Some(v) = self.child.as_ref() {
            struct_ser.serialize_field("child", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::reference_segment::ListElement {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "offset",
            "child",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Offset,
            Child,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "offset" => Ok(GeneratedField::Offset),
                            "child" => Ok(GeneratedField::Child),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::reference_segment::ListElement;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.ReferenceSegment.ListElement")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::reference_segment::ListElement, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut offset__ = None;
                let mut child__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Offset => {
                            if offset__.is_some() {
                                return Err(serde::de::Error::duplicate_field("offset"));
                            }
                            offset__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Child => {
                            if child__.is_some() {
                                return Err(serde::de::Error::duplicate_field("child"));
                            }
                            child__ = map_.next_value()?;
                        }
                    }
                }
                Ok(expression::reference_segment::ListElement {
                    offset: offset__.unwrap_or_default(),
                    child: child__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.ReferenceSegment.ListElement", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::reference_segment::MapKey {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.map_key.is_some() {
            len += 1;
        }
        if self.child.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.ReferenceSegment.MapKey", len)?;
        if let Some(v) = self.map_key.as_ref() {
            struct_ser.serialize_field("mapKey", v)?;
        }
        if let Some(v) = self.child.as_ref() {
            struct_ser.serialize_field("child", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::reference_segment::MapKey {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "map_key",
            "mapKey",
            "child",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MapKey,
            Child,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "mapKey" | "map_key" => Ok(GeneratedField::MapKey),
                            "child" => Ok(GeneratedField::Child),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::reference_segment::MapKey;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.ReferenceSegment.MapKey")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::reference_segment::MapKey, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut map_key__ = None;
                let mut child__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MapKey => {
                            if map_key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mapKey"));
                            }
                            map_key__ = map_.next_value()?;
                        }
                        GeneratedField::Child => {
                            if child__.is_some() {
                                return Err(serde::de::Error::duplicate_field("child"));
                            }
                            child__ = map_.next_value()?;
                        }
                    }
                }
                Ok(expression::reference_segment::MapKey {
                    map_key: map_key__,
                    child: child__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.ReferenceSegment.MapKey", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::reference_segment::StructField {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.field != 0 {
            len += 1;
        }
        if self.child.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.ReferenceSegment.StructField", len)?;
        if self.field != 0 {
            struct_ser.serialize_field("field", &self.field)?;
        }
        if let Some(v) = self.child.as_ref() {
            struct_ser.serialize_field("child", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::reference_segment::StructField {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "field",
            "child",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Field,
            Child,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "field" => Ok(GeneratedField::Field),
                            "child" => Ok(GeneratedField::Child),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::reference_segment::StructField;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.ReferenceSegment.StructField")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::reference_segment::StructField, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut field__ = None;
                let mut child__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Field => {
                            if field__.is_some() {
                                return Err(serde::de::Error::duplicate_field("field"));
                            }
                            field__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Child => {
                            if child__.is_some() {
                                return Err(serde::de::Error::duplicate_field("child"));
                            }
                            child__ = map_.next_value()?;
                        }
                    }
                }
                Ok(expression::reference_segment::StructField {
                    field: field__.unwrap_or_default(),
                    child: child__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.ReferenceSegment.StructField", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::ScalarFunction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.function_reference != 0 {
            len += 1;
        }
        if !self.arguments.is_empty() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        if self.output_type.is_some() {
            len += 1;
        }
        if !self.args.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.ScalarFunction", len)?;
        if self.function_reference != 0 {
            struct_ser.serialize_field("functionReference", &self.function_reference)?;
        }
        if !self.arguments.is_empty() {
            struct_ser.serialize_field("arguments", &self.arguments)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        if let Some(v) = self.output_type.as_ref() {
            struct_ser.serialize_field("outputType", v)?;
        }
        if !self.args.is_empty() {
            struct_ser.serialize_field("args", &self.args)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::ScalarFunction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "function_reference",
            "functionReference",
            "arguments",
            "options",
            "output_type",
            "outputType",
            "args",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            FunctionReference,
            Arguments,
            Options,
            OutputType,
            Args,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "functionReference" | "function_reference" => Ok(GeneratedField::FunctionReference),
                            "arguments" => Ok(GeneratedField::Arguments),
                            "options" => Ok(GeneratedField::Options),
                            "outputType" | "output_type" => Ok(GeneratedField::OutputType),
                            "args" => Ok(GeneratedField::Args),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::ScalarFunction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.ScalarFunction")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::ScalarFunction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut function_reference__ = None;
                let mut arguments__ = None;
                let mut options__ = None;
                let mut output_type__ = None;
                let mut args__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::FunctionReference => {
                            if function_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("functionReference"));
                            }
                            function_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Arguments => {
                            if arguments__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arguments"));
                            }
                            arguments__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OutputType => {
                            if output_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("outputType"));
                            }
                            output_type__ = map_.next_value()?;
                        }
                        GeneratedField::Args => {
                            if args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("args"));
                            }
                            args__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(expression::ScalarFunction {
                    function_reference: function_reference__.unwrap_or_default(),
                    arguments: arguments__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                    output_type: output_type__,
                    args: args__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.ScalarFunction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::SingularOrList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.value.is_some() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.SingularOrList", len)?;
        if let Some(v) = self.value.as_ref() {
            struct_ser.serialize_field("value", v)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::SingularOrList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "value",
            "options",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Value,
            Options,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "value" => Ok(GeneratedField::Value),
                            "options" => Ok(GeneratedField::Options),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::SingularOrList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.SingularOrList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::SingularOrList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut value__ = None;
                let mut options__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ = map_.next_value()?;
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(expression::SingularOrList {
                    value: value__,
                    options: options__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.SingularOrList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::Subquery {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.subquery_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.Subquery", len)?;
        if let Some(v) = self.subquery_type.as_ref() {
            match v {
                expression::subquery::SubqueryType::Scalar(v) => {
                    struct_ser.serialize_field("scalar", v)?;
                }
                expression::subquery::SubqueryType::InPredicate(v) => {
                    struct_ser.serialize_field("inPredicate", v)?;
                }
                expression::subquery::SubqueryType::SetPredicate(v) => {
                    struct_ser.serialize_field("setPredicate", v)?;
                }
                expression::subquery::SubqueryType::SetComparison(v) => {
                    struct_ser.serialize_field("setComparison", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::Subquery {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "scalar",
            "in_predicate",
            "inPredicate",
            "set_predicate",
            "setPredicate",
            "set_comparison",
            "setComparison",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Scalar,
            InPredicate,
            SetPredicate,
            SetComparison,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "scalar" => Ok(GeneratedField::Scalar),
                            "inPredicate" | "in_predicate" => Ok(GeneratedField::InPredicate),
                            "setPredicate" | "set_predicate" => Ok(GeneratedField::SetPredicate),
                            "setComparison" | "set_comparison" => Ok(GeneratedField::SetComparison),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::Subquery;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.Subquery")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::Subquery, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut subquery_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Scalar => {
                            if subquery_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("scalar"));
                            }
                            subquery_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::subquery::SubqueryType::Scalar)
;
                        }
                        GeneratedField::InPredicate => {
                            if subquery_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inPredicate"));
                            }
                            subquery_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::subquery::SubqueryType::InPredicate)
;
                        }
                        GeneratedField::SetPredicate => {
                            if subquery_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("setPredicate"));
                            }
                            subquery_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::subquery::SubqueryType::SetPredicate)
;
                        }
                        GeneratedField::SetComparison => {
                            if subquery_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("setComparison"));
                            }
                            subquery_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::subquery::SubqueryType::SetComparison)
;
                        }
                    }
                }
                Ok(expression::Subquery {
                    subquery_type: subquery_type__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.Subquery", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::subquery::InPredicate {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.needles.is_empty() {
            len += 1;
        }
        if self.haystack.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.Subquery.InPredicate", len)?;
        if !self.needles.is_empty() {
            struct_ser.serialize_field("needles", &self.needles)?;
        }
        if let Some(v) = self.haystack.as_ref() {
            struct_ser.serialize_field("haystack", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::subquery::InPredicate {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "needles",
            "haystack",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Needles,
            Haystack,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "needles" => Ok(GeneratedField::Needles),
                            "haystack" => Ok(GeneratedField::Haystack),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::subquery::InPredicate;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.Subquery.InPredicate")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::subquery::InPredicate, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut needles__ = None;
                let mut haystack__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Needles => {
                            if needles__.is_some() {
                                return Err(serde::de::Error::duplicate_field("needles"));
                            }
                            needles__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Haystack => {
                            if haystack__.is_some() {
                                return Err(serde::de::Error::duplicate_field("haystack"));
                            }
                            haystack__ = map_.next_value()?;
                        }
                    }
                }
                Ok(expression::subquery::InPredicate {
                    needles: needles__.unwrap_or_default(),
                    haystack: haystack__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.Subquery.InPredicate", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::subquery::Scalar {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.input.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.Subquery.Scalar", len)?;
        if let Some(v) = self.input.as_ref() {
            struct_ser.serialize_field("input", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::subquery::Scalar {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "input",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Input,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "input" => Ok(GeneratedField::Input),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::subquery::Scalar;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.Subquery.Scalar")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::subquery::Scalar, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut input__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Input => {
                            if input__.is_some() {
                                return Err(serde::de::Error::duplicate_field("input"));
                            }
                            input__ = map_.next_value()?;
                        }
                    }
                }
                Ok(expression::subquery::Scalar {
                    input: input__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.Subquery.Scalar", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::subquery::SetComparison {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.reduction_op != 0 {
            len += 1;
        }
        if self.comparison_op != 0 {
            len += 1;
        }
        if self.left.is_some() {
            len += 1;
        }
        if self.right.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.Subquery.SetComparison", len)?;
        if self.reduction_op != 0 {
            let v = expression::subquery::set_comparison::ReductionOp::try_from(self.reduction_op)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.reduction_op)))?;
            struct_ser.serialize_field("reductionOp", &v)?;
        }
        if self.comparison_op != 0 {
            let v = expression::subquery::set_comparison::ComparisonOp::try_from(self.comparison_op)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.comparison_op)))?;
            struct_ser.serialize_field("comparisonOp", &v)?;
        }
        if let Some(v) = self.left.as_ref() {
            struct_ser.serialize_field("left", v)?;
        }
        if let Some(v) = self.right.as_ref() {
            struct_ser.serialize_field("right", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::subquery::SetComparison {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "reduction_op",
            "reductionOp",
            "comparison_op",
            "comparisonOp",
            "left",
            "right",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ReductionOp,
            ComparisonOp,
            Left,
            Right,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "reductionOp" | "reduction_op" => Ok(GeneratedField::ReductionOp),
                            "comparisonOp" | "comparison_op" => Ok(GeneratedField::ComparisonOp),
                            "left" => Ok(GeneratedField::Left),
                            "right" => Ok(GeneratedField::Right),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::subquery::SetComparison;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.Subquery.SetComparison")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::subquery::SetComparison, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut reduction_op__ = None;
                let mut comparison_op__ = None;
                let mut left__ = None;
                let mut right__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ReductionOp => {
                            if reduction_op__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reductionOp"));
                            }
                            reduction_op__ = Some(map_.next_value::<expression::subquery::set_comparison::ReductionOp>()? as i32);
                        }
                        GeneratedField::ComparisonOp => {
                            if comparison_op__.is_some() {
                                return Err(serde::de::Error::duplicate_field("comparisonOp"));
                            }
                            comparison_op__ = Some(map_.next_value::<expression::subquery::set_comparison::ComparisonOp>()? as i32);
                        }
                        GeneratedField::Left => {
                            if left__.is_some() {
                                return Err(serde::de::Error::duplicate_field("left"));
                            }
                            left__ = map_.next_value()?;
                        }
                        GeneratedField::Right => {
                            if right__.is_some() {
                                return Err(serde::de::Error::duplicate_field("right"));
                            }
                            right__ = map_.next_value()?;
                        }
                    }
                }
                Ok(expression::subquery::SetComparison {
                    reduction_op: reduction_op__.unwrap_or_default(),
                    comparison_op: comparison_op__.unwrap_or_default(),
                    left: left__,
                    right: right__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.Subquery.SetComparison", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::subquery::set_comparison::ComparisonOp {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unspecified => "COMPARISON_OP_UNSPECIFIED",
            Self::Eq => "COMPARISON_OP_EQ",
            Self::Ne => "COMPARISON_OP_NE",
            Self::Lt => "COMPARISON_OP_LT",
            Self::Gt => "COMPARISON_OP_GT",
            Self::Le => "COMPARISON_OP_LE",
            Self::Ge => "COMPARISON_OP_GE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for expression::subquery::set_comparison::ComparisonOp {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "COMPARISON_OP_UNSPECIFIED",
            "COMPARISON_OP_EQ",
            "COMPARISON_OP_NE",
            "COMPARISON_OP_LT",
            "COMPARISON_OP_GT",
            "COMPARISON_OP_LE",
            "COMPARISON_OP_GE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::subquery::set_comparison::ComparisonOp;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "COMPARISON_OP_UNSPECIFIED" => Ok(expression::subquery::set_comparison::ComparisonOp::Unspecified),
                    "COMPARISON_OP_EQ" => Ok(expression::subquery::set_comparison::ComparisonOp::Eq),
                    "COMPARISON_OP_NE" => Ok(expression::subquery::set_comparison::ComparisonOp::Ne),
                    "COMPARISON_OP_LT" => Ok(expression::subquery::set_comparison::ComparisonOp::Lt),
                    "COMPARISON_OP_GT" => Ok(expression::subquery::set_comparison::ComparisonOp::Gt),
                    "COMPARISON_OP_LE" => Ok(expression::subquery::set_comparison::ComparisonOp::Le),
                    "COMPARISON_OP_GE" => Ok(expression::subquery::set_comparison::ComparisonOp::Ge),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for expression::subquery::set_comparison::ReductionOp {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unspecified => "REDUCTION_OP_UNSPECIFIED",
            Self::Any => "REDUCTION_OP_ANY",
            Self::All => "REDUCTION_OP_ALL",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for expression::subquery::set_comparison::ReductionOp {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "REDUCTION_OP_UNSPECIFIED",
            "REDUCTION_OP_ANY",
            "REDUCTION_OP_ALL",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::subquery::set_comparison::ReductionOp;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "REDUCTION_OP_UNSPECIFIED" => Ok(expression::subquery::set_comparison::ReductionOp::Unspecified),
                    "REDUCTION_OP_ANY" => Ok(expression::subquery::set_comparison::ReductionOp::Any),
                    "REDUCTION_OP_ALL" => Ok(expression::subquery::set_comparison::ReductionOp::All),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for expression::subquery::SetPredicate {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.predicate_op != 0 {
            len += 1;
        }
        if self.tuples.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.Subquery.SetPredicate", len)?;
        if self.predicate_op != 0 {
            let v = expression::subquery::set_predicate::PredicateOp::try_from(self.predicate_op)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.predicate_op)))?;
            struct_ser.serialize_field("predicateOp", &v)?;
        }
        if let Some(v) = self.tuples.as_ref() {
            struct_ser.serialize_field("tuples", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::subquery::SetPredicate {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "predicate_op",
            "predicateOp",
            "tuples",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PredicateOp,
            Tuples,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "predicateOp" | "predicate_op" => Ok(GeneratedField::PredicateOp),
                            "tuples" => Ok(GeneratedField::Tuples),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::subquery::SetPredicate;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.Subquery.SetPredicate")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::subquery::SetPredicate, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut predicate_op__ = None;
                let mut tuples__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PredicateOp => {
                            if predicate_op__.is_some() {
                                return Err(serde::de::Error::duplicate_field("predicateOp"));
                            }
                            predicate_op__ = Some(map_.next_value::<expression::subquery::set_predicate::PredicateOp>()? as i32);
                        }
                        GeneratedField::Tuples => {
                            if tuples__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tuples"));
                            }
                            tuples__ = map_.next_value()?;
                        }
                    }
                }
                Ok(expression::subquery::SetPredicate {
                    predicate_op: predicate_op__.unwrap_or_default(),
                    tuples: tuples__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.Subquery.SetPredicate", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::subquery::set_predicate::PredicateOp {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unspecified => "PREDICATE_OP_UNSPECIFIED",
            Self::Exists => "PREDICATE_OP_EXISTS",
            Self::Unique => "PREDICATE_OP_UNIQUE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for expression::subquery::set_predicate::PredicateOp {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PREDICATE_OP_UNSPECIFIED",
            "PREDICATE_OP_EXISTS",
            "PREDICATE_OP_UNIQUE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::subquery::set_predicate::PredicateOp;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "PREDICATE_OP_UNSPECIFIED" => Ok(expression::subquery::set_predicate::PredicateOp::Unspecified),
                    "PREDICATE_OP_EXISTS" => Ok(expression::subquery::set_predicate::PredicateOp::Exists),
                    "PREDICATE_OP_UNIQUE" => Ok(expression::subquery::set_predicate::PredicateOp::Unique),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for expression::SwitchExpression {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.r#match.is_some() {
            len += 1;
        }
        if !self.ifs.is_empty() {
            len += 1;
        }
        if self.r#else.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.SwitchExpression", len)?;
        if let Some(v) = self.r#match.as_ref() {
            struct_ser.serialize_field("match", v)?;
        }
        if !self.ifs.is_empty() {
            struct_ser.serialize_field("ifs", &self.ifs)?;
        }
        if let Some(v) = self.r#else.as_ref() {
            struct_ser.serialize_field("else", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::SwitchExpression {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "match",
            "ifs",
            "else",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Match,
            Ifs,
            Else,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "match" => Ok(GeneratedField::Match),
                            "ifs" => Ok(GeneratedField::Ifs),
                            "else" => Ok(GeneratedField::Else),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::SwitchExpression;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.SwitchExpression")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::SwitchExpression, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#match__ = None;
                let mut ifs__ = None;
                let mut r#else__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Match => {
                            if r#match__.is_some() {
                                return Err(serde::de::Error::duplicate_field("match"));
                            }
                            r#match__ = map_.next_value()?;
                        }
                        GeneratedField::Ifs => {
                            if ifs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ifs"));
                            }
                            ifs__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Else => {
                            if r#else__.is_some() {
                                return Err(serde::de::Error::duplicate_field("else"));
                            }
                            r#else__ = map_.next_value()?;
                        }
                    }
                }
                Ok(expression::SwitchExpression {
                    r#match: r#match__,
                    ifs: ifs__.unwrap_or_default(),
                    r#else: r#else__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.SwitchExpression", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::switch_expression::IfValue {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.r#if.is_some() {
            len += 1;
        }
        if self.then.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.SwitchExpression.IfValue", len)?;
        if let Some(v) = self.r#if.as_ref() {
            struct_ser.serialize_field("if", v)?;
        }
        if let Some(v) = self.then.as_ref() {
            struct_ser.serialize_field("then", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::switch_expression::IfValue {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "if",
            "then",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            If,
            Then,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "if" => Ok(GeneratedField::If),
                            "then" => Ok(GeneratedField::Then),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::switch_expression::IfValue;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.SwitchExpression.IfValue")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::switch_expression::IfValue, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#if__ = None;
                let mut then__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::If => {
                            if r#if__.is_some() {
                                return Err(serde::de::Error::duplicate_field("if"));
                            }
                            r#if__ = map_.next_value()?;
                        }
                        GeneratedField::Then => {
                            if then__.is_some() {
                                return Err(serde::de::Error::duplicate_field("then"));
                            }
                            then__ = map_.next_value()?;
                        }
                    }
                }
                Ok(expression::switch_expression::IfValue {
                    r#if: r#if__,
                    then: then__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.SwitchExpression.IfValue", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::WindowFunction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.function_reference != 0 {
            len += 1;
        }
        if !self.arguments.is_empty() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        if self.output_type.is_some() {
            len += 1;
        }
        if self.phase != 0 {
            len += 1;
        }
        if !self.sorts.is_empty() {
            len += 1;
        }
        if self.invocation != 0 {
            len += 1;
        }
        if !self.partitions.is_empty() {
            len += 1;
        }
        if self.bounds_type != 0 {
            len += 1;
        }
        if self.lower_bound.is_some() {
            len += 1;
        }
        if self.upper_bound.is_some() {
            len += 1;
        }
        if !self.args.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.WindowFunction", len)?;
        if self.function_reference != 0 {
            struct_ser.serialize_field("functionReference", &self.function_reference)?;
        }
        if !self.arguments.is_empty() {
            struct_ser.serialize_field("arguments", &self.arguments)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        if let Some(v) = self.output_type.as_ref() {
            struct_ser.serialize_field("outputType", v)?;
        }
        if self.phase != 0 {
            let v = AggregationPhase::try_from(self.phase)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.phase)))?;
            struct_ser.serialize_field("phase", &v)?;
        }
        if !self.sorts.is_empty() {
            struct_ser.serialize_field("sorts", &self.sorts)?;
        }
        if self.invocation != 0 {
            let v = aggregate_function::AggregationInvocation::try_from(self.invocation)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.invocation)))?;
            struct_ser.serialize_field("invocation", &v)?;
        }
        if !self.partitions.is_empty() {
            struct_ser.serialize_field("partitions", &self.partitions)?;
        }
        if self.bounds_type != 0 {
            let v = expression::window_function::BoundsType::try_from(self.bounds_type)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.bounds_type)))?;
            struct_ser.serialize_field("boundsType", &v)?;
        }
        if let Some(v) = self.lower_bound.as_ref() {
            struct_ser.serialize_field("lowerBound", v)?;
        }
        if let Some(v) = self.upper_bound.as_ref() {
            struct_ser.serialize_field("upperBound", v)?;
        }
        if !self.args.is_empty() {
            struct_ser.serialize_field("args", &self.args)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::WindowFunction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "function_reference",
            "functionReference",
            "arguments",
            "options",
            "output_type",
            "outputType",
            "phase",
            "sorts",
            "invocation",
            "partitions",
            "bounds_type",
            "boundsType",
            "lower_bound",
            "lowerBound",
            "upper_bound",
            "upperBound",
            "args",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            FunctionReference,
            Arguments,
            Options,
            OutputType,
            Phase,
            Sorts,
            Invocation,
            Partitions,
            BoundsType,
            LowerBound,
            UpperBound,
            Args,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "functionReference" | "function_reference" => Ok(GeneratedField::FunctionReference),
                            "arguments" => Ok(GeneratedField::Arguments),
                            "options" => Ok(GeneratedField::Options),
                            "outputType" | "output_type" => Ok(GeneratedField::OutputType),
                            "phase" => Ok(GeneratedField::Phase),
                            "sorts" => Ok(GeneratedField::Sorts),
                            "invocation" => Ok(GeneratedField::Invocation),
                            "partitions" => Ok(GeneratedField::Partitions),
                            "boundsType" | "bounds_type" => Ok(GeneratedField::BoundsType),
                            "lowerBound" | "lower_bound" => Ok(GeneratedField::LowerBound),
                            "upperBound" | "upper_bound" => Ok(GeneratedField::UpperBound),
                            "args" => Ok(GeneratedField::Args),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::WindowFunction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.WindowFunction")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::WindowFunction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut function_reference__ = None;
                let mut arguments__ = None;
                let mut options__ = None;
                let mut output_type__ = None;
                let mut phase__ = None;
                let mut sorts__ = None;
                let mut invocation__ = None;
                let mut partitions__ = None;
                let mut bounds_type__ = None;
                let mut lower_bound__ = None;
                let mut upper_bound__ = None;
                let mut args__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::FunctionReference => {
                            if function_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("functionReference"));
                            }
                            function_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Arguments => {
                            if arguments__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arguments"));
                            }
                            arguments__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OutputType => {
                            if output_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("outputType"));
                            }
                            output_type__ = map_.next_value()?;
                        }
                        GeneratedField::Phase => {
                            if phase__.is_some() {
                                return Err(serde::de::Error::duplicate_field("phase"));
                            }
                            phase__ = Some(map_.next_value::<AggregationPhase>()? as i32);
                        }
                        GeneratedField::Sorts => {
                            if sorts__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sorts"));
                            }
                            sorts__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Invocation => {
                            if invocation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("invocation"));
                            }
                            invocation__ = Some(map_.next_value::<aggregate_function::AggregationInvocation>()? as i32);
                        }
                        GeneratedField::Partitions => {
                            if partitions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("partitions"));
                            }
                            partitions__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BoundsType => {
                            if bounds_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("boundsType"));
                            }
                            bounds_type__ = Some(map_.next_value::<expression::window_function::BoundsType>()? as i32);
                        }
                        GeneratedField::LowerBound => {
                            if lower_bound__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lowerBound"));
                            }
                            lower_bound__ = map_.next_value()?;
                        }
                        GeneratedField::UpperBound => {
                            if upper_bound__.is_some() {
                                return Err(serde::de::Error::duplicate_field("upperBound"));
                            }
                            upper_bound__ = map_.next_value()?;
                        }
                        GeneratedField::Args => {
                            if args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("args"));
                            }
                            args__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(expression::WindowFunction {
                    function_reference: function_reference__.unwrap_or_default(),
                    arguments: arguments__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                    output_type: output_type__,
                    phase: phase__.unwrap_or_default(),
                    sorts: sorts__.unwrap_or_default(),
                    invocation: invocation__.unwrap_or_default(),
                    partitions: partitions__.unwrap_or_default(),
                    bounds_type: bounds_type__.unwrap_or_default(),
                    lower_bound: lower_bound__,
                    upper_bound: upper_bound__,
                    args: args__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.WindowFunction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::window_function::Bound {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.kind.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.WindowFunction.Bound", len)?;
        if let Some(v) = self.kind.as_ref() {
            match v {
                expression::window_function::bound::Kind::Preceding(v) => {
                    struct_ser.serialize_field("preceding", v)?;
                }
                expression::window_function::bound::Kind::Following(v) => {
                    struct_ser.serialize_field("following", v)?;
                }
                expression::window_function::bound::Kind::CurrentRow(v) => {
                    struct_ser.serialize_field("currentRow", v)?;
                }
                expression::window_function::bound::Kind::Unbounded(v) => {
                    struct_ser.serialize_field("unbounded", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::window_function::Bound {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "preceding",
            "following",
            "current_row",
            "currentRow",
            "unbounded",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Preceding,
            Following,
            CurrentRow,
            Unbounded,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "preceding" => Ok(GeneratedField::Preceding),
                            "following" => Ok(GeneratedField::Following),
                            "currentRow" | "current_row" => Ok(GeneratedField::CurrentRow),
                            "unbounded" => Ok(GeneratedField::Unbounded),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::window_function::Bound;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.WindowFunction.Bound")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::window_function::Bound, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut kind__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Preceding => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("preceding"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::window_function::bound::Kind::Preceding)
;
                        }
                        GeneratedField::Following => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("following"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::window_function::bound::Kind::Following)
;
                        }
                        GeneratedField::CurrentRow => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("currentRow"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::window_function::bound::Kind::CurrentRow)
;
                        }
                        GeneratedField::Unbounded => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("unbounded"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(expression::window_function::bound::Kind::Unbounded)
;
                        }
                    }
                }
                Ok(expression::window_function::Bound {
                    kind: kind__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.WindowFunction.Bound", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::window_function::bound::CurrentRow {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("substrait.Expression.WindowFunction.Bound.CurrentRow", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::window_function::bound::CurrentRow {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::window_function::bound::CurrentRow;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.WindowFunction.Bound.CurrentRow")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::window_function::bound::CurrentRow, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(expression::window_function::bound::CurrentRow {
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.WindowFunction.Bound.CurrentRow", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::window_function::bound::Following {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.offset != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.WindowFunction.Bound.Following", len)?;
        if self.offset != 0 {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("offset", ToString::to_string(&self.offset).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::window_function::bound::Following {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "offset",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Offset,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "offset" => Ok(GeneratedField::Offset),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::window_function::bound::Following;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.WindowFunction.Bound.Following")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::window_function::bound::Following, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut offset__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Offset => {
                            if offset__.is_some() {
                                return Err(serde::de::Error::duplicate_field("offset"));
                            }
                            offset__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(expression::window_function::bound::Following {
                    offset: offset__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.WindowFunction.Bound.Following", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::window_function::bound::Preceding {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.offset != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Expression.WindowFunction.Bound.Preceding", len)?;
        if self.offset != 0 {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("offset", ToString::to_string(&self.offset).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::window_function::bound::Preceding {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "offset",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Offset,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "offset" => Ok(GeneratedField::Offset),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::window_function::bound::Preceding;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.WindowFunction.Bound.Preceding")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::window_function::bound::Preceding, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut offset__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Offset => {
                            if offset__.is_some() {
                                return Err(serde::de::Error::duplicate_field("offset"));
                            }
                            offset__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(expression::window_function::bound::Preceding {
                    offset: offset__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.WindowFunction.Bound.Preceding", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::window_function::bound::Unbounded {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("substrait.Expression.WindowFunction.Bound.Unbounded", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for expression::window_function::bound::Unbounded {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::window_function::bound::Unbounded;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Expression.WindowFunction.Bound.Unbounded")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<expression::window_function::bound::Unbounded, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(expression::window_function::bound::Unbounded {
                })
            }
        }
        deserializer.deserialize_struct("substrait.Expression.WindowFunction.Bound.Unbounded", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for expression::window_function::BoundsType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unspecified => "BOUNDS_TYPE_UNSPECIFIED",
            Self::Rows => "BOUNDS_TYPE_ROWS",
            Self::Range => "BOUNDS_TYPE_RANGE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for expression::window_function::BoundsType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BOUNDS_TYPE_UNSPECIFIED",
            "BOUNDS_TYPE_ROWS",
            "BOUNDS_TYPE_RANGE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = expression::window_function::BoundsType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "BOUNDS_TYPE_UNSPECIFIED" => Ok(expression::window_function::BoundsType::Unspecified),
                    "BOUNDS_TYPE_ROWS" => Ok(expression::window_function::BoundsType::Rows),
                    "BOUNDS_TYPE_RANGE" => Ok(expression::window_function::BoundsType::Range),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ExpressionReference {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.output_names.is_empty() {
            len += 1;
        }
        if self.expr_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ExpressionReference", len)?;
        if !self.output_names.is_empty() {
            struct_ser.serialize_field("outputNames", &self.output_names)?;
        }
        if let Some(v) = self.expr_type.as_ref() {
            match v {
                expression_reference::ExprType::Expression(v) => {
                    struct_ser.serialize_field("expression", v)?;
                }
                expression_reference::ExprType::Measure(v) => {
                    struct_ser.serialize_field("measure", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ExpressionReference {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "output_names",
            "outputNames",
            "expression",
            "measure",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            OutputNames,
            Expression,
            Measure,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "outputNames" | "output_names" => Ok(GeneratedField::OutputNames),
                            "expression" => Ok(GeneratedField::Expression),
                            "measure" => Ok(GeneratedField::Measure),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ExpressionReference;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ExpressionReference")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ExpressionReference, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut output_names__ = None;
                let mut expr_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::OutputNames => {
                            if output_names__.is_some() {
                                return Err(serde::de::Error::duplicate_field("outputNames"));
                            }
                            output_names__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Expression => {
                            if expr_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expression"));
                            }
                            expr_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression_reference::ExprType::Expression)
;
                        }
                        GeneratedField::Measure => {
                            if expr_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("measure"));
                            }
                            expr_type__ = map_.next_value::<::std::option::Option<_>>()?.map(expression_reference::ExprType::Measure)
;
                        }
                    }
                }
                Ok(ExpressionReference {
                    output_names: output_names__.unwrap_or_default(),
                    expr_type: expr_type__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.ExpressionReference", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ExtendedExpression {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.version.is_some() {
            len += 1;
        }
        if !self.extension_uris.is_empty() {
            len += 1;
        }
        if !self.extension_urns.is_empty() {
            len += 1;
        }
        if !self.extensions.is_empty() {
            len += 1;
        }
        if !self.referred_expr.is_empty() {
            len += 1;
        }
        if self.base_schema.is_some() {
            len += 1;
        }
        if self.advanced_extensions.is_some() {
            len += 1;
        }
        if !self.expected_type_urls.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ExtendedExpression", len)?;
        if let Some(v) = self.version.as_ref() {
            struct_ser.serialize_field("version", v)?;
        }
        if !self.extension_uris.is_empty() {
            struct_ser.serialize_field("extensionUris", &self.extension_uris)?;
        }
        if !self.extension_urns.is_empty() {
            struct_ser.serialize_field("extensionUrns", &self.extension_urns)?;
        }
        if !self.extensions.is_empty() {
            struct_ser.serialize_field("extensions", &self.extensions)?;
        }
        if !self.referred_expr.is_empty() {
            struct_ser.serialize_field("referredExpr", &self.referred_expr)?;
        }
        if let Some(v) = self.base_schema.as_ref() {
            struct_ser.serialize_field("baseSchema", v)?;
        }
        if let Some(v) = self.advanced_extensions.as_ref() {
            struct_ser.serialize_field("advancedExtensions", v)?;
        }
        if !self.expected_type_urls.is_empty() {
            struct_ser.serialize_field("expectedTypeUrls", &self.expected_type_urls)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ExtendedExpression {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "version",
            "extension_uris",
            "extensionUris",
            "extension_urns",
            "extensionUrns",
            "extensions",
            "referred_expr",
            "referredExpr",
            "base_schema",
            "baseSchema",
            "advanced_extensions",
            "advancedExtensions",
            "expected_type_urls",
            "expectedTypeUrls",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Version,
            ExtensionUris,
            ExtensionUrns,
            Extensions,
            ReferredExpr,
            BaseSchema,
            AdvancedExtensions,
            ExpectedTypeUrls,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "version" => Ok(GeneratedField::Version),
                            "extensionUris" | "extension_uris" => Ok(GeneratedField::ExtensionUris),
                            "extensionUrns" | "extension_urns" => Ok(GeneratedField::ExtensionUrns),
                            "extensions" => Ok(GeneratedField::Extensions),
                            "referredExpr" | "referred_expr" => Ok(GeneratedField::ReferredExpr),
                            "baseSchema" | "base_schema" => Ok(GeneratedField::BaseSchema),
                            "advancedExtensions" | "advanced_extensions" => Ok(GeneratedField::AdvancedExtensions),
                            "expectedTypeUrls" | "expected_type_urls" => Ok(GeneratedField::ExpectedTypeUrls),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ExtendedExpression;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ExtendedExpression")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ExtendedExpression, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut version__ = None;
                let mut extension_uris__ = None;
                let mut extension_urns__ = None;
                let mut extensions__ = None;
                let mut referred_expr__ = None;
                let mut base_schema__ = None;
                let mut advanced_extensions__ = None;
                let mut expected_type_urls__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Version => {
                            if version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("version"));
                            }
                            version__ = map_.next_value()?;
                        }
                        GeneratedField::ExtensionUris => {
                            if extension_uris__.is_some() {
                                return Err(serde::de::Error::duplicate_field("extensionUris"));
                            }
                            extension_uris__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ExtensionUrns => {
                            if extension_urns__.is_some() {
                                return Err(serde::de::Error::duplicate_field("extensionUrns"));
                            }
                            extension_urns__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Extensions => {
                            if extensions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("extensions"));
                            }
                            extensions__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ReferredExpr => {
                            if referred_expr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("referredExpr"));
                            }
                            referred_expr__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BaseSchema => {
                            if base_schema__.is_some() {
                                return Err(serde::de::Error::duplicate_field("baseSchema"));
                            }
                            base_schema__ = map_.next_value()?;
                        }
                        GeneratedField::AdvancedExtensions => {
                            if advanced_extensions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("advancedExtensions"));
                            }
                            advanced_extensions__ = map_.next_value()?;
                        }
                        GeneratedField::ExpectedTypeUrls => {
                            if expected_type_urls__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expectedTypeUrls"));
                            }
                            expected_type_urls__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(ExtendedExpression {
                    version: version__,
                    extension_uris: extension_uris__.unwrap_or_default(),
                    extension_urns: extension_urns__.unwrap_or_default(),
                    extensions: extensions__.unwrap_or_default(),
                    referred_expr: referred_expr__.unwrap_or_default(),
                    base_schema: base_schema__,
                    advanced_extensions: advanced_extensions__,
                    expected_type_urls: expected_type_urls__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.ExtendedExpression", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ExtensionLeafRel {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.common.is_some() {
            len += 1;
        }
        if self.detail.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ExtensionLeafRel", len)?;
        if let Some(v) = self.common.as_ref() {
            struct_ser.serialize_field("common", v)?;
        }
        if let Some(v) = self.detail.as_ref() {
            struct_ser.serialize_field("detail", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ExtensionLeafRel {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "common",
            "detail",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Common,
            Detail,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "common" => Ok(GeneratedField::Common),
                            "detail" => Ok(GeneratedField::Detail),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ExtensionLeafRel;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ExtensionLeafRel")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ExtensionLeafRel, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut common__ = None;
                let mut detail__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Common => {
                            if common__.is_some() {
                                return Err(serde::de::Error::duplicate_field("common"));
                            }
                            common__ = map_.next_value()?;
                        }
                        GeneratedField::Detail => {
                            if detail__.is_some() {
                                return Err(serde::de::Error::duplicate_field("detail"));
                            }
                            detail__ = map_.next_value()?;
                        }
                    }
                }
                Ok(ExtensionLeafRel {
                    common: common__,
                    detail: detail__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.ExtensionLeafRel", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ExtensionMultiRel {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.common.is_some() {
            len += 1;
        }
        if !self.inputs.is_empty() {
            len += 1;
        }
        if self.detail.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ExtensionMultiRel", len)?;
        if let Some(v) = self.common.as_ref() {
            struct_ser.serialize_field("common", v)?;
        }
        if !self.inputs.is_empty() {
            struct_ser.serialize_field("inputs", &self.inputs)?;
        }
        if let Some(v) = self.detail.as_ref() {
            struct_ser.serialize_field("detail", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ExtensionMultiRel {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "common",
            "inputs",
            "detail",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Common,
            Inputs,
            Detail,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "common" => Ok(GeneratedField::Common),
                            "inputs" => Ok(GeneratedField::Inputs),
                            "detail" => Ok(GeneratedField::Detail),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ExtensionMultiRel;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ExtensionMultiRel")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ExtensionMultiRel, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut common__ = None;
                let mut inputs__ = None;
                let mut detail__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Common => {
                            if common__.is_some() {
                                return Err(serde::de::Error::duplicate_field("common"));
                            }
                            common__ = map_.next_value()?;
                        }
                        GeneratedField::Inputs => {
                            if inputs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inputs"));
                            }
                            inputs__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Detail => {
                            if detail__.is_some() {
                                return Err(serde::de::Error::duplicate_field("detail"));
                            }
                            detail__ = map_.next_value()?;
                        }
                    }
                }
                Ok(ExtensionMultiRel {
                    common: common__,
                    inputs: inputs__.unwrap_or_default(),
                    detail: detail__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.ExtensionMultiRel", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ExtensionObject {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.detail.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ExtensionObject", len)?;
        if let Some(v) = self.detail.as_ref() {
            struct_ser.serialize_field("detail", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ExtensionObject {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "detail",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Detail,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "detail" => Ok(GeneratedField::Detail),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ExtensionObject;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ExtensionObject")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ExtensionObject, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut detail__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Detail => {
                            if detail__.is_some() {
                                return Err(serde::de::Error::duplicate_field("detail"));
                            }
                            detail__ = map_.next_value()?;
                        }
                    }
                }
                Ok(ExtensionObject {
                    detail: detail__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.ExtensionObject", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ExtensionSingleRel {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.common.is_some() {
            len += 1;
        }
        if self.input.is_some() {
            len += 1;
        }
        if self.detail.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ExtensionSingleRel", len)?;
        if let Some(v) = self.common.as_ref() {
            struct_ser.serialize_field("common", v)?;
        }
        if let Some(v) = self.input.as_ref() {
            struct_ser.serialize_field("input", v)?;
        }
        if let Some(v) = self.detail.as_ref() {
            struct_ser.serialize_field("detail", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ExtensionSingleRel {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "common",
            "input",
            "detail",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Common,
            Input,
            Detail,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "common" => Ok(GeneratedField::Common),
                            "input" => Ok(GeneratedField::Input),
                            "detail" => Ok(GeneratedField::Detail),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ExtensionSingleRel;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ExtensionSingleRel")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ExtensionSingleRel, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut common__ = None;
                let mut input__ = None;
                let mut detail__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Common => {
                            if common__.is_some() {
                                return Err(serde::de::Error::duplicate_field("common"));
                            }
                            common__ = map_.next_value()?;
                        }
                        GeneratedField::Input => {
                            if input__.is_some() {
                                return Err(serde::de::Error::duplicate_field("input"));
                            }
                            input__ = map_.next_value()?;
                        }
                        GeneratedField::Detail => {
                            if detail__.is_some() {
                                return Err(serde::de::Error::duplicate_field("detail"));
                            }
                            detail__ = map_.next_value()?;
                        }
                    }
                }
                Ok(ExtensionSingleRel {
                    common: common__,
                    input: input__,
                    detail: detail__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.ExtensionSingleRel", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FetchRel {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.common.is_some() {
            len += 1;
        }
        if self.input.is_some() {
            len += 1;
        }
        if self.advanced_extension.is_some() {
            len += 1;
        }
        if self.offset_mode.is_some() {
            len += 1;
        }
        if self.count_mode.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.FetchRel", len)?;
        if let Some(v) = self.common.as_ref() {
            struct_ser.serialize_field("common", v)?;
        }
        if let Some(v) = self.input.as_ref() {
            struct_ser.serialize_field("input", v)?;
        }
        if let Some(v) = self.advanced_extension.as_ref() {
            struct_ser.serialize_field("advancedExtension", v)?;
        }
        if let Some(v) = self.offset_mode.as_ref() {
            match v {
                fetch_rel::OffsetMode::Offset(v) => {
                    #[allow(clippy::needless_borrow)]
                    #[allow(clippy::needless_borrows_for_generic_args)]
                    struct_ser.serialize_field("offset", ToString::to_string(&v).as_str())?;
                }
                fetch_rel::OffsetMode::OffsetExpr(v) => {
                    struct_ser.serialize_field("offsetExpr", v)?;
                }
            }
        }
        if let Some(v) = self.count_mode.as_ref() {
            match v {
                fetch_rel::CountMode::Count(v) => {
                    #[allow(clippy::needless_borrow)]
                    #[allow(clippy::needless_borrows_for_generic_args)]
                    struct_ser.serialize_field("count", ToString::to_string(&v).as_str())?;
                }
                fetch_rel::CountMode::CountExpr(v) => {
                    struct_ser.serialize_field("countExpr", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FetchRel {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "common",
            "input",
            "advanced_extension",
            "advancedExtension",
            "offset",
            "offset_expr",
            "offsetExpr",
            "count",
            "count_expr",
            "countExpr",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Common,
            Input,
            AdvancedExtension,
            Offset,
            OffsetExpr,
            Count,
            CountExpr,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "common" => Ok(GeneratedField::Common),
                            "input" => Ok(GeneratedField::Input),
                            "advancedExtension" | "advanced_extension" => Ok(GeneratedField::AdvancedExtension),
                            "offset" => Ok(GeneratedField::Offset),
                            "offsetExpr" | "offset_expr" => Ok(GeneratedField::OffsetExpr),
                            "count" => Ok(GeneratedField::Count),
                            "countExpr" | "count_expr" => Ok(GeneratedField::CountExpr),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FetchRel;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.FetchRel")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FetchRel, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut common__ = None;
                let mut input__ = None;
                let mut advanced_extension__ = None;
                let mut offset_mode__ = None;
                let mut count_mode__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Common => {
                            if common__.is_some() {
                                return Err(serde::de::Error::duplicate_field("common"));
                            }
                            common__ = map_.next_value()?;
                        }
                        GeneratedField::Input => {
                            if input__.is_some() {
                                return Err(serde::de::Error::duplicate_field("input"));
                            }
                            input__ = map_.next_value()?;
                        }
                        GeneratedField::AdvancedExtension => {
                            if advanced_extension__.is_some() {
                                return Err(serde::de::Error::duplicate_field("advancedExtension"));
                            }
                            advanced_extension__ = map_.next_value()?;
                        }
                        GeneratedField::Offset => {
                            if offset_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("offset"));
                            }
                            offset_mode__ = map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| fetch_rel::OffsetMode::Offset(x.0));
                        }
                        GeneratedField::OffsetExpr => {
                            if offset_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("offsetExpr"));
                            }
                            offset_mode__ = map_.next_value::<::std::option::Option<_>>()?.map(fetch_rel::OffsetMode::OffsetExpr)
;
                        }
                        GeneratedField::Count => {
                            if count_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("count"));
                            }
                            count_mode__ = map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| fetch_rel::CountMode::Count(x.0));
                        }
                        GeneratedField::CountExpr => {
                            if count_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("countExpr"));
                            }
                            count_mode__ = map_.next_value::<::std::option::Option<_>>()?.map(fetch_rel::CountMode::CountExpr)
;
                        }
                    }
                }
                Ok(FetchRel {
                    common: common__,
                    input: input__,
                    advanced_extension: advanced_extension__,
                    offset_mode: offset_mode__,
                    count_mode: count_mode__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.FetchRel", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FilterRel {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.common.is_some() {
            len += 1;
        }
        if self.input.is_some() {
            len += 1;
        }
        if self.condition.is_some() {
            len += 1;
        }
        if self.advanced_extension.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.FilterRel", len)?;
        if let Some(v) = self.common.as_ref() {
            struct_ser.serialize_field("common", v)?;
        }
        if let Some(v) = self.input.as_ref() {
            struct_ser.serialize_field("input", v)?;
        }
        if let Some(v) = self.condition.as_ref() {
            struct_ser.serialize_field("condition", v)?;
        }
        if let Some(v) = self.advanced_extension.as_ref() {
            struct_ser.serialize_field("advancedExtension", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FilterRel {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "common",
            "input",
            "condition",
            "advanced_extension",
            "advancedExtension",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Common,
            Input,
            Condition,
            AdvancedExtension,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "common" => Ok(GeneratedField::Common),
                            "input" => Ok(GeneratedField::Input),
                            "condition" => Ok(GeneratedField::Condition),
                            "advancedExtension" | "advanced_extension" => Ok(GeneratedField::AdvancedExtension),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FilterRel;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.FilterRel")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FilterRel, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut common__ = None;
                let mut input__ = None;
                let mut condition__ = None;
                let mut advanced_extension__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Common => {
                            if common__.is_some() {
                                return Err(serde::de::Error::duplicate_field("common"));
                            }
                            common__ = map_.next_value()?;
                        }
                        GeneratedField::Input => {
                            if input__.is_some() {
                                return Err(serde::de::Error::duplicate_field("input"));
                            }
                            input__ = map_.next_value()?;
                        }
                        GeneratedField::Condition => {
                            if condition__.is_some() {
                                return Err(serde::de::Error::duplicate_field("condition"));
                            }
                            condition__ = map_.next_value()?;
                        }
                        GeneratedField::AdvancedExtension => {
                            if advanced_extension__.is_some() {
                                return Err(serde::de::Error::duplicate_field("advancedExtension"));
                            }
                            advanced_extension__ = map_.next_value()?;
                        }
                    }
                }
                Ok(FilterRel {
                    common: common__,
                    input: input__,
                    condition: condition__,
                    advanced_extension: advanced_extension__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.FilterRel", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FunctionArgument {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.arg_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.FunctionArgument", len)?;
        if let Some(v) = self.arg_type.as_ref() {
            match v {
                function_argument::ArgType::Enum(v) => {
                    struct_ser.serialize_field("enum", v)?;
                }
                function_argument::ArgType::Type(v) => {
                    struct_ser.serialize_field("type", v)?;
                }
                function_argument::ArgType::Value(v) => {
                    struct_ser.serialize_field("value", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FunctionArgument {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "enum",
            "type",
            "value",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Enum,
            Type,
            Value,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "enum" => Ok(GeneratedField::Enum),
                            "type" => Ok(GeneratedField::Type),
                            "value" => Ok(GeneratedField::Value),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FunctionArgument;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.FunctionArgument")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FunctionArgument, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut arg_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Enum => {
                            if arg_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("enum"));
                            }
                            arg_type__ = map_.next_value::<::std::option::Option<_>>()?.map(function_argument::ArgType::Enum);
                        }
                        GeneratedField::Type => {
                            if arg_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            arg_type__ = map_.next_value::<::std::option::Option<_>>()?.map(function_argument::ArgType::Type)
;
                        }
                        GeneratedField::Value => {
                            if arg_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            arg_type__ = map_.next_value::<::std::option::Option<_>>()?.map(function_argument::ArgType::Value)
;
                        }
                    }
                }
                Ok(FunctionArgument {
                    arg_type: arg_type__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.FunctionArgument", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FunctionOption {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.name.is_empty() {
            len += 1;
        }
        if !self.preference.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.FunctionOption", len)?;
        if !self.name.is_empty() {
            struct_ser.serialize_field("name", &self.name)?;
        }
        if !self.preference.is_empty() {
            struct_ser.serialize_field("preference", &self.preference)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FunctionOption {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "preference",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Preference,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "preference" => Ok(GeneratedField::Preference),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FunctionOption;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.FunctionOption")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FunctionOption, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut preference__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Preference => {
                            if preference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("preference"));
                            }
                            preference__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(FunctionOption {
                    name: name__.unwrap_or_default(),
                    preference: preference__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.FunctionOption", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FunctionSignature {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("substrait.FunctionSignature", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FunctionSignature {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FunctionSignature;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.FunctionSignature")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FunctionSignature, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(FunctionSignature {
                })
            }
        }
        deserializer.deserialize_struct("substrait.FunctionSignature", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for function_signature::Aggregate {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.arguments.is_empty() {
            len += 1;
        }
        if !self.name.is_empty() {
            len += 1;
        }
        if self.description.is_some() {
            len += 1;
        }
        if self.deterministic {
            len += 1;
        }
        if self.session_dependent {
            len += 1;
        }
        if self.output_type.is_some() {
            len += 1;
        }
        if self.ordered {
            len += 1;
        }
        if self.max_set != 0 {
            len += 1;
        }
        if self.intermediate_type.is_some() {
            len += 1;
        }
        if !self.implementations.is_empty() {
            len += 1;
        }
        if self.final_variable_behavior.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.FunctionSignature.Aggregate", len)?;
        if !self.arguments.is_empty() {
            struct_ser.serialize_field("arguments", &self.arguments)?;
        }
        if !self.name.is_empty() {
            struct_ser.serialize_field("name", &self.name)?;
        }
        if let Some(v) = self.description.as_ref() {
            struct_ser.serialize_field("description", v)?;
        }
        if self.deterministic {
            struct_ser.serialize_field("deterministic", &self.deterministic)?;
        }
        if self.session_dependent {
            struct_ser.serialize_field("sessionDependent", &self.session_dependent)?;
        }
        if let Some(v) = self.output_type.as_ref() {
            struct_ser.serialize_field("outputType", v)?;
        }
        if self.ordered {
            struct_ser.serialize_field("ordered", &self.ordered)?;
        }
        if self.max_set != 0 {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("maxSet", ToString::to_string(&self.max_set).as_str())?;
        }
        if let Some(v) = self.intermediate_type.as_ref() {
            struct_ser.serialize_field("intermediateType", v)?;
        }
        if !self.implementations.is_empty() {
            struct_ser.serialize_field("implementations", &self.implementations)?;
        }
        if let Some(v) = self.final_variable_behavior.as_ref() {
            match v {
                function_signature::aggregate::FinalVariableBehavior::Variadic(v) => {
                    struct_ser.serialize_field("variadic", v)?;
                }
                function_signature::aggregate::FinalVariableBehavior::Normal(v) => {
                    struct_ser.serialize_field("normal", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for function_signature::Aggregate {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "arguments",
            "name",
            "description",
            "deterministic",
            "session_dependent",
            "sessionDependent",
            "output_type",
            "outputType",
            "ordered",
            "max_set",
            "maxSet",
            "intermediate_type",
            "intermediateType",
            "implementations",
            "variadic",
            "normal",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Arguments,
            Name,
            Description,
            Deterministic,
            SessionDependent,
            OutputType,
            Ordered,
            MaxSet,
            IntermediateType,
            Implementations,
            Variadic,
            Normal,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "arguments" => Ok(GeneratedField::Arguments),
                            "name" => Ok(GeneratedField::Name),
                            "description" => Ok(GeneratedField::Description),
                            "deterministic" => Ok(GeneratedField::Deterministic),
                            "sessionDependent" | "session_dependent" => Ok(GeneratedField::SessionDependent),
                            "outputType" | "output_type" => Ok(GeneratedField::OutputType),
                            "ordered" => Ok(GeneratedField::Ordered),
                            "maxSet" | "max_set" => Ok(GeneratedField::MaxSet),
                            "intermediateType" | "intermediate_type" => Ok(GeneratedField::IntermediateType),
                            "implementations" => Ok(GeneratedField::Implementations),
                            "variadic" => Ok(GeneratedField::Variadic),
                            "normal" => Ok(GeneratedField::Normal),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = function_signature::Aggregate;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.FunctionSignature.Aggregate")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<function_signature::Aggregate, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut arguments__ = None;
                let mut name__ = None;
                let mut description__ = None;
                let mut deterministic__ = None;
                let mut session_dependent__ = None;
                let mut output_type__ = None;
                let mut ordered__ = None;
                let mut max_set__ = None;
                let mut intermediate_type__ = None;
                let mut implementations__ = None;
                let mut final_variable_behavior__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Arguments => {
                            if arguments__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arguments"));
                            }
                            arguments__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Description => {
                            if description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("description"));
                            }
                            description__ = map_.next_value()?;
                        }
                        GeneratedField::Deterministic => {
                            if deterministic__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deterministic"));
                            }
                            deterministic__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SessionDependent => {
                            if session_dependent__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sessionDependent"));
                            }
                            session_dependent__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OutputType => {
                            if output_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("outputType"));
                            }
                            output_type__ = map_.next_value()?;
                        }
                        GeneratedField::Ordered => {
                            if ordered__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ordered"));
                            }
                            ordered__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MaxSet => {
                            if max_set__.is_some() {
                                return Err(serde::de::Error::duplicate_field("maxSet"));
                            }
                            max_set__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::IntermediateType => {
                            if intermediate_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("intermediateType"));
                            }
                            intermediate_type__ = map_.next_value()?;
                        }
                        GeneratedField::Implementations => {
                            if implementations__.is_some() {
                                return Err(serde::de::Error::duplicate_field("implementations"));
                            }
                            implementations__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Variadic => {
                            if final_variable_behavior__.is_some() {
                                return Err(serde::de::Error::duplicate_field("variadic"));
                            }
                            final_variable_behavior__ = map_.next_value::<::std::option::Option<_>>()?.map(function_signature::aggregate::FinalVariableBehavior::Variadic)
;
                        }
                        GeneratedField::Normal => {
                            if final_variable_behavior__.is_some() {
                                return Err(serde::de::Error::duplicate_field("normal"));
                            }
                            final_variable_behavior__ = map_.next_value::<::std::option::Option<_>>()?.map(function_signature::aggregate::FinalVariableBehavior::Normal)
;
                        }
                    }
                }
                Ok(function_signature::Aggregate {
                    arguments: arguments__.unwrap_or_default(),
                    name: name__.unwrap_or_default(),
                    description: description__,
                    deterministic: deterministic__.unwrap_or_default(),
                    session_dependent: session_dependent__.unwrap_or_default(),
                    output_type: output_type__,
                    ordered: ordered__.unwrap_or_default(),
                    max_set: max_set__.unwrap_or_default(),
                    intermediate_type: intermediate_type__,
                    implementations: implementations__.unwrap_or_default(),
                    final_variable_behavior: final_variable_behavior__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.FunctionSignature.Aggregate", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for function_signature::Argument {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.name.is_empty() {
            len += 1;
        }
        if self.argument_kind.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.FunctionSignature.Argument", len)?;
        if !self.name.is_empty() {
            struct_ser.serialize_field("name", &self.name)?;
        }
        if let Some(v) = self.argument_kind.as_ref() {
            match v {
                function_signature::argument::ArgumentKind::Value(v) => {
                    struct_ser.serialize_field("value", v)?;
                }
                function_signature::argument::ArgumentKind::Type(v) => {
                    struct_ser.serialize_field("type", v)?;
                }
                function_signature::argument::ArgumentKind::Enum(v) => {
                    struct_ser.serialize_field("enum", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for function_signature::Argument {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "value",
            "type",
            "enum",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Value,
            Type,
            Enum,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "value" => Ok(GeneratedField::Value),
                            "type" => Ok(GeneratedField::Type),
                            "enum" => Ok(GeneratedField::Enum),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = function_signature::Argument;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.FunctionSignature.Argument")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<function_signature::Argument, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut argument_kind__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Value => {
                            if argument_kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            argument_kind__ = map_.next_value::<::std::option::Option<_>>()?.map(function_signature::argument::ArgumentKind::Value)
;
                        }
                        GeneratedField::Type => {
                            if argument_kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            argument_kind__ = map_.next_value::<::std::option::Option<_>>()?.map(function_signature::argument::ArgumentKind::Type)
;
                        }
                        GeneratedField::Enum => {
                            if argument_kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("enum"));
                            }
                            argument_kind__ = map_.next_value::<::std::option::Option<_>>()?.map(function_signature::argument::ArgumentKind::Enum)
;
                        }
                    }
                }
                Ok(function_signature::Argument {
                    name: name__.unwrap_or_default(),
                    argument_kind: argument_kind__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.FunctionSignature.Argument", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for function_signature::argument::EnumArgument {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.options.is_empty() {
            len += 1;
        }
        if self.optional {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.FunctionSignature.Argument.EnumArgument", len)?;
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        if self.optional {
            struct_ser.serialize_field("optional", &self.optional)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for function_signature::argument::EnumArgument {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "options",
            "optional",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Options,
            Optional,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "options" => Ok(GeneratedField::Options),
                            "optional" => Ok(GeneratedField::Optional),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = function_signature::argument::EnumArgument;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.FunctionSignature.Argument.EnumArgument")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<function_signature::argument::EnumArgument, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut options__ = None;
                let mut optional__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Optional => {
                            if optional__.is_some() {
                                return Err(serde::de::Error::duplicate_field("optional"));
                            }
                            optional__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(function_signature::argument::EnumArgument {
                    options: options__.unwrap_or_default(),
                    optional: optional__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.FunctionSignature.Argument.EnumArgument", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for function_signature::argument::TypeArgument {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.r#type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.FunctionSignature.Argument.TypeArgument", len)?;
        if let Some(v) = self.r#type.as_ref() {
            struct_ser.serialize_field("type", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for function_signature::argument::TypeArgument {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = function_signature::argument::TypeArgument;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.FunctionSignature.Argument.TypeArgument")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<function_signature::argument::TypeArgument, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = map_.next_value()?;
                        }
                    }
                }
                Ok(function_signature::argument::TypeArgument {
                    r#type: r#type__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.FunctionSignature.Argument.TypeArgument", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for function_signature::argument::ValueArgument {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.r#type.is_some() {
            len += 1;
        }
        if self.constant {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.FunctionSignature.Argument.ValueArgument", len)?;
        if let Some(v) = self.r#type.as_ref() {
            struct_ser.serialize_field("type", v)?;
        }
        if self.constant {
            struct_ser.serialize_field("constant", &self.constant)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for function_signature::argument::ValueArgument {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "constant",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Constant,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "constant" => Ok(GeneratedField::Constant),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = function_signature::argument::ValueArgument;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.FunctionSignature.Argument.ValueArgument")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<function_signature::argument::ValueArgument, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut constant__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = map_.next_value()?;
                        }
                        GeneratedField::Constant => {
                            if constant__.is_some() {
                                return Err(serde::de::Error::duplicate_field("constant"));
                            }
                            constant__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(function_signature::argument::ValueArgument {
                    r#type: r#type__,
                    constant: constant__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.FunctionSignature.Argument.ValueArgument", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for function_signature::Description {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.language.is_empty() {
            len += 1;
        }
        if !self.body.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.FunctionSignature.Description", len)?;
        if !self.language.is_empty() {
            struct_ser.serialize_field("language", &self.language)?;
        }
        if !self.body.is_empty() {
            struct_ser.serialize_field("body", &self.body)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for function_signature::Description {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "language",
            "body",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Language,
            Body,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "language" => Ok(GeneratedField::Language),
                            "body" => Ok(GeneratedField::Body),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = function_signature::Description;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.FunctionSignature.Description")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<function_signature::Description, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut language__ = None;
                let mut body__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Language => {
                            if language__.is_some() {
                                return Err(serde::de::Error::duplicate_field("language"));
                            }
                            language__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Body => {
                            if body__.is_some() {
                                return Err(serde::de::Error::duplicate_field("body"));
                            }
                            body__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(function_signature::Description {
                    language: language__.unwrap_or_default(),
                    body: body__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.FunctionSignature.Description", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for function_signature::FinalArgNormal {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("substrait.FunctionSignature.FinalArgNormal", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for function_signature::FinalArgNormal {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = function_signature::FinalArgNormal;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.FunctionSignature.FinalArgNormal")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<function_signature::FinalArgNormal, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(function_signature::FinalArgNormal {
                })
            }
        }
        deserializer.deserialize_struct("substrait.FunctionSignature.FinalArgNormal", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for function_signature::FinalArgVariadic {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.min_args != 0 {
            len += 1;
        }
        if self.max_args != 0 {
            len += 1;
        }
        if self.consistency != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.FunctionSignature.FinalArgVariadic", len)?;
        if self.min_args != 0 {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("minArgs", ToString::to_string(&self.min_args).as_str())?;
        }
        if self.max_args != 0 {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("maxArgs", ToString::to_string(&self.max_args).as_str())?;
        }
        if self.consistency != 0 {
            let v = function_signature::final_arg_variadic::ParameterConsistency::try_from(self.consistency)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.consistency)))?;
            struct_ser.serialize_field("consistency", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for function_signature::FinalArgVariadic {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "min_args",
            "minArgs",
            "max_args",
            "maxArgs",
            "consistency",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MinArgs,
            MaxArgs,
            Consistency,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "minArgs" | "min_args" => Ok(GeneratedField::MinArgs),
                            "maxArgs" | "max_args" => Ok(GeneratedField::MaxArgs),
                            "consistency" => Ok(GeneratedField::Consistency),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = function_signature::FinalArgVariadic;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.FunctionSignature.FinalArgVariadic")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<function_signature::FinalArgVariadic, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut min_args__ = None;
                let mut max_args__ = None;
                let mut consistency__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MinArgs => {
                            if min_args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minArgs"));
                            }
                            min_args__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::MaxArgs => {
                            if max_args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("maxArgs"));
                            }
                            max_args__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Consistency => {
                            if consistency__.is_some() {
                                return Err(serde::de::Error::duplicate_field("consistency"));
                            }
                            consistency__ = Some(map_.next_value::<function_signature::final_arg_variadic::ParameterConsistency>()? as i32);
                        }
                    }
                }
                Ok(function_signature::FinalArgVariadic {
                    min_args: min_args__.unwrap_or_default(),
                    max_args: max_args__.unwrap_or_default(),
                    consistency: consistency__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.FunctionSignature.FinalArgVariadic", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for function_signature::final_arg_variadic::ParameterConsistency {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unspecified => "PARAMETER_CONSISTENCY_UNSPECIFIED",
            Self::Consistent => "PARAMETER_CONSISTENCY_CONSISTENT",
            Self::Inconsistent => "PARAMETER_CONSISTENCY_INCONSISTENT",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for function_signature::final_arg_variadic::ParameterConsistency {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PARAMETER_CONSISTENCY_UNSPECIFIED",
            "PARAMETER_CONSISTENCY_CONSISTENT",
            "PARAMETER_CONSISTENCY_INCONSISTENT",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = function_signature::final_arg_variadic::ParameterConsistency;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "PARAMETER_CONSISTENCY_UNSPECIFIED" => Ok(function_signature::final_arg_variadic::ParameterConsistency::Unspecified),
                    "PARAMETER_CONSISTENCY_CONSISTENT" => Ok(function_signature::final_arg_variadic::ParameterConsistency::Consistent),
                    "PARAMETER_CONSISTENCY_INCONSISTENT" => Ok(function_signature::final_arg_variadic::ParameterConsistency::Inconsistent),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for function_signature::Implementation {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.r#type != 0 {
            len += 1;
        }
        if !self.uri.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.FunctionSignature.Implementation", len)?;
        if self.r#type != 0 {
            let v = function_signature::implementation::Type::try_from(self.r#type)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
            struct_ser.serialize_field("type", &v)?;
        }
        if !self.uri.is_empty() {
            struct_ser.serialize_field("uri", &self.uri)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for function_signature::Implementation {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "uri",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Uri,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "uri" => Ok(GeneratedField::Uri),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = function_signature::Implementation;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.FunctionSignature.Implementation")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<function_signature::Implementation, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut uri__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<function_signature::implementation::Type>()? as i32);
                        }
                        GeneratedField::Uri => {
                            if uri__.is_some() {
                                return Err(serde::de::Error::duplicate_field("uri"));
                            }
                            uri__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(function_signature::Implementation {
                    r#type: r#type__.unwrap_or_default(),
                    uri: uri__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.FunctionSignature.Implementation", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for function_signature::implementation::Type {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unspecified => "TYPE_UNSPECIFIED",
            Self::WebAssembly => "TYPE_WEB_ASSEMBLY",
            Self::TrinoJar => "TYPE_TRINO_JAR",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for function_signature::implementation::Type {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TYPE_UNSPECIFIED",
            "TYPE_WEB_ASSEMBLY",
            "TYPE_TRINO_JAR",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = function_signature::implementation::Type;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "TYPE_UNSPECIFIED" => Ok(function_signature::implementation::Type::Unspecified),
                    "TYPE_WEB_ASSEMBLY" => Ok(function_signature::implementation::Type::WebAssembly),
                    "TYPE_TRINO_JAR" => Ok(function_signature::implementation::Type::TrinoJar),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for function_signature::Scalar {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.arguments.is_empty() {
            len += 1;
        }
        if !self.name.is_empty() {
            len += 1;
        }
        if self.description.is_some() {
            len += 1;
        }
        if self.deterministic {
            len += 1;
        }
        if self.session_dependent {
            len += 1;
        }
        if self.output_type.is_some() {
            len += 1;
        }
        if !self.implementations.is_empty() {
            len += 1;
        }
        if self.final_variable_behavior.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.FunctionSignature.Scalar", len)?;
        if !self.arguments.is_empty() {
            struct_ser.serialize_field("arguments", &self.arguments)?;
        }
        if !self.name.is_empty() {
            struct_ser.serialize_field("name", &self.name)?;
        }
        if let Some(v) = self.description.as_ref() {
            struct_ser.serialize_field("description", v)?;
        }
        if self.deterministic {
            struct_ser.serialize_field("deterministic", &self.deterministic)?;
        }
        if self.session_dependent {
            struct_ser.serialize_field("sessionDependent", &self.session_dependent)?;
        }
        if let Some(v) = self.output_type.as_ref() {
            struct_ser.serialize_field("outputType", v)?;
        }
        if !self.implementations.is_empty() {
            struct_ser.serialize_field("implementations", &self.implementations)?;
        }
        if let Some(v) = self.final_variable_behavior.as_ref() {
            match v {
                function_signature::scalar::FinalVariableBehavior::Variadic(v) => {
                    struct_ser.serialize_field("variadic", v)?;
                }
                function_signature::scalar::FinalVariableBehavior::Normal(v) => {
                    struct_ser.serialize_field("normal", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for function_signature::Scalar {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "arguments",
            "name",
            "description",
            "deterministic",
            "session_dependent",
            "sessionDependent",
            "output_type",
            "outputType",
            "implementations",
            "variadic",
            "normal",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Arguments,
            Name,
            Description,
            Deterministic,
            SessionDependent,
            OutputType,
            Implementations,
            Variadic,
            Normal,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "arguments" => Ok(GeneratedField::Arguments),
                            "name" => Ok(GeneratedField::Name),
                            "description" => Ok(GeneratedField::Description),
                            "deterministic" => Ok(GeneratedField::Deterministic),
                            "sessionDependent" | "session_dependent" => Ok(GeneratedField::SessionDependent),
                            "outputType" | "output_type" => Ok(GeneratedField::OutputType),
                            "implementations" => Ok(GeneratedField::Implementations),
                            "variadic" => Ok(GeneratedField::Variadic),
                            "normal" => Ok(GeneratedField::Normal),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = function_signature::Scalar;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.FunctionSignature.Scalar")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<function_signature::Scalar, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut arguments__ = None;
                let mut name__ = None;
                let mut description__ = None;
                let mut deterministic__ = None;
                let mut session_dependent__ = None;
                let mut output_type__ = None;
                let mut implementations__ = None;
                let mut final_variable_behavior__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Arguments => {
                            if arguments__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arguments"));
                            }
                            arguments__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Description => {
                            if description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("description"));
                            }
                            description__ = map_.next_value()?;
                        }
                        GeneratedField::Deterministic => {
                            if deterministic__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deterministic"));
                            }
                            deterministic__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SessionDependent => {
                            if session_dependent__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sessionDependent"));
                            }
                            session_dependent__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OutputType => {
                            if output_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("outputType"));
                            }
                            output_type__ = map_.next_value()?;
                        }
                        GeneratedField::Implementations => {
                            if implementations__.is_some() {
                                return Err(serde::de::Error::duplicate_field("implementations"));
                            }
                            implementations__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Variadic => {
                            if final_variable_behavior__.is_some() {
                                return Err(serde::de::Error::duplicate_field("variadic"));
                            }
                            final_variable_behavior__ = map_.next_value::<::std::option::Option<_>>()?.map(function_signature::scalar::FinalVariableBehavior::Variadic)
;
                        }
                        GeneratedField::Normal => {
                            if final_variable_behavior__.is_some() {
                                return Err(serde::de::Error::duplicate_field("normal"));
                            }
                            final_variable_behavior__ = map_.next_value::<::std::option::Option<_>>()?.map(function_signature::scalar::FinalVariableBehavior::Normal)
;
                        }
                    }
                }
                Ok(function_signature::Scalar {
                    arguments: arguments__.unwrap_or_default(),
                    name: name__.unwrap_or_default(),
                    description: description__,
                    deterministic: deterministic__.unwrap_or_default(),
                    session_dependent: session_dependent__.unwrap_or_default(),
                    output_type: output_type__,
                    implementations: implementations__.unwrap_or_default(),
                    final_variable_behavior: final_variable_behavior__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.FunctionSignature.Scalar", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for function_signature::Window {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.arguments.is_empty() {
            len += 1;
        }
        if !self.name.is_empty() {
            len += 1;
        }
        if self.description.is_some() {
            len += 1;
        }
        if self.deterministic {
            len += 1;
        }
        if self.session_dependent {
            len += 1;
        }
        if self.intermediate_type.is_some() {
            len += 1;
        }
        if self.output_type.is_some() {
            len += 1;
        }
        if self.ordered {
            len += 1;
        }
        if self.max_set != 0 {
            len += 1;
        }
        if self.window_type != 0 {
            len += 1;
        }
        if !self.implementations.is_empty() {
            len += 1;
        }
        if self.final_variable_behavior.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.FunctionSignature.Window", len)?;
        if !self.arguments.is_empty() {
            struct_ser.serialize_field("arguments", &self.arguments)?;
        }
        if !self.name.is_empty() {
            struct_ser.serialize_field("name", &self.name)?;
        }
        if let Some(v) = self.description.as_ref() {
            struct_ser.serialize_field("description", v)?;
        }
        if self.deterministic {
            struct_ser.serialize_field("deterministic", &self.deterministic)?;
        }
        if self.session_dependent {
            struct_ser.serialize_field("sessionDependent", &self.session_dependent)?;
        }
        if let Some(v) = self.intermediate_type.as_ref() {
            struct_ser.serialize_field("intermediateType", v)?;
        }
        if let Some(v) = self.output_type.as_ref() {
            struct_ser.serialize_field("outputType", v)?;
        }
        if self.ordered {
            struct_ser.serialize_field("ordered", &self.ordered)?;
        }
        if self.max_set != 0 {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("maxSet", ToString::to_string(&self.max_set).as_str())?;
        }
        if self.window_type != 0 {
            let v = function_signature::window::WindowType::try_from(self.window_type)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.window_type)))?;
            struct_ser.serialize_field("windowType", &v)?;
        }
        if !self.implementations.is_empty() {
            struct_ser.serialize_field("implementations", &self.implementations)?;
        }
        if let Some(v) = self.final_variable_behavior.as_ref() {
            match v {
                function_signature::window::FinalVariableBehavior::Variadic(v) => {
                    struct_ser.serialize_field("variadic", v)?;
                }
                function_signature::window::FinalVariableBehavior::Normal(v) => {
                    struct_ser.serialize_field("normal", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for function_signature::Window {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "arguments",
            "name",
            "description",
            "deterministic",
            "session_dependent",
            "sessionDependent",
            "intermediate_type",
            "intermediateType",
            "output_type",
            "outputType",
            "ordered",
            "max_set",
            "maxSet",
            "window_type",
            "windowType",
            "implementations",
            "variadic",
            "normal",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Arguments,
            Name,
            Description,
            Deterministic,
            SessionDependent,
            IntermediateType,
            OutputType,
            Ordered,
            MaxSet,
            WindowType,
            Implementations,
            Variadic,
            Normal,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "arguments" => Ok(GeneratedField::Arguments),
                            "name" => Ok(GeneratedField::Name),
                            "description" => Ok(GeneratedField::Description),
                            "deterministic" => Ok(GeneratedField::Deterministic),
                            "sessionDependent" | "session_dependent" => Ok(GeneratedField::SessionDependent),
                            "intermediateType" | "intermediate_type" => Ok(GeneratedField::IntermediateType),
                            "outputType" | "output_type" => Ok(GeneratedField::OutputType),
                            "ordered" => Ok(GeneratedField::Ordered),
                            "maxSet" | "max_set" => Ok(GeneratedField::MaxSet),
                            "windowType" | "window_type" => Ok(GeneratedField::WindowType),
                            "implementations" => Ok(GeneratedField::Implementations),
                            "variadic" => Ok(GeneratedField::Variadic),
                            "normal" => Ok(GeneratedField::Normal),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = function_signature::Window;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.FunctionSignature.Window")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<function_signature::Window, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut arguments__ = None;
                let mut name__ = None;
                let mut description__ = None;
                let mut deterministic__ = None;
                let mut session_dependent__ = None;
                let mut intermediate_type__ = None;
                let mut output_type__ = None;
                let mut ordered__ = None;
                let mut max_set__ = None;
                let mut window_type__ = None;
                let mut implementations__ = None;
                let mut final_variable_behavior__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Arguments => {
                            if arguments__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arguments"));
                            }
                            arguments__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Description => {
                            if description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("description"));
                            }
                            description__ = map_.next_value()?;
                        }
                        GeneratedField::Deterministic => {
                            if deterministic__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deterministic"));
                            }
                            deterministic__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SessionDependent => {
                            if session_dependent__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sessionDependent"));
                            }
                            session_dependent__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IntermediateType => {
                            if intermediate_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("intermediateType"));
                            }
                            intermediate_type__ = map_.next_value()?;
                        }
                        GeneratedField::OutputType => {
                            if output_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("outputType"));
                            }
                            output_type__ = map_.next_value()?;
                        }
                        GeneratedField::Ordered => {
                            if ordered__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ordered"));
                            }
                            ordered__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MaxSet => {
                            if max_set__.is_some() {
                                return Err(serde::de::Error::duplicate_field("maxSet"));
                            }
                            max_set__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::WindowType => {
                            if window_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("windowType"));
                            }
                            window_type__ = Some(map_.next_value::<function_signature::window::WindowType>()? as i32);
                        }
                        GeneratedField::Implementations => {
                            if implementations__.is_some() {
                                return Err(serde::de::Error::duplicate_field("implementations"));
                            }
                            implementations__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Variadic => {
                            if final_variable_behavior__.is_some() {
                                return Err(serde::de::Error::duplicate_field("variadic"));
                            }
                            final_variable_behavior__ = map_.next_value::<::std::option::Option<_>>()?.map(function_signature::window::FinalVariableBehavior::Variadic)
;
                        }
                        GeneratedField::Normal => {
                            if final_variable_behavior__.is_some() {
                                return Err(serde::de::Error::duplicate_field("normal"));
                            }
                            final_variable_behavior__ = map_.next_value::<::std::option::Option<_>>()?.map(function_signature::window::FinalVariableBehavior::Normal)
;
                        }
                    }
                }
                Ok(function_signature::Window {
                    arguments: arguments__.unwrap_or_default(),
                    name: name__.unwrap_or_default(),
                    description: description__,
                    deterministic: deterministic__.unwrap_or_default(),
                    session_dependent: session_dependent__.unwrap_or_default(),
                    intermediate_type: intermediate_type__,
                    output_type: output_type__,
                    ordered: ordered__.unwrap_or_default(),
                    max_set: max_set__.unwrap_or_default(),
                    window_type: window_type__.unwrap_or_default(),
                    implementations: implementations__.unwrap_or_default(),
                    final_variable_behavior: final_variable_behavior__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.FunctionSignature.Window", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for function_signature::window::WindowType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unspecified => "WINDOW_TYPE_UNSPECIFIED",
            Self::Streaming => "WINDOW_TYPE_STREAMING",
            Self::Partition => "WINDOW_TYPE_PARTITION",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for function_signature::window::WindowType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "WINDOW_TYPE_UNSPECIFIED",
            "WINDOW_TYPE_STREAMING",
            "WINDOW_TYPE_PARTITION",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = function_signature::window::WindowType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "WINDOW_TYPE_UNSPECIFIED" => Ok(function_signature::window::WindowType::Unspecified),
                    "WINDOW_TYPE_STREAMING" => Ok(function_signature::window::WindowType::Streaming),
                    "WINDOW_TYPE_PARTITION" => Ok(function_signature::window::WindowType::Partition),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for HashJoinRel {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.common.is_some() {
            len += 1;
        }
        if self.left.is_some() {
            len += 1;
        }
        if self.right.is_some() {
            len += 1;
        }
        if !self.left_keys.is_empty() {
            len += 1;
        }
        if !self.right_keys.is_empty() {
            len += 1;
        }
        if !self.keys.is_empty() {
            len += 1;
        }
        if self.post_join_filter.is_some() {
            len += 1;
        }
        if self.r#type != 0 {
            len += 1;
        }
        if self.build_input != 0 {
            len += 1;
        }
        if self.advanced_extension.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.HashJoinRel", len)?;
        if let Some(v) = self.common.as_ref() {
            struct_ser.serialize_field("common", v)?;
        }
        if let Some(v) = self.left.as_ref() {
            struct_ser.serialize_field("left", v)?;
        }
        if let Some(v) = self.right.as_ref() {
            struct_ser.serialize_field("right", v)?;
        }
        if !self.left_keys.is_empty() {
            struct_ser.serialize_field("leftKeys", &self.left_keys)?;
        }
        if !self.right_keys.is_empty() {
            struct_ser.serialize_field("rightKeys", &self.right_keys)?;
        }
        if !self.keys.is_empty() {
            struct_ser.serialize_field("keys", &self.keys)?;
        }
        if let Some(v) = self.post_join_filter.as_ref() {
            struct_ser.serialize_field("postJoinFilter", v)?;
        }
        if self.r#type != 0 {
            let v = hash_join_rel::JoinType::try_from(self.r#type)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
            struct_ser.serialize_field("type", &v)?;
        }
        if self.build_input != 0 {
            let v = hash_join_rel::BuildInput::try_from(self.build_input)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.build_input)))?;
            struct_ser.serialize_field("buildInput", &v)?;
        }
        if let Some(v) = self.advanced_extension.as_ref() {
            struct_ser.serialize_field("advancedExtension", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for HashJoinRel {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "common",
            "left",
            "right",
            "left_keys",
            "leftKeys",
            "right_keys",
            "rightKeys",
            "keys",
            "post_join_filter",
            "postJoinFilter",
            "type",
            "build_input",
            "buildInput",
            "advanced_extension",
            "advancedExtension",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Common,
            Left,
            Right,
            LeftKeys,
            RightKeys,
            Keys,
            PostJoinFilter,
            Type,
            BuildInput,
            AdvancedExtension,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "common" => Ok(GeneratedField::Common),
                            "left" => Ok(GeneratedField::Left),
                            "right" => Ok(GeneratedField::Right),
                            "leftKeys" | "left_keys" => Ok(GeneratedField::LeftKeys),
                            "rightKeys" | "right_keys" => Ok(GeneratedField::RightKeys),
                            "keys" => Ok(GeneratedField::Keys),
                            "postJoinFilter" | "post_join_filter" => Ok(GeneratedField::PostJoinFilter),
                            "type" => Ok(GeneratedField::Type),
                            "buildInput" | "build_input" => Ok(GeneratedField::BuildInput),
                            "advancedExtension" | "advanced_extension" => Ok(GeneratedField::AdvancedExtension),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = HashJoinRel;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.HashJoinRel")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<HashJoinRel, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut common__ = None;
                let mut left__ = None;
                let mut right__ = None;
                let mut left_keys__ = None;
                let mut right_keys__ = None;
                let mut keys__ = None;
                let mut post_join_filter__ = None;
                let mut r#type__ = None;
                let mut build_input__ = None;
                let mut advanced_extension__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Common => {
                            if common__.is_some() {
                                return Err(serde::de::Error::duplicate_field("common"));
                            }
                            common__ = map_.next_value()?;
                        }
                        GeneratedField::Left => {
                            if left__.is_some() {
                                return Err(serde::de::Error::duplicate_field("left"));
                            }
                            left__ = map_.next_value()?;
                        }
                        GeneratedField::Right => {
                            if right__.is_some() {
                                return Err(serde::de::Error::duplicate_field("right"));
                            }
                            right__ = map_.next_value()?;
                        }
                        GeneratedField::LeftKeys => {
                            if left_keys__.is_some() {
                                return Err(serde::de::Error::duplicate_field("leftKeys"));
                            }
                            left_keys__ = Some(map_.next_value()?);
                        }
                        GeneratedField::RightKeys => {
                            if right_keys__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rightKeys"));
                            }
                            right_keys__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Keys => {
                            if keys__.is_some() {
                                return Err(serde::de::Error::duplicate_field("keys"));
                            }
                            keys__ = Some(map_.next_value()?);
                        }
                        GeneratedField::PostJoinFilter => {
                            if post_join_filter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("postJoinFilter"));
                            }
                            post_join_filter__ = map_.next_value()?;
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<hash_join_rel::JoinType>()? as i32);
                        }
                        GeneratedField::BuildInput => {
                            if build_input__.is_some() {
                                return Err(serde::de::Error::duplicate_field("buildInput"));
                            }
                            build_input__ = Some(map_.next_value::<hash_join_rel::BuildInput>()? as i32);
                        }
                        GeneratedField::AdvancedExtension => {
                            if advanced_extension__.is_some() {
                                return Err(serde::de::Error::duplicate_field("advancedExtension"));
                            }
                            advanced_extension__ = map_.next_value()?;
                        }
                    }
                }
                Ok(HashJoinRel {
                    common: common__,
                    left: left__,
                    right: right__,
                    left_keys: left_keys__.unwrap_or_default(),
                    right_keys: right_keys__.unwrap_or_default(),
                    keys: keys__.unwrap_or_default(),
                    post_join_filter: post_join_filter__,
                    r#type: r#type__.unwrap_or_default(),
                    build_input: build_input__.unwrap_or_default(),
                    advanced_extension: advanced_extension__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.HashJoinRel", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for hash_join_rel::BuildInput {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unspecified => "BUILD_INPUT_UNSPECIFIED",
            Self::Left => "BUILD_INPUT_LEFT",
            Self::Right => "BUILD_INPUT_RIGHT",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for hash_join_rel::BuildInput {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BUILD_INPUT_UNSPECIFIED",
            "BUILD_INPUT_LEFT",
            "BUILD_INPUT_RIGHT",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = hash_join_rel::BuildInput;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "BUILD_INPUT_UNSPECIFIED" => Ok(hash_join_rel::BuildInput::Unspecified),
                    "BUILD_INPUT_LEFT" => Ok(hash_join_rel::BuildInput::Left),
                    "BUILD_INPUT_RIGHT" => Ok(hash_join_rel::BuildInput::Right),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for hash_join_rel::JoinType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unspecified => "JOIN_TYPE_UNSPECIFIED",
            Self::Inner => "JOIN_TYPE_INNER",
            Self::Outer => "JOIN_TYPE_OUTER",
            Self::Left => "JOIN_TYPE_LEFT",
            Self::Right => "JOIN_TYPE_RIGHT",
            Self::LeftSemi => "JOIN_TYPE_LEFT_SEMI",
            Self::RightSemi => "JOIN_TYPE_RIGHT_SEMI",
            Self::LeftAnti => "JOIN_TYPE_LEFT_ANTI",
            Self::RightAnti => "JOIN_TYPE_RIGHT_ANTI",
            Self::LeftSingle => "JOIN_TYPE_LEFT_SINGLE",
            Self::RightSingle => "JOIN_TYPE_RIGHT_SINGLE",
            Self::LeftMark => "JOIN_TYPE_LEFT_MARK",
            Self::RightMark => "JOIN_TYPE_RIGHT_MARK",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for hash_join_rel::JoinType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "JOIN_TYPE_UNSPECIFIED",
            "JOIN_TYPE_INNER",
            "JOIN_TYPE_OUTER",
            "JOIN_TYPE_LEFT",
            "JOIN_TYPE_RIGHT",
            "JOIN_TYPE_LEFT_SEMI",
            "JOIN_TYPE_RIGHT_SEMI",
            "JOIN_TYPE_LEFT_ANTI",
            "JOIN_TYPE_RIGHT_ANTI",
            "JOIN_TYPE_LEFT_SINGLE",
            "JOIN_TYPE_RIGHT_SINGLE",
            "JOIN_TYPE_LEFT_MARK",
            "JOIN_TYPE_RIGHT_MARK",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = hash_join_rel::JoinType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "JOIN_TYPE_UNSPECIFIED" => Ok(hash_join_rel::JoinType::Unspecified),
                    "JOIN_TYPE_INNER" => Ok(hash_join_rel::JoinType::Inner),
                    "JOIN_TYPE_OUTER" => Ok(hash_join_rel::JoinType::Outer),
                    "JOIN_TYPE_LEFT" => Ok(hash_join_rel::JoinType::Left),
                    "JOIN_TYPE_RIGHT" => Ok(hash_join_rel::JoinType::Right),
                    "JOIN_TYPE_LEFT_SEMI" => Ok(hash_join_rel::JoinType::LeftSemi),
                    "JOIN_TYPE_RIGHT_SEMI" => Ok(hash_join_rel::JoinType::RightSemi),
                    "JOIN_TYPE_LEFT_ANTI" => Ok(hash_join_rel::JoinType::LeftAnti),
                    "JOIN_TYPE_RIGHT_ANTI" => Ok(hash_join_rel::JoinType::RightAnti),
                    "JOIN_TYPE_LEFT_SINGLE" => Ok(hash_join_rel::JoinType::LeftSingle),
                    "JOIN_TYPE_RIGHT_SINGLE" => Ok(hash_join_rel::JoinType::RightSingle),
                    "JOIN_TYPE_LEFT_MARK" => Ok(hash_join_rel::JoinType::LeftMark),
                    "JOIN_TYPE_RIGHT_MARK" => Ok(hash_join_rel::JoinType::RightMark),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for JoinRel {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.common.is_some() {
            len += 1;
        }
        if self.left.is_some() {
            len += 1;
        }
        if self.right.is_some() {
            len += 1;
        }
        if self.expression.is_some() {
            len += 1;
        }
        if self.post_join_filter.is_some() {
            len += 1;
        }
        if self.r#type != 0 {
            len += 1;
        }
        if self.advanced_extension.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.JoinRel", len)?;
        if let Some(v) = self.common.as_ref() {
            struct_ser.serialize_field("common", v)?;
        }
        if let Some(v) = self.left.as_ref() {
            struct_ser.serialize_field("left", v)?;
        }
        if let Some(v) = self.right.as_ref() {
            struct_ser.serialize_field("right", v)?;
        }
        if let Some(v) = self.expression.as_ref() {
            struct_ser.serialize_field("expression", v)?;
        }
        if let Some(v) = self.post_join_filter.as_ref() {
            struct_ser.serialize_field("postJoinFilter", v)?;
        }
        if self.r#type != 0 {
            let v = join_rel::JoinType::try_from(self.r#type)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
            struct_ser.serialize_field("type", &v)?;
        }
        if let Some(v) = self.advanced_extension.as_ref() {
            struct_ser.serialize_field("advancedExtension", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for JoinRel {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "common",
            "left",
            "right",
            "expression",
            "post_join_filter",
            "postJoinFilter",
            "type",
            "advanced_extension",
            "advancedExtension",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Common,
            Left,
            Right,
            Expression,
            PostJoinFilter,
            Type,
            AdvancedExtension,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "common" => Ok(GeneratedField::Common),
                            "left" => Ok(GeneratedField::Left),
                            "right" => Ok(GeneratedField::Right),
                            "expression" => Ok(GeneratedField::Expression),
                            "postJoinFilter" | "post_join_filter" => Ok(GeneratedField::PostJoinFilter),
                            "type" => Ok(GeneratedField::Type),
                            "advancedExtension" | "advanced_extension" => Ok(GeneratedField::AdvancedExtension),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = JoinRel;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.JoinRel")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<JoinRel, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut common__ = None;
                let mut left__ = None;
                let mut right__ = None;
                let mut expression__ = None;
                let mut post_join_filter__ = None;
                let mut r#type__ = None;
                let mut advanced_extension__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Common => {
                            if common__.is_some() {
                                return Err(serde::de::Error::duplicate_field("common"));
                            }
                            common__ = map_.next_value()?;
                        }
                        GeneratedField::Left => {
                            if left__.is_some() {
                                return Err(serde::de::Error::duplicate_field("left"));
                            }
                            left__ = map_.next_value()?;
                        }
                        GeneratedField::Right => {
                            if right__.is_some() {
                                return Err(serde::de::Error::duplicate_field("right"));
                            }
                            right__ = map_.next_value()?;
                        }
                        GeneratedField::Expression => {
                            if expression__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expression"));
                            }
                            expression__ = map_.next_value()?;
                        }
                        GeneratedField::PostJoinFilter => {
                            if post_join_filter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("postJoinFilter"));
                            }
                            post_join_filter__ = map_.next_value()?;
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<join_rel::JoinType>()? as i32);
                        }
                        GeneratedField::AdvancedExtension => {
                            if advanced_extension__.is_some() {
                                return Err(serde::de::Error::duplicate_field("advancedExtension"));
                            }
                            advanced_extension__ = map_.next_value()?;
                        }
                    }
                }
                Ok(JoinRel {
                    common: common__,
                    left: left__,
                    right: right__,
                    expression: expression__,
                    post_join_filter: post_join_filter__,
                    r#type: r#type__.unwrap_or_default(),
                    advanced_extension: advanced_extension__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.JoinRel", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for join_rel::JoinType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unspecified => "JOIN_TYPE_UNSPECIFIED",
            Self::Inner => "JOIN_TYPE_INNER",
            Self::Outer => "JOIN_TYPE_OUTER",
            Self::Left => "JOIN_TYPE_LEFT",
            Self::Right => "JOIN_TYPE_RIGHT",
            Self::LeftSemi => "JOIN_TYPE_LEFT_SEMI",
            Self::LeftAnti => "JOIN_TYPE_LEFT_ANTI",
            Self::LeftSingle => "JOIN_TYPE_LEFT_SINGLE",
            Self::RightSemi => "JOIN_TYPE_RIGHT_SEMI",
            Self::RightAnti => "JOIN_TYPE_RIGHT_ANTI",
            Self::RightSingle => "JOIN_TYPE_RIGHT_SINGLE",
            Self::LeftMark => "JOIN_TYPE_LEFT_MARK",
            Self::RightMark => "JOIN_TYPE_RIGHT_MARK",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for join_rel::JoinType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "JOIN_TYPE_UNSPECIFIED",
            "JOIN_TYPE_INNER",
            "JOIN_TYPE_OUTER",
            "JOIN_TYPE_LEFT",
            "JOIN_TYPE_RIGHT",
            "JOIN_TYPE_LEFT_SEMI",
            "JOIN_TYPE_LEFT_ANTI",
            "JOIN_TYPE_LEFT_SINGLE",
            "JOIN_TYPE_RIGHT_SEMI",
            "JOIN_TYPE_RIGHT_ANTI",
            "JOIN_TYPE_RIGHT_SINGLE",
            "JOIN_TYPE_LEFT_MARK",
            "JOIN_TYPE_RIGHT_MARK",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = join_rel::JoinType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "JOIN_TYPE_UNSPECIFIED" => Ok(join_rel::JoinType::Unspecified),
                    "JOIN_TYPE_INNER" => Ok(join_rel::JoinType::Inner),
                    "JOIN_TYPE_OUTER" => Ok(join_rel::JoinType::Outer),
                    "JOIN_TYPE_LEFT" => Ok(join_rel::JoinType::Left),
                    "JOIN_TYPE_RIGHT" => Ok(join_rel::JoinType::Right),
                    "JOIN_TYPE_LEFT_SEMI" => Ok(join_rel::JoinType::LeftSemi),
                    "JOIN_TYPE_LEFT_ANTI" => Ok(join_rel::JoinType::LeftAnti),
                    "JOIN_TYPE_LEFT_SINGLE" => Ok(join_rel::JoinType::LeftSingle),
                    "JOIN_TYPE_RIGHT_SEMI" => Ok(join_rel::JoinType::RightSemi),
                    "JOIN_TYPE_RIGHT_ANTI" => Ok(join_rel::JoinType::RightAnti),
                    "JOIN_TYPE_RIGHT_SINGLE" => Ok(join_rel::JoinType::RightSingle),
                    "JOIN_TYPE_LEFT_MARK" => Ok(join_rel::JoinType::LeftMark),
                    "JOIN_TYPE_RIGHT_MARK" => Ok(join_rel::JoinType::RightMark),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for MergeJoinRel {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.common.is_some() {
            len += 1;
        }
        if self.left.is_some() {
            len += 1;
        }
        if self.right.is_some() {
            len += 1;
        }
        if !self.left_keys.is_empty() {
            len += 1;
        }
        if !self.right_keys.is_empty() {
            len += 1;
        }
        if !self.keys.is_empty() {
            len += 1;
        }
        if self.post_join_filter.is_some() {
            len += 1;
        }
        if self.r#type != 0 {
            len += 1;
        }
        if self.advanced_extension.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.MergeJoinRel", len)?;
        if let Some(v) = self.common.as_ref() {
            struct_ser.serialize_field("common", v)?;
        }
        if let Some(v) = self.left.as_ref() {
            struct_ser.serialize_field("left", v)?;
        }
        if let Some(v) = self.right.as_ref() {
            struct_ser.serialize_field("right", v)?;
        }
        if !self.left_keys.is_empty() {
            struct_ser.serialize_field("leftKeys", &self.left_keys)?;
        }
        if !self.right_keys.is_empty() {
            struct_ser.serialize_field("rightKeys", &self.right_keys)?;
        }
        if !self.keys.is_empty() {
            struct_ser.serialize_field("keys", &self.keys)?;
        }
        if let Some(v) = self.post_join_filter.as_ref() {
            struct_ser.serialize_field("postJoinFilter", v)?;
        }
        if self.r#type != 0 {
            let v = merge_join_rel::JoinType::try_from(self.r#type)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
            struct_ser.serialize_field("type", &v)?;
        }
        if let Some(v) = self.advanced_extension.as_ref() {
            struct_ser.serialize_field("advancedExtension", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MergeJoinRel {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "common",
            "left",
            "right",
            "left_keys",
            "leftKeys",
            "right_keys",
            "rightKeys",
            "keys",
            "post_join_filter",
            "postJoinFilter",
            "type",
            "advanced_extension",
            "advancedExtension",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Common,
            Left,
            Right,
            LeftKeys,
            RightKeys,
            Keys,
            PostJoinFilter,
            Type,
            AdvancedExtension,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "common" => Ok(GeneratedField::Common),
                            "left" => Ok(GeneratedField::Left),
                            "right" => Ok(GeneratedField::Right),
                            "leftKeys" | "left_keys" => Ok(GeneratedField::LeftKeys),
                            "rightKeys" | "right_keys" => Ok(GeneratedField::RightKeys),
                            "keys" => Ok(GeneratedField::Keys),
                            "postJoinFilter" | "post_join_filter" => Ok(GeneratedField::PostJoinFilter),
                            "type" => Ok(GeneratedField::Type),
                            "advancedExtension" | "advanced_extension" => Ok(GeneratedField::AdvancedExtension),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MergeJoinRel;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.MergeJoinRel")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MergeJoinRel, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut common__ = None;
                let mut left__ = None;
                let mut right__ = None;
                let mut left_keys__ = None;
                let mut right_keys__ = None;
                let mut keys__ = None;
                let mut post_join_filter__ = None;
                let mut r#type__ = None;
                let mut advanced_extension__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Common => {
                            if common__.is_some() {
                                return Err(serde::de::Error::duplicate_field("common"));
                            }
                            common__ = map_.next_value()?;
                        }
                        GeneratedField::Left => {
                            if left__.is_some() {
                                return Err(serde::de::Error::duplicate_field("left"));
                            }
                            left__ = map_.next_value()?;
                        }
                        GeneratedField::Right => {
                            if right__.is_some() {
                                return Err(serde::de::Error::duplicate_field("right"));
                            }
                            right__ = map_.next_value()?;
                        }
                        GeneratedField::LeftKeys => {
                            if left_keys__.is_some() {
                                return Err(serde::de::Error::duplicate_field("leftKeys"));
                            }
                            left_keys__ = Some(map_.next_value()?);
                        }
                        GeneratedField::RightKeys => {
                            if right_keys__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rightKeys"));
                            }
                            right_keys__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Keys => {
                            if keys__.is_some() {
                                return Err(serde::de::Error::duplicate_field("keys"));
                            }
                            keys__ = Some(map_.next_value()?);
                        }
                        GeneratedField::PostJoinFilter => {
                            if post_join_filter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("postJoinFilter"));
                            }
                            post_join_filter__ = map_.next_value()?;
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<merge_join_rel::JoinType>()? as i32);
                        }
                        GeneratedField::AdvancedExtension => {
                            if advanced_extension__.is_some() {
                                return Err(serde::de::Error::duplicate_field("advancedExtension"));
                            }
                            advanced_extension__ = map_.next_value()?;
                        }
                    }
                }
                Ok(MergeJoinRel {
                    common: common__,
                    left: left__,
                    right: right__,
                    left_keys: left_keys__.unwrap_or_default(),
                    right_keys: right_keys__.unwrap_or_default(),
                    keys: keys__.unwrap_or_default(),
                    post_join_filter: post_join_filter__,
                    r#type: r#type__.unwrap_or_default(),
                    advanced_extension: advanced_extension__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.MergeJoinRel", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for merge_join_rel::JoinType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unspecified => "JOIN_TYPE_UNSPECIFIED",
            Self::Inner => "JOIN_TYPE_INNER",
            Self::Outer => "JOIN_TYPE_OUTER",
            Self::Left => "JOIN_TYPE_LEFT",
            Self::Right => "JOIN_TYPE_RIGHT",
            Self::LeftSemi => "JOIN_TYPE_LEFT_SEMI",
            Self::RightSemi => "JOIN_TYPE_RIGHT_SEMI",
            Self::LeftAnti => "JOIN_TYPE_LEFT_ANTI",
            Self::RightAnti => "JOIN_TYPE_RIGHT_ANTI",
            Self::LeftSingle => "JOIN_TYPE_LEFT_SINGLE",
            Self::RightSingle => "JOIN_TYPE_RIGHT_SINGLE",
            Self::LeftMark => "JOIN_TYPE_LEFT_MARK",
            Self::RightMark => "JOIN_TYPE_RIGHT_MARK",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for merge_join_rel::JoinType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "JOIN_TYPE_UNSPECIFIED",
            "JOIN_TYPE_INNER",
            "JOIN_TYPE_OUTER",
            "JOIN_TYPE_LEFT",
            "JOIN_TYPE_RIGHT",
            "JOIN_TYPE_LEFT_SEMI",
            "JOIN_TYPE_RIGHT_SEMI",
            "JOIN_TYPE_LEFT_ANTI",
            "JOIN_TYPE_RIGHT_ANTI",
            "JOIN_TYPE_LEFT_SINGLE",
            "JOIN_TYPE_RIGHT_SINGLE",
            "JOIN_TYPE_LEFT_MARK",
            "JOIN_TYPE_RIGHT_MARK",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = merge_join_rel::JoinType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "JOIN_TYPE_UNSPECIFIED" => Ok(merge_join_rel::JoinType::Unspecified),
                    "JOIN_TYPE_INNER" => Ok(merge_join_rel::JoinType::Inner),
                    "JOIN_TYPE_OUTER" => Ok(merge_join_rel::JoinType::Outer),
                    "JOIN_TYPE_LEFT" => Ok(merge_join_rel::JoinType::Left),
                    "JOIN_TYPE_RIGHT" => Ok(merge_join_rel::JoinType::Right),
                    "JOIN_TYPE_LEFT_SEMI" => Ok(merge_join_rel::JoinType::LeftSemi),
                    "JOIN_TYPE_RIGHT_SEMI" => Ok(merge_join_rel::JoinType::RightSemi),
                    "JOIN_TYPE_LEFT_ANTI" => Ok(merge_join_rel::JoinType::LeftAnti),
                    "JOIN_TYPE_RIGHT_ANTI" => Ok(merge_join_rel::JoinType::RightAnti),
                    "JOIN_TYPE_LEFT_SINGLE" => Ok(merge_join_rel::JoinType::LeftSingle),
                    "JOIN_TYPE_RIGHT_SINGLE" => Ok(merge_join_rel::JoinType::RightSingle),
                    "JOIN_TYPE_LEFT_MARK" => Ok(merge_join_rel::JoinType::LeftMark),
                    "JOIN_TYPE_RIGHT_MARK" => Ok(merge_join_rel::JoinType::RightMark),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for NamedObjectWrite {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.names.is_empty() {
            len += 1;
        }
        if self.advanced_extension.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.NamedObjectWrite", len)?;
        if !self.names.is_empty() {
            struct_ser.serialize_field("names", &self.names)?;
        }
        if let Some(v) = self.advanced_extension.as_ref() {
            struct_ser.serialize_field("advancedExtension", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NamedObjectWrite {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "names",
            "advanced_extension",
            "advancedExtension",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Names,
            AdvancedExtension,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "names" => Ok(GeneratedField::Names),
                            "advancedExtension" | "advanced_extension" => Ok(GeneratedField::AdvancedExtension),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NamedObjectWrite;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.NamedObjectWrite")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NamedObjectWrite, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut names__ = None;
                let mut advanced_extension__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Names => {
                            if names__.is_some() {
                                return Err(serde::de::Error::duplicate_field("names"));
                            }
                            names__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AdvancedExtension => {
                            if advanced_extension__.is_some() {
                                return Err(serde::de::Error::duplicate_field("advancedExtension"));
                            }
                            advanced_extension__ = map_.next_value()?;
                        }
                    }
                }
                Ok(NamedObjectWrite {
                    names: names__.unwrap_or_default(),
                    advanced_extension: advanced_extension__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.NamedObjectWrite", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NamedStruct {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.names.is_empty() {
            len += 1;
        }
        if self.r#struct.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.NamedStruct", len)?;
        if !self.names.is_empty() {
            struct_ser.serialize_field("names", &self.names)?;
        }
        if let Some(v) = self.r#struct.as_ref() {
            struct_ser.serialize_field("struct", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NamedStruct {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "names",
            "struct",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Names,
            Struct,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "names" => Ok(GeneratedField::Names),
                            "struct" => Ok(GeneratedField::Struct),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NamedStruct;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.NamedStruct")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NamedStruct, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut names__ = None;
                let mut r#struct__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Names => {
                            if names__.is_some() {
                                return Err(serde::de::Error::duplicate_field("names"));
                            }
                            names__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Struct => {
                            if r#struct__.is_some() {
                                return Err(serde::de::Error::duplicate_field("struct"));
                            }
                            r#struct__ = map_.next_value()?;
                        }
                    }
                }
                Ok(NamedStruct {
                    names: names__.unwrap_or_default(),
                    r#struct: r#struct__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.NamedStruct", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NamedTable {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.names.is_empty() {
            len += 1;
        }
        if self.advanced_extension.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.NamedTable", len)?;
        if !self.names.is_empty() {
            struct_ser.serialize_field("names", &self.names)?;
        }
        if let Some(v) = self.advanced_extension.as_ref() {
            struct_ser.serialize_field("advancedExtension", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NamedTable {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "names",
            "advanced_extension",
            "advancedExtension",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Names,
            AdvancedExtension,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "names" => Ok(GeneratedField::Names),
                            "advancedExtension" | "advanced_extension" => Ok(GeneratedField::AdvancedExtension),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NamedTable;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.NamedTable")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NamedTable, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut names__ = None;
                let mut advanced_extension__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Names => {
                            if names__.is_some() {
                                return Err(serde::de::Error::duplicate_field("names"));
                            }
                            names__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AdvancedExtension => {
                            if advanced_extension__.is_some() {
                                return Err(serde::de::Error::duplicate_field("advancedExtension"));
                            }
                            advanced_extension__ = map_.next_value()?;
                        }
                    }
                }
                Ok(NamedTable {
                    names: names__.unwrap_or_default(),
                    advanced_extension: advanced_extension__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.NamedTable", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NestedLoopJoinRel {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.common.is_some() {
            len += 1;
        }
        if self.left.is_some() {
            len += 1;
        }
        if self.right.is_some() {
            len += 1;
        }
        if self.expression.is_some() {
            len += 1;
        }
        if self.r#type != 0 {
            len += 1;
        }
        if self.advanced_extension.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.NestedLoopJoinRel", len)?;
        if let Some(v) = self.common.as_ref() {
            struct_ser.serialize_field("common", v)?;
        }
        if let Some(v) = self.left.as_ref() {
            struct_ser.serialize_field("left", v)?;
        }
        if let Some(v) = self.right.as_ref() {
            struct_ser.serialize_field("right", v)?;
        }
        if let Some(v) = self.expression.as_ref() {
            struct_ser.serialize_field("expression", v)?;
        }
        if self.r#type != 0 {
            let v = nested_loop_join_rel::JoinType::try_from(self.r#type)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
            struct_ser.serialize_field("type", &v)?;
        }
        if let Some(v) = self.advanced_extension.as_ref() {
            struct_ser.serialize_field("advancedExtension", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NestedLoopJoinRel {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "common",
            "left",
            "right",
            "expression",
            "type",
            "advanced_extension",
            "advancedExtension",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Common,
            Left,
            Right,
            Expression,
            Type,
            AdvancedExtension,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "common" => Ok(GeneratedField::Common),
                            "left" => Ok(GeneratedField::Left),
                            "right" => Ok(GeneratedField::Right),
                            "expression" => Ok(GeneratedField::Expression),
                            "type" => Ok(GeneratedField::Type),
                            "advancedExtension" | "advanced_extension" => Ok(GeneratedField::AdvancedExtension),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NestedLoopJoinRel;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.NestedLoopJoinRel")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NestedLoopJoinRel, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut common__ = None;
                let mut left__ = None;
                let mut right__ = None;
                let mut expression__ = None;
                let mut r#type__ = None;
                let mut advanced_extension__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Common => {
                            if common__.is_some() {
                                return Err(serde::de::Error::duplicate_field("common"));
                            }
                            common__ = map_.next_value()?;
                        }
                        GeneratedField::Left => {
                            if left__.is_some() {
                                return Err(serde::de::Error::duplicate_field("left"));
                            }
                            left__ = map_.next_value()?;
                        }
                        GeneratedField::Right => {
                            if right__.is_some() {
                                return Err(serde::de::Error::duplicate_field("right"));
                            }
                            right__ = map_.next_value()?;
                        }
                        GeneratedField::Expression => {
                            if expression__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expression"));
                            }
                            expression__ = map_.next_value()?;
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<nested_loop_join_rel::JoinType>()? as i32);
                        }
                        GeneratedField::AdvancedExtension => {
                            if advanced_extension__.is_some() {
                                return Err(serde::de::Error::duplicate_field("advancedExtension"));
                            }
                            advanced_extension__ = map_.next_value()?;
                        }
                    }
                }
                Ok(NestedLoopJoinRel {
                    common: common__,
                    left: left__,
                    right: right__,
                    expression: expression__,
                    r#type: r#type__.unwrap_or_default(),
                    advanced_extension: advanced_extension__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.NestedLoopJoinRel", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for nested_loop_join_rel::JoinType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unspecified => "JOIN_TYPE_UNSPECIFIED",
            Self::Inner => "JOIN_TYPE_INNER",
            Self::Outer => "JOIN_TYPE_OUTER",
            Self::Left => "JOIN_TYPE_LEFT",
            Self::Right => "JOIN_TYPE_RIGHT",
            Self::LeftSemi => "JOIN_TYPE_LEFT_SEMI",
            Self::RightSemi => "JOIN_TYPE_RIGHT_SEMI",
            Self::LeftAnti => "JOIN_TYPE_LEFT_ANTI",
            Self::RightAnti => "JOIN_TYPE_RIGHT_ANTI",
            Self::LeftSingle => "JOIN_TYPE_LEFT_SINGLE",
            Self::RightSingle => "JOIN_TYPE_RIGHT_SINGLE",
            Self::LeftMark => "JOIN_TYPE_LEFT_MARK",
            Self::RightMark => "JOIN_TYPE_RIGHT_MARK",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for nested_loop_join_rel::JoinType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "JOIN_TYPE_UNSPECIFIED",
            "JOIN_TYPE_INNER",
            "JOIN_TYPE_OUTER",
            "JOIN_TYPE_LEFT",
            "JOIN_TYPE_RIGHT",
            "JOIN_TYPE_LEFT_SEMI",
            "JOIN_TYPE_RIGHT_SEMI",
            "JOIN_TYPE_LEFT_ANTI",
            "JOIN_TYPE_RIGHT_ANTI",
            "JOIN_TYPE_LEFT_SINGLE",
            "JOIN_TYPE_RIGHT_SINGLE",
            "JOIN_TYPE_LEFT_MARK",
            "JOIN_TYPE_RIGHT_MARK",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = nested_loop_join_rel::JoinType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "JOIN_TYPE_UNSPECIFIED" => Ok(nested_loop_join_rel::JoinType::Unspecified),
                    "JOIN_TYPE_INNER" => Ok(nested_loop_join_rel::JoinType::Inner),
                    "JOIN_TYPE_OUTER" => Ok(nested_loop_join_rel::JoinType::Outer),
                    "JOIN_TYPE_LEFT" => Ok(nested_loop_join_rel::JoinType::Left),
                    "JOIN_TYPE_RIGHT" => Ok(nested_loop_join_rel::JoinType::Right),
                    "JOIN_TYPE_LEFT_SEMI" => Ok(nested_loop_join_rel::JoinType::LeftSemi),
                    "JOIN_TYPE_RIGHT_SEMI" => Ok(nested_loop_join_rel::JoinType::RightSemi),
                    "JOIN_TYPE_LEFT_ANTI" => Ok(nested_loop_join_rel::JoinType::LeftAnti),
                    "JOIN_TYPE_RIGHT_ANTI" => Ok(nested_loop_join_rel::JoinType::RightAnti),
                    "JOIN_TYPE_LEFT_SINGLE" => Ok(nested_loop_join_rel::JoinType::LeftSingle),
                    "JOIN_TYPE_RIGHT_SINGLE" => Ok(nested_loop_join_rel::JoinType::RightSingle),
                    "JOIN_TYPE_LEFT_MARK" => Ok(nested_loop_join_rel::JoinType::LeftMark),
                    "JOIN_TYPE_RIGHT_MARK" => Ok(nested_loop_join_rel::JoinType::RightMark),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ParameterizedType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.kind.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ParameterizedType", len)?;
        if let Some(v) = self.kind.as_ref() {
            match v {
                parameterized_type::Kind::Bool(v) => {
                    struct_ser.serialize_field("bool", v)?;
                }
                parameterized_type::Kind::I8(v) => {
                    struct_ser.serialize_field("i8", v)?;
                }
                parameterized_type::Kind::I16(v) => {
                    struct_ser.serialize_field("i16", v)?;
                }
                parameterized_type::Kind::I32(v) => {
                    struct_ser.serialize_field("i32", v)?;
                }
                parameterized_type::Kind::I64(v) => {
                    struct_ser.serialize_field("i64", v)?;
                }
                parameterized_type::Kind::Fp32(v) => {
                    struct_ser.serialize_field("fp32", v)?;
                }
                parameterized_type::Kind::Fp64(v) => {
                    struct_ser.serialize_field("fp64", v)?;
                }
                parameterized_type::Kind::String(v) => {
                    struct_ser.serialize_field("string", v)?;
                }
                parameterized_type::Kind::Binary(v) => {
                    struct_ser.serialize_field("binary", v)?;
                }
                parameterized_type::Kind::Timestamp(v) => {
                    struct_ser.serialize_field("timestamp", v)?;
                }
                parameterized_type::Kind::Date(v) => {
                    struct_ser.serialize_field("date", v)?;
                }
                parameterized_type::Kind::Time(v) => {
                    struct_ser.serialize_field("time", v)?;
                }
                parameterized_type::Kind::IntervalYear(v) => {
                    struct_ser.serialize_field("intervalYear", v)?;
                }
                parameterized_type::Kind::IntervalDay(v) => {
                    struct_ser.serialize_field("intervalDay", v)?;
                }
                parameterized_type::Kind::IntervalCompound(v) => {
                    struct_ser.serialize_field("intervalCompound", v)?;
                }
                parameterized_type::Kind::TimestampTz(v) => {
                    struct_ser.serialize_field("timestampTz", v)?;
                }
                parameterized_type::Kind::Uuid(v) => {
                    struct_ser.serialize_field("uuid", v)?;
                }
                parameterized_type::Kind::FixedChar(v) => {
                    struct_ser.serialize_field("fixedChar", v)?;
                }
                parameterized_type::Kind::Varchar(v) => {
                    struct_ser.serialize_field("varchar", v)?;
                }
                parameterized_type::Kind::FixedBinary(v) => {
                    struct_ser.serialize_field("fixedBinary", v)?;
                }
                parameterized_type::Kind::Decimal(v) => {
                    struct_ser.serialize_field("decimal", v)?;
                }
                parameterized_type::Kind::PrecisionTime(v) => {
                    struct_ser.serialize_field("precisionTime", v)?;
                }
                parameterized_type::Kind::PrecisionTimestamp(v) => {
                    struct_ser.serialize_field("precisionTimestamp", v)?;
                }
                parameterized_type::Kind::PrecisionTimestampTz(v) => {
                    struct_ser.serialize_field("precisionTimestampTz", v)?;
                }
                parameterized_type::Kind::Struct(v) => {
                    struct_ser.serialize_field("struct", v)?;
                }
                parameterized_type::Kind::List(v) => {
                    struct_ser.serialize_field("list", v)?;
                }
                parameterized_type::Kind::Map(v) => {
                    struct_ser.serialize_field("map", v)?;
                }
                parameterized_type::Kind::UserDefined(v) => {
                    struct_ser.serialize_field("userDefined", v)?;
                }
                parameterized_type::Kind::UserDefinedPointer(v) => {
                    struct_ser.serialize_field("userDefinedPointer", v)?;
                }
                parameterized_type::Kind::TypeParameter(v) => {
                    struct_ser.serialize_field("typeParameter", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ParameterizedType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "bool",
            "i8",
            "i16",
            "i32",
            "i64",
            "fp32",
            "fp64",
            "string",
            "binary",
            "timestamp",
            "date",
            "time",
            "interval_year",
            "intervalYear",
            "interval_day",
            "intervalDay",
            "interval_compound",
            "intervalCompound",
            "timestamp_tz",
            "timestampTz",
            "uuid",
            "fixed_char",
            "fixedChar",
            "varchar",
            "fixed_binary",
            "fixedBinary",
            "decimal",
            "precision_time",
            "precisionTime",
            "precision_timestamp",
            "precisionTimestamp",
            "precision_timestamp_tz",
            "precisionTimestampTz",
            "struct",
            "list",
            "map",
            "user_defined",
            "userDefined",
            "user_defined_pointer",
            "userDefinedPointer",
            "type_parameter",
            "typeParameter",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Bool,
            I8,
            I16,
            I32,
            I64,
            Fp32,
            Fp64,
            String,
            Binary,
            Timestamp,
            Date,
            Time,
            IntervalYear,
            IntervalDay,
            IntervalCompound,
            TimestampTz,
            Uuid,
            FixedChar,
            Varchar,
            FixedBinary,
            Decimal,
            PrecisionTime,
            PrecisionTimestamp,
            PrecisionTimestampTz,
            Struct,
            List,
            Map,
            UserDefined,
            UserDefinedPointer,
            TypeParameter,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "bool" => Ok(GeneratedField::Bool),
                            "i8" => Ok(GeneratedField::I8),
                            "i16" => Ok(GeneratedField::I16),
                            "i32" => Ok(GeneratedField::I32),
                            "i64" => Ok(GeneratedField::I64),
                            "fp32" => Ok(GeneratedField::Fp32),
                            "fp64" => Ok(GeneratedField::Fp64),
                            "string" => Ok(GeneratedField::String),
                            "binary" => Ok(GeneratedField::Binary),
                            "timestamp" => Ok(GeneratedField::Timestamp),
                            "date" => Ok(GeneratedField::Date),
                            "time" => Ok(GeneratedField::Time),
                            "intervalYear" | "interval_year" => Ok(GeneratedField::IntervalYear),
                            "intervalDay" | "interval_day" => Ok(GeneratedField::IntervalDay),
                            "intervalCompound" | "interval_compound" => Ok(GeneratedField::IntervalCompound),
                            "timestampTz" | "timestamp_tz" => Ok(GeneratedField::TimestampTz),
                            "uuid" => Ok(GeneratedField::Uuid),
                            "fixedChar" | "fixed_char" => Ok(GeneratedField::FixedChar),
                            "varchar" => Ok(GeneratedField::Varchar),
                            "fixedBinary" | "fixed_binary" => Ok(GeneratedField::FixedBinary),
                            "decimal" => Ok(GeneratedField::Decimal),
                            "precisionTime" | "precision_time" => Ok(GeneratedField::PrecisionTime),
                            "precisionTimestamp" | "precision_timestamp" => Ok(GeneratedField::PrecisionTimestamp),
                            "precisionTimestampTz" | "precision_timestamp_tz" => Ok(GeneratedField::PrecisionTimestampTz),
                            "struct" => Ok(GeneratedField::Struct),
                            "list" => Ok(GeneratedField::List),
                            "map" => Ok(GeneratedField::Map),
                            "userDefined" | "user_defined" => Ok(GeneratedField::UserDefined),
                            "userDefinedPointer" | "user_defined_pointer" => Ok(GeneratedField::UserDefinedPointer),
                            "typeParameter" | "type_parameter" => Ok(GeneratedField::TypeParameter),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ParameterizedType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ParameterizedType")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ParameterizedType, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut kind__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Bool => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bool"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(parameterized_type::Kind::Bool)
;
                        }
                        GeneratedField::I8 => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("i8"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(parameterized_type::Kind::I8)
;
                        }
                        GeneratedField::I16 => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("i16"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(parameterized_type::Kind::I16)
;
                        }
                        GeneratedField::I32 => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("i32"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(parameterized_type::Kind::I32)
;
                        }
                        GeneratedField::I64 => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("i64"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(parameterized_type::Kind::I64)
;
                        }
                        GeneratedField::Fp32 => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fp32"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(parameterized_type::Kind::Fp32)
;
                        }
                        GeneratedField::Fp64 => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fp64"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(parameterized_type::Kind::Fp64)
;
                        }
                        GeneratedField::String => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("string"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(parameterized_type::Kind::String)
;
                        }
                        GeneratedField::Binary => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("binary"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(parameterized_type::Kind::Binary)
;
                        }
                        GeneratedField::Timestamp => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestamp"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(parameterized_type::Kind::Timestamp)
;
                        }
                        GeneratedField::Date => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("date"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(parameterized_type::Kind::Date)
;
                        }
                        GeneratedField::Time => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("time"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(parameterized_type::Kind::Time)
;
                        }
                        GeneratedField::IntervalYear => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("intervalYear"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(parameterized_type::Kind::IntervalYear)
;
                        }
                        GeneratedField::IntervalDay => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("intervalDay"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(parameterized_type::Kind::IntervalDay)
;
                        }
                        GeneratedField::IntervalCompound => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("intervalCompound"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(parameterized_type::Kind::IntervalCompound)
;
                        }
                        GeneratedField::TimestampTz => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestampTz"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(parameterized_type::Kind::TimestampTz)
;
                        }
                        GeneratedField::Uuid => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("uuid"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(parameterized_type::Kind::Uuid)
;
                        }
                        GeneratedField::FixedChar => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fixedChar"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(parameterized_type::Kind::FixedChar)
;
                        }
                        GeneratedField::Varchar => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("varchar"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(parameterized_type::Kind::Varchar)
;
                        }
                        GeneratedField::FixedBinary => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fixedBinary"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(parameterized_type::Kind::FixedBinary)
;
                        }
                        GeneratedField::Decimal => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("decimal"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(parameterized_type::Kind::Decimal)
;
                        }
                        GeneratedField::PrecisionTime => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precisionTime"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(parameterized_type::Kind::PrecisionTime)
;
                        }
                        GeneratedField::PrecisionTimestamp => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precisionTimestamp"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(parameterized_type::Kind::PrecisionTimestamp)
;
                        }
                        GeneratedField::PrecisionTimestampTz => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precisionTimestampTz"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(parameterized_type::Kind::PrecisionTimestampTz)
;
                        }
                        GeneratedField::Struct => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("struct"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(parameterized_type::Kind::Struct)
;
                        }
                        GeneratedField::List => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(parameterized_type::Kind::List)
;
                        }
                        GeneratedField::Map => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("map"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(parameterized_type::Kind::Map)
;
                        }
                        GeneratedField::UserDefined => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("userDefined"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(parameterized_type::Kind::UserDefined)
;
                        }
                        GeneratedField::UserDefinedPointer => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("userDefinedPointer"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| parameterized_type::Kind::UserDefinedPointer(x.0));
                        }
                        GeneratedField::TypeParameter => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeParameter"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(parameterized_type::Kind::TypeParameter)
;
                        }
                    }
                }
                Ok(ParameterizedType {
                    kind: kind__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.ParameterizedType", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for parameterized_type::IntegerOption {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.integer_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ParameterizedType.IntegerOption", len)?;
        if let Some(v) = self.integer_type.as_ref() {
            match v {
                parameterized_type::integer_option::IntegerType::Literal(v) => {
                    struct_ser.serialize_field("literal", v)?;
                }
                parameterized_type::integer_option::IntegerType::Parameter(v) => {
                    struct_ser.serialize_field("parameter", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for parameterized_type::IntegerOption {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "literal",
            "parameter",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Literal,
            Parameter,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "literal" => Ok(GeneratedField::Literal),
                            "parameter" => Ok(GeneratedField::Parameter),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = parameterized_type::IntegerOption;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ParameterizedType.IntegerOption")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<parameterized_type::IntegerOption, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut integer_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Literal => {
                            if integer_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("literal"));
                            }
                            integer_type__ = map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| parameterized_type::integer_option::IntegerType::Literal(x.0));
                        }
                        GeneratedField::Parameter => {
                            if integer_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("parameter"));
                            }
                            integer_type__ = map_.next_value::<::std::option::Option<_>>()?.map(parameterized_type::integer_option::IntegerType::Parameter)
;
                        }
                    }
                }
                Ok(parameterized_type::IntegerOption {
                    integer_type: integer_type__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.ParameterizedType.IntegerOption", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for parameterized_type::IntegerParameter {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.name.is_empty() {
            len += 1;
        }
        if self.range_start_inclusive.is_some() {
            len += 1;
        }
        if self.range_end_exclusive.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ParameterizedType.IntegerParameter", len)?;
        if !self.name.is_empty() {
            struct_ser.serialize_field("name", &self.name)?;
        }
        if let Some(v) = self.range_start_inclusive.as_ref() {
            struct_ser.serialize_field("rangeStartInclusive", v)?;
        }
        if let Some(v) = self.range_end_exclusive.as_ref() {
            struct_ser.serialize_field("rangeEndExclusive", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for parameterized_type::IntegerParameter {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "range_start_inclusive",
            "rangeStartInclusive",
            "range_end_exclusive",
            "rangeEndExclusive",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            RangeStartInclusive,
            RangeEndExclusive,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "rangeStartInclusive" | "range_start_inclusive" => Ok(GeneratedField::RangeStartInclusive),
                            "rangeEndExclusive" | "range_end_exclusive" => Ok(GeneratedField::RangeEndExclusive),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = parameterized_type::IntegerParameter;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ParameterizedType.IntegerParameter")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<parameterized_type::IntegerParameter, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut range_start_inclusive__ = None;
                let mut range_end_exclusive__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::RangeStartInclusive => {
                            if range_start_inclusive__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rangeStartInclusive"));
                            }
                            range_start_inclusive__ = map_.next_value()?;
                        }
                        GeneratedField::RangeEndExclusive => {
                            if range_end_exclusive__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rangeEndExclusive"));
                            }
                            range_end_exclusive__ = map_.next_value()?;
                        }
                    }
                }
                Ok(parameterized_type::IntegerParameter {
                    name: name__.unwrap_or_default(),
                    range_start_inclusive: range_start_inclusive__,
                    range_end_exclusive: range_end_exclusive__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.ParameterizedType.IntegerParameter", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for parameterized_type::NullableInteger {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.value != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ParameterizedType.NullableInteger", len)?;
        if self.value != 0 {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("value", ToString::to_string(&self.value).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for parameterized_type::NullableInteger {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "value",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Value,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "value" => Ok(GeneratedField::Value),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = parameterized_type::NullableInteger;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ParameterizedType.NullableInteger")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<parameterized_type::NullableInteger, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut value__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(parameterized_type::NullableInteger {
                    value: value__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.ParameterizedType.NullableInteger", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for parameterized_type::ParameterizedDecimal {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.scale.is_some() {
            len += 1;
        }
        if self.precision.is_some() {
            len += 1;
        }
        if self.variation_pointer != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ParameterizedType.ParameterizedDecimal", len)?;
        if let Some(v) = self.scale.as_ref() {
            struct_ser.serialize_field("scale", v)?;
        }
        if let Some(v) = self.precision.as_ref() {
            struct_ser.serialize_field("precision", v)?;
        }
        if self.variation_pointer != 0 {
            struct_ser.serialize_field("variationPointer", &self.variation_pointer)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for parameterized_type::ParameterizedDecimal {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "scale",
            "precision",
            "variation_pointer",
            "variationPointer",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Scale,
            Precision,
            VariationPointer,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "scale" => Ok(GeneratedField::Scale),
                            "precision" => Ok(GeneratedField::Precision),
                            "variationPointer" | "variation_pointer" => Ok(GeneratedField::VariationPointer),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = parameterized_type::ParameterizedDecimal;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ParameterizedType.ParameterizedDecimal")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<parameterized_type::ParameterizedDecimal, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut scale__ = None;
                let mut precision__ = None;
                let mut variation_pointer__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Scale => {
                            if scale__.is_some() {
                                return Err(serde::de::Error::duplicate_field("scale"));
                            }
                            scale__ = map_.next_value()?;
                        }
                        GeneratedField::Precision => {
                            if precision__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precision"));
                            }
                            precision__ = map_.next_value()?;
                        }
                        GeneratedField::VariationPointer => {
                            if variation_pointer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("variationPointer"));
                            }
                            variation_pointer__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(parameterized_type::ParameterizedDecimal {
                    scale: scale__,
                    precision: precision__,
                    variation_pointer: variation_pointer__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.ParameterizedType.ParameterizedDecimal", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for parameterized_type::ParameterizedFixedBinary {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.length.is_some() {
            len += 1;
        }
        if self.variation_pointer != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ParameterizedType.ParameterizedFixedBinary", len)?;
        if let Some(v) = self.length.as_ref() {
            struct_ser.serialize_field("length", v)?;
        }
        if self.variation_pointer != 0 {
            struct_ser.serialize_field("variationPointer", &self.variation_pointer)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for parameterized_type::ParameterizedFixedBinary {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "length",
            "variation_pointer",
            "variationPointer",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Length,
            VariationPointer,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "length" => Ok(GeneratedField::Length),
                            "variationPointer" | "variation_pointer" => Ok(GeneratedField::VariationPointer),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = parameterized_type::ParameterizedFixedBinary;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ParameterizedType.ParameterizedFixedBinary")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<parameterized_type::ParameterizedFixedBinary, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut length__ = None;
                let mut variation_pointer__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Length => {
                            if length__.is_some() {
                                return Err(serde::de::Error::duplicate_field("length"));
                            }
                            length__ = map_.next_value()?;
                        }
                        GeneratedField::VariationPointer => {
                            if variation_pointer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("variationPointer"));
                            }
                            variation_pointer__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(parameterized_type::ParameterizedFixedBinary {
                    length: length__,
                    variation_pointer: variation_pointer__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.ParameterizedType.ParameterizedFixedBinary", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for parameterized_type::ParameterizedFixedChar {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.length.is_some() {
            len += 1;
        }
        if self.variation_pointer != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ParameterizedType.ParameterizedFixedChar", len)?;
        if let Some(v) = self.length.as_ref() {
            struct_ser.serialize_field("length", v)?;
        }
        if self.variation_pointer != 0 {
            struct_ser.serialize_field("variationPointer", &self.variation_pointer)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for parameterized_type::ParameterizedFixedChar {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "length",
            "variation_pointer",
            "variationPointer",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Length,
            VariationPointer,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "length" => Ok(GeneratedField::Length),
                            "variationPointer" | "variation_pointer" => Ok(GeneratedField::VariationPointer),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = parameterized_type::ParameterizedFixedChar;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ParameterizedType.ParameterizedFixedChar")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<parameterized_type::ParameterizedFixedChar, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut length__ = None;
                let mut variation_pointer__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Length => {
                            if length__.is_some() {
                                return Err(serde::de::Error::duplicate_field("length"));
                            }
                            length__ = map_.next_value()?;
                        }
                        GeneratedField::VariationPointer => {
                            if variation_pointer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("variationPointer"));
                            }
                            variation_pointer__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(parameterized_type::ParameterizedFixedChar {
                    length: length__,
                    variation_pointer: variation_pointer__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.ParameterizedType.ParameterizedFixedChar", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for parameterized_type::ParameterizedIntervalCompound {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.precision.is_some() {
            len += 1;
        }
        if self.variation_pointer != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ParameterizedType.ParameterizedIntervalCompound", len)?;
        if let Some(v) = self.precision.as_ref() {
            struct_ser.serialize_field("precision", v)?;
        }
        if self.variation_pointer != 0 {
            struct_ser.serialize_field("variationPointer", &self.variation_pointer)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for parameterized_type::ParameterizedIntervalCompound {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "precision",
            "variation_pointer",
            "variationPointer",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Precision,
            VariationPointer,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "precision" => Ok(GeneratedField::Precision),
                            "variationPointer" | "variation_pointer" => Ok(GeneratedField::VariationPointer),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = parameterized_type::ParameterizedIntervalCompound;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ParameterizedType.ParameterizedIntervalCompound")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<parameterized_type::ParameterizedIntervalCompound, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut precision__ = None;
                let mut variation_pointer__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Precision => {
                            if precision__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precision"));
                            }
                            precision__ = map_.next_value()?;
                        }
                        GeneratedField::VariationPointer => {
                            if variation_pointer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("variationPointer"));
                            }
                            variation_pointer__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(parameterized_type::ParameterizedIntervalCompound {
                    precision: precision__,
                    variation_pointer: variation_pointer__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.ParameterizedType.ParameterizedIntervalCompound", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for parameterized_type::ParameterizedIntervalDay {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.precision.is_some() {
            len += 1;
        }
        if self.variation_pointer != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ParameterizedType.ParameterizedIntervalDay", len)?;
        if let Some(v) = self.precision.as_ref() {
            struct_ser.serialize_field("precision", v)?;
        }
        if self.variation_pointer != 0 {
            struct_ser.serialize_field("variationPointer", &self.variation_pointer)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for parameterized_type::ParameterizedIntervalDay {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "precision",
            "variation_pointer",
            "variationPointer",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Precision,
            VariationPointer,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "precision" => Ok(GeneratedField::Precision),
                            "variationPointer" | "variation_pointer" => Ok(GeneratedField::VariationPointer),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = parameterized_type::ParameterizedIntervalDay;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ParameterizedType.ParameterizedIntervalDay")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<parameterized_type::ParameterizedIntervalDay, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut precision__ = None;
                let mut variation_pointer__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Precision => {
                            if precision__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precision"));
                            }
                            precision__ = map_.next_value()?;
                        }
                        GeneratedField::VariationPointer => {
                            if variation_pointer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("variationPointer"));
                            }
                            variation_pointer__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(parameterized_type::ParameterizedIntervalDay {
                    precision: precision__,
                    variation_pointer: variation_pointer__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.ParameterizedType.ParameterizedIntervalDay", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for parameterized_type::ParameterizedList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.r#type.is_some() {
            len += 1;
        }
        if self.variation_pointer != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ParameterizedType.ParameterizedList", len)?;
        if let Some(v) = self.r#type.as_ref() {
            struct_ser.serialize_field("type", v)?;
        }
        if self.variation_pointer != 0 {
            struct_ser.serialize_field("variationPointer", &self.variation_pointer)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for parameterized_type::ParameterizedList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "variation_pointer",
            "variationPointer",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            VariationPointer,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "variationPointer" | "variation_pointer" => Ok(GeneratedField::VariationPointer),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = parameterized_type::ParameterizedList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ParameterizedType.ParameterizedList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<parameterized_type::ParameterizedList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut variation_pointer__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = map_.next_value()?;
                        }
                        GeneratedField::VariationPointer => {
                            if variation_pointer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("variationPointer"));
                            }
                            variation_pointer__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(parameterized_type::ParameterizedList {
                    r#type: r#type__,
                    variation_pointer: variation_pointer__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.ParameterizedType.ParameterizedList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for parameterized_type::ParameterizedMap {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.key.is_some() {
            len += 1;
        }
        if self.value.is_some() {
            len += 1;
        }
        if self.variation_pointer != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ParameterizedType.ParameterizedMap", len)?;
        if let Some(v) = self.key.as_ref() {
            struct_ser.serialize_field("key", v)?;
        }
        if let Some(v) = self.value.as_ref() {
            struct_ser.serialize_field("value", v)?;
        }
        if self.variation_pointer != 0 {
            struct_ser.serialize_field("variationPointer", &self.variation_pointer)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for parameterized_type::ParameterizedMap {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "key",
            "value",
            "variation_pointer",
            "variationPointer",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Key,
            Value,
            VariationPointer,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "key" => Ok(GeneratedField::Key),
                            "value" => Ok(GeneratedField::Value),
                            "variationPointer" | "variation_pointer" => Ok(GeneratedField::VariationPointer),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = parameterized_type::ParameterizedMap;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ParameterizedType.ParameterizedMap")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<parameterized_type::ParameterizedMap, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut key__ = None;
                let mut value__ = None;
                let mut variation_pointer__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Key => {
                            if key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("key"));
                            }
                            key__ = map_.next_value()?;
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ = map_.next_value()?;
                        }
                        GeneratedField::VariationPointer => {
                            if variation_pointer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("variationPointer"));
                            }
                            variation_pointer__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(parameterized_type::ParameterizedMap {
                    key: key__,
                    value: value__,
                    variation_pointer: variation_pointer__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.ParameterizedType.ParameterizedMap", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for parameterized_type::ParameterizedNamedStruct {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.names.is_empty() {
            len += 1;
        }
        if self.r#struct.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ParameterizedType.ParameterizedNamedStruct", len)?;
        if !self.names.is_empty() {
            struct_ser.serialize_field("names", &self.names)?;
        }
        if let Some(v) = self.r#struct.as_ref() {
            struct_ser.serialize_field("struct", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for parameterized_type::ParameterizedNamedStruct {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "names",
            "struct",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Names,
            Struct,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "names" => Ok(GeneratedField::Names),
                            "struct" => Ok(GeneratedField::Struct),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = parameterized_type::ParameterizedNamedStruct;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ParameterizedType.ParameterizedNamedStruct")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<parameterized_type::ParameterizedNamedStruct, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut names__ = None;
                let mut r#struct__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Names => {
                            if names__.is_some() {
                                return Err(serde::de::Error::duplicate_field("names"));
                            }
                            names__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Struct => {
                            if r#struct__.is_some() {
                                return Err(serde::de::Error::duplicate_field("struct"));
                            }
                            r#struct__ = map_.next_value()?;
                        }
                    }
                }
                Ok(parameterized_type::ParameterizedNamedStruct {
                    names: names__.unwrap_or_default(),
                    r#struct: r#struct__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.ParameterizedType.ParameterizedNamedStruct", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for parameterized_type::ParameterizedPrecisionTime {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.precision.is_some() {
            len += 1;
        }
        if self.variation_pointer != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ParameterizedType.ParameterizedPrecisionTime", len)?;
        if let Some(v) = self.precision.as_ref() {
            struct_ser.serialize_field("precision", v)?;
        }
        if self.variation_pointer != 0 {
            struct_ser.serialize_field("variationPointer", &self.variation_pointer)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for parameterized_type::ParameterizedPrecisionTime {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "precision",
            "variation_pointer",
            "variationPointer",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Precision,
            VariationPointer,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "precision" => Ok(GeneratedField::Precision),
                            "variationPointer" | "variation_pointer" => Ok(GeneratedField::VariationPointer),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = parameterized_type::ParameterizedPrecisionTime;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ParameterizedType.ParameterizedPrecisionTime")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<parameterized_type::ParameterizedPrecisionTime, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut precision__ = None;
                let mut variation_pointer__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Precision => {
                            if precision__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precision"));
                            }
                            precision__ = map_.next_value()?;
                        }
                        GeneratedField::VariationPointer => {
                            if variation_pointer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("variationPointer"));
                            }
                            variation_pointer__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(parameterized_type::ParameterizedPrecisionTime {
                    precision: precision__,
                    variation_pointer: variation_pointer__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.ParameterizedType.ParameterizedPrecisionTime", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for parameterized_type::ParameterizedPrecisionTimestamp {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.precision.is_some() {
            len += 1;
        }
        if self.variation_pointer != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ParameterizedType.ParameterizedPrecisionTimestamp", len)?;
        if let Some(v) = self.precision.as_ref() {
            struct_ser.serialize_field("precision", v)?;
        }
        if self.variation_pointer != 0 {
            struct_ser.serialize_field("variationPointer", &self.variation_pointer)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for parameterized_type::ParameterizedPrecisionTimestamp {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "precision",
            "variation_pointer",
            "variationPointer",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Precision,
            VariationPointer,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "precision" => Ok(GeneratedField::Precision),
                            "variationPointer" | "variation_pointer" => Ok(GeneratedField::VariationPointer),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = parameterized_type::ParameterizedPrecisionTimestamp;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ParameterizedType.ParameterizedPrecisionTimestamp")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<parameterized_type::ParameterizedPrecisionTimestamp, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut precision__ = None;
                let mut variation_pointer__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Precision => {
                            if precision__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precision"));
                            }
                            precision__ = map_.next_value()?;
                        }
                        GeneratedField::VariationPointer => {
                            if variation_pointer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("variationPointer"));
                            }
                            variation_pointer__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(parameterized_type::ParameterizedPrecisionTimestamp {
                    precision: precision__,
                    variation_pointer: variation_pointer__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.ParameterizedType.ParameterizedPrecisionTimestamp", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for parameterized_type::ParameterizedPrecisionTimestampTz {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.precision.is_some() {
            len += 1;
        }
        if self.variation_pointer != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ParameterizedType.ParameterizedPrecisionTimestampTZ", len)?;
        if let Some(v) = self.precision.as_ref() {
            struct_ser.serialize_field("precision", v)?;
        }
        if self.variation_pointer != 0 {
            struct_ser.serialize_field("variationPointer", &self.variation_pointer)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for parameterized_type::ParameterizedPrecisionTimestampTz {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "precision",
            "variation_pointer",
            "variationPointer",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Precision,
            VariationPointer,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "precision" => Ok(GeneratedField::Precision),
                            "variationPointer" | "variation_pointer" => Ok(GeneratedField::VariationPointer),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = parameterized_type::ParameterizedPrecisionTimestampTz;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ParameterizedType.ParameterizedPrecisionTimestampTZ")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<parameterized_type::ParameterizedPrecisionTimestampTz, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut precision__ = None;
                let mut variation_pointer__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Precision => {
                            if precision__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precision"));
                            }
                            precision__ = map_.next_value()?;
                        }
                        GeneratedField::VariationPointer => {
                            if variation_pointer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("variationPointer"));
                            }
                            variation_pointer__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(parameterized_type::ParameterizedPrecisionTimestampTz {
                    precision: precision__,
                    variation_pointer: variation_pointer__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.ParameterizedType.ParameterizedPrecisionTimestampTZ", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for parameterized_type::ParameterizedStruct {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.types.is_empty() {
            len += 1;
        }
        if self.variation_pointer != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ParameterizedType.ParameterizedStruct", len)?;
        if !self.types.is_empty() {
            struct_ser.serialize_field("types", &self.types)?;
        }
        if self.variation_pointer != 0 {
            struct_ser.serialize_field("variationPointer", &self.variation_pointer)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for parameterized_type::ParameterizedStruct {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "types",
            "variation_pointer",
            "variationPointer",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Types,
            VariationPointer,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "types" => Ok(GeneratedField::Types),
                            "variationPointer" | "variation_pointer" => Ok(GeneratedField::VariationPointer),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = parameterized_type::ParameterizedStruct;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ParameterizedType.ParameterizedStruct")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<parameterized_type::ParameterizedStruct, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut types__ = None;
                let mut variation_pointer__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Types => {
                            if types__.is_some() {
                                return Err(serde::de::Error::duplicate_field("types"));
                            }
                            types__ = Some(map_.next_value()?);
                        }
                        GeneratedField::VariationPointer => {
                            if variation_pointer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("variationPointer"));
                            }
                            variation_pointer__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(parameterized_type::ParameterizedStruct {
                    types: types__.unwrap_or_default(),
                    variation_pointer: variation_pointer__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.ParameterizedType.ParameterizedStruct", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for parameterized_type::ParameterizedUserDefined {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.type_pointer != 0 {
            len += 1;
        }
        if self.variation_pointer != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ParameterizedType.ParameterizedUserDefined", len)?;
        if self.type_pointer != 0 {
            struct_ser.serialize_field("typePointer", &self.type_pointer)?;
        }
        if self.variation_pointer != 0 {
            struct_ser.serialize_field("variationPointer", &self.variation_pointer)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for parameterized_type::ParameterizedUserDefined {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type_pointer",
            "typePointer",
            "variation_pointer",
            "variationPointer",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TypePointer,
            VariationPointer,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "typePointer" | "type_pointer" => Ok(GeneratedField::TypePointer),
                            "variationPointer" | "variation_pointer" => Ok(GeneratedField::VariationPointer),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = parameterized_type::ParameterizedUserDefined;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ParameterizedType.ParameterizedUserDefined")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<parameterized_type::ParameterizedUserDefined, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut type_pointer__ = None;
                let mut variation_pointer__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TypePointer => {
                            if type_pointer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typePointer"));
                            }
                            type_pointer__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::VariationPointer => {
                            if variation_pointer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("variationPointer"));
                            }
                            variation_pointer__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(parameterized_type::ParameterizedUserDefined {
                    type_pointer: type_pointer__.unwrap_or_default(),
                    variation_pointer: variation_pointer__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.ParameterizedType.ParameterizedUserDefined", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for parameterized_type::ParameterizedVarChar {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.length.is_some() {
            len += 1;
        }
        if self.variation_pointer != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ParameterizedType.ParameterizedVarChar", len)?;
        if let Some(v) = self.length.as_ref() {
            struct_ser.serialize_field("length", v)?;
        }
        if self.variation_pointer != 0 {
            struct_ser.serialize_field("variationPointer", &self.variation_pointer)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for parameterized_type::ParameterizedVarChar {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "length",
            "variation_pointer",
            "variationPointer",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Length,
            VariationPointer,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "length" => Ok(GeneratedField::Length),
                            "variationPointer" | "variation_pointer" => Ok(GeneratedField::VariationPointer),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = parameterized_type::ParameterizedVarChar;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ParameterizedType.ParameterizedVarChar")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<parameterized_type::ParameterizedVarChar, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut length__ = None;
                let mut variation_pointer__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Length => {
                            if length__.is_some() {
                                return Err(serde::de::Error::duplicate_field("length"));
                            }
                            length__ = map_.next_value()?;
                        }
                        GeneratedField::VariationPointer => {
                            if variation_pointer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("variationPointer"));
                            }
                            variation_pointer__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(parameterized_type::ParameterizedVarChar {
                    length: length__,
                    variation_pointer: variation_pointer__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.ParameterizedType.ParameterizedVarChar", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for parameterized_type::TypeParameter {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.name.is_empty() {
            len += 1;
        }
        if !self.bounds.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ParameterizedType.TypeParameter", len)?;
        if !self.name.is_empty() {
            struct_ser.serialize_field("name", &self.name)?;
        }
        if !self.bounds.is_empty() {
            struct_ser.serialize_field("bounds", &self.bounds)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for parameterized_type::TypeParameter {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "bounds",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Bounds,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "bounds" => Ok(GeneratedField::Bounds),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = parameterized_type::TypeParameter;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ParameterizedType.TypeParameter")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<parameterized_type::TypeParameter, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut bounds__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Bounds => {
                            if bounds__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bounds"));
                            }
                            bounds__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(parameterized_type::TypeParameter {
                    name: name__.unwrap_or_default(),
                    bounds: bounds__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.ParameterizedType.TypeParameter", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Plan {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.version.is_some() {
            len += 1;
        }
        if !self.extension_uris.is_empty() {
            len += 1;
        }
        if !self.extension_urns.is_empty() {
            len += 1;
        }
        if !self.extensions.is_empty() {
            len += 1;
        }
        if !self.relations.is_empty() {
            len += 1;
        }
        if self.advanced_extensions.is_some() {
            len += 1;
        }
        if !self.expected_type_urls.is_empty() {
            len += 1;
        }
        if !self.parameter_bindings.is_empty() {
            len += 1;
        }
        if !self.type_aliases.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Plan", len)?;
        if let Some(v) = self.version.as_ref() {
            struct_ser.serialize_field("version", v)?;
        }
        if !self.extension_uris.is_empty() {
            struct_ser.serialize_field("extensionUris", &self.extension_uris)?;
        }
        if !self.extension_urns.is_empty() {
            struct_ser.serialize_field("extensionUrns", &self.extension_urns)?;
        }
        if !self.extensions.is_empty() {
            struct_ser.serialize_field("extensions", &self.extensions)?;
        }
        if !self.relations.is_empty() {
            struct_ser.serialize_field("relations", &self.relations)?;
        }
        if let Some(v) = self.advanced_extensions.as_ref() {
            struct_ser.serialize_field("advancedExtensions", v)?;
        }
        if !self.expected_type_urls.is_empty() {
            struct_ser.serialize_field("expectedTypeUrls", &self.expected_type_urls)?;
        }
        if !self.parameter_bindings.is_empty() {
            struct_ser.serialize_field("parameterBindings", &self.parameter_bindings)?;
        }
        if !self.type_aliases.is_empty() {
            struct_ser.serialize_field("typeAliases", &self.type_aliases)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Plan {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "version",
            "extension_uris",
            "extensionUris",
            "extension_urns",
            "extensionUrns",
            "extensions",
            "relations",
            "advanced_extensions",
            "advancedExtensions",
            "expected_type_urls",
            "expectedTypeUrls",
            "parameter_bindings",
            "parameterBindings",
            "type_aliases",
            "typeAliases",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Version,
            ExtensionUris,
            ExtensionUrns,
            Extensions,
            Relations,
            AdvancedExtensions,
            ExpectedTypeUrls,
            ParameterBindings,
            TypeAliases,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "version" => Ok(GeneratedField::Version),
                            "extensionUris" | "extension_uris" => Ok(GeneratedField::ExtensionUris),
                            "extensionUrns" | "extension_urns" => Ok(GeneratedField::ExtensionUrns),
                            "extensions" => Ok(GeneratedField::Extensions),
                            "relations" => Ok(GeneratedField::Relations),
                            "advancedExtensions" | "advanced_extensions" => Ok(GeneratedField::AdvancedExtensions),
                            "expectedTypeUrls" | "expected_type_urls" => Ok(GeneratedField::ExpectedTypeUrls),
                            "parameterBindings" | "parameter_bindings" => Ok(GeneratedField::ParameterBindings),
                            "typeAliases" | "type_aliases" => Ok(GeneratedField::TypeAliases),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Plan;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Plan")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Plan, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut version__ = None;
                let mut extension_uris__ = None;
                let mut extension_urns__ = None;
                let mut extensions__ = None;
                let mut relations__ = None;
                let mut advanced_extensions__ = None;
                let mut expected_type_urls__ = None;
                let mut parameter_bindings__ = None;
                let mut type_aliases__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Version => {
                            if version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("version"));
                            }
                            version__ = map_.next_value()?;
                        }
                        GeneratedField::ExtensionUris => {
                            if extension_uris__.is_some() {
                                return Err(serde::de::Error::duplicate_field("extensionUris"));
                            }
                            extension_uris__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ExtensionUrns => {
                            if extension_urns__.is_some() {
                                return Err(serde::de::Error::duplicate_field("extensionUrns"));
                            }
                            extension_urns__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Extensions => {
                            if extensions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("extensions"));
                            }
                            extensions__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Relations => {
                            if relations__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relations"));
                            }
                            relations__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AdvancedExtensions => {
                            if advanced_extensions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("advancedExtensions"));
                            }
                            advanced_extensions__ = map_.next_value()?;
                        }
                        GeneratedField::ExpectedTypeUrls => {
                            if expected_type_urls__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expectedTypeUrls"));
                            }
                            expected_type_urls__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ParameterBindings => {
                            if parameter_bindings__.is_some() {
                                return Err(serde::de::Error::duplicate_field("parameterBindings"));
                            }
                            parameter_bindings__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TypeAliases => {
                            if type_aliases__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeAliases"));
                            }
                            type_aliases__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(Plan {
                    version: version__,
                    extension_uris: extension_uris__.unwrap_or_default(),
                    extension_urns: extension_urns__.unwrap_or_default(),
                    extensions: extensions__.unwrap_or_default(),
                    relations: relations__.unwrap_or_default(),
                    advanced_extensions: advanced_extensions__,
                    expected_type_urls: expected_type_urls__.unwrap_or_default(),
                    parameter_bindings: parameter_bindings__.unwrap_or_default(),
                    type_aliases: type_aliases__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Plan", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PlanRel {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.rel_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.PlanRel", len)?;
        if let Some(v) = self.rel_type.as_ref() {
            match v {
                plan_rel::RelType::Rel(v) => {
                    struct_ser.serialize_field("rel", v)?;
                }
                plan_rel::RelType::Root(v) => {
                    struct_ser.serialize_field("root", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PlanRel {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "rel",
            "root",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Rel,
            Root,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "rel" => Ok(GeneratedField::Rel),
                            "root" => Ok(GeneratedField::Root),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PlanRel;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.PlanRel")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PlanRel, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut rel_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Rel => {
                            if rel_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rel"));
                            }
                            rel_type__ = map_.next_value::<::std::option::Option<_>>()?.map(plan_rel::RelType::Rel)
;
                        }
                        GeneratedField::Root => {
                            if rel_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("root"));
                            }
                            rel_type__ = map_.next_value::<::std::option::Option<_>>()?.map(plan_rel::RelType::Root)
;
                        }
                    }
                }
                Ok(PlanRel {
                    rel_type: rel_type__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.PlanRel", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PlanVersion {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.version.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.PlanVersion", len)?;
        if let Some(v) = self.version.as_ref() {
            struct_ser.serialize_field("version", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PlanVersion {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "version",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Version,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "version" => Ok(GeneratedField::Version),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PlanVersion;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.PlanVersion")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PlanVersion, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut version__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Version => {
                            if version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("version"));
                            }
                            version__ = map_.next_value()?;
                        }
                    }
                }
                Ok(PlanVersion {
                    version: version__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.PlanVersion", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ProjectRel {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.common.is_some() {
            len += 1;
        }
        if self.input.is_some() {
            len += 1;
        }
        if !self.expressions.is_empty() {
            len += 1;
        }
        if self.advanced_extension.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ProjectRel", len)?;
        if let Some(v) = self.common.as_ref() {
            struct_ser.serialize_field("common", v)?;
        }
        if let Some(v) = self.input.as_ref() {
            struct_ser.serialize_field("input", v)?;
        }
        if !self.expressions.is_empty() {
            struct_ser.serialize_field("expressions", &self.expressions)?;
        }
        if let Some(v) = self.advanced_extension.as_ref() {
            struct_ser.serialize_field("advancedExtension", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ProjectRel {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "common",
            "input",
            "expressions",
            "advanced_extension",
            "advancedExtension",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Common,
            Input,
            Expressions,
            AdvancedExtension,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "common" => Ok(GeneratedField::Common),
                            "input" => Ok(GeneratedField::Input),
                            "expressions" => Ok(GeneratedField::Expressions),
                            "advancedExtension" | "advanced_extension" => Ok(GeneratedField::AdvancedExtension),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ProjectRel;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ProjectRel")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ProjectRel, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut common__ = None;
                let mut input__ = None;
                let mut expressions__ = None;
                let mut advanced_extension__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Common => {
                            if common__.is_some() {
                                return Err(serde::de::Error::duplicate_field("common"));
                            }
                            common__ = map_.next_value()?;
                        }
                        GeneratedField::Input => {
                            if input__.is_some() {
                                return Err(serde::de::Error::duplicate_field("input"));
                            }
                            input__ = map_.next_value()?;
                        }
                        GeneratedField::Expressions => {
                            if expressions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expressions"));
                            }
                            expressions__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AdvancedExtension => {
                            if advanced_extension__.is_some() {
                                return Err(serde::de::Error::duplicate_field("advancedExtension"));
                            }
                            advanced_extension__ = map_.next_value()?;
                        }
                    }
                }
                Ok(ProjectRel {
                    common: common__,
                    input: input__,
                    expressions: expressions__.unwrap_or_default(),
                    advanced_extension: advanced_extension__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.ProjectRel", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ReadRel {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.common.is_some() {
            len += 1;
        }
        if self.base_schema.is_some() {
            len += 1;
        }
        if self.filter.is_some() {
            len += 1;
        }
        if self.best_effort_filter.is_some() {
            len += 1;
        }
        if self.projection.is_some() {
            len += 1;
        }
        if self.advanced_extension.is_some() {
            len += 1;
        }
        if self.read_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ReadRel", len)?;
        if let Some(v) = self.common.as_ref() {
            struct_ser.serialize_field("common", v)?;
        }
        if let Some(v) = self.base_schema.as_ref() {
            struct_ser.serialize_field("baseSchema", v)?;
        }
        if let Some(v) = self.filter.as_ref() {
            struct_ser.serialize_field("filter", v)?;
        }
        if let Some(v) = self.best_effort_filter.as_ref() {
            struct_ser.serialize_field("bestEffortFilter", v)?;
        }
        if let Some(v) = self.projection.as_ref() {
            struct_ser.serialize_field("projection", v)?;
        }
        if let Some(v) = self.advanced_extension.as_ref() {
            struct_ser.serialize_field("advancedExtension", v)?;
        }
        if let Some(v) = self.read_type.as_ref() {
            match v {
                read_rel::ReadType::VirtualTable(v) => {
                    struct_ser.serialize_field("virtualTable", v)?;
                }
                read_rel::ReadType::LocalFiles(v) => {
                    struct_ser.serialize_field("localFiles", v)?;
                }
                read_rel::ReadType::NamedTable(v) => {
                    struct_ser.serialize_field("namedTable", v)?;
                }
                read_rel::ReadType::ExtensionTable(v) => {
                    struct_ser.serialize_field("extensionTable", v)?;
                }
                read_rel::ReadType::IcebergTable(v) => {
                    struct_ser.serialize_field("icebergTable", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ReadRel {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "common",
            "base_schema",
            "baseSchema",
            "filter",
            "best_effort_filter",
            "bestEffortFilter",
            "projection",
            "advanced_extension",
            "advancedExtension",
            "virtual_table",
            "virtualTable",
            "local_files",
            "localFiles",
            "named_table",
            "namedTable",
            "extension_table",
            "extensionTable",
            "iceberg_table",
            "icebergTable",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Common,
            BaseSchema,
            Filter,
            BestEffortFilter,
            Projection,
            AdvancedExtension,
            VirtualTable,
            LocalFiles,
            NamedTable,
            ExtensionTable,
            IcebergTable,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "common" => Ok(GeneratedField::Common),
                            "baseSchema" | "base_schema" => Ok(GeneratedField::BaseSchema),
                            "filter" => Ok(GeneratedField::Filter),
                            "bestEffortFilter" | "best_effort_filter" => Ok(GeneratedField::BestEffortFilter),
                            "projection" => Ok(GeneratedField::Projection),
                            "advancedExtension" | "advanced_extension" => Ok(GeneratedField::AdvancedExtension),
                            "virtualTable" | "virtual_table" => Ok(GeneratedField::VirtualTable),
                            "localFiles" | "local_files" => Ok(GeneratedField::LocalFiles),
                            "namedTable" | "named_table" => Ok(GeneratedField::NamedTable),
                            "extensionTable" | "extension_table" => Ok(GeneratedField::ExtensionTable),
                            "icebergTable" | "iceberg_table" => Ok(GeneratedField::IcebergTable),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ReadRel;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ReadRel")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ReadRel, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut common__ = None;
                let mut base_schema__ = None;
                let mut filter__ = None;
                let mut best_effort_filter__ = None;
                let mut projection__ = None;
                let mut advanced_extension__ = None;
                let mut read_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Common => {
                            if common__.is_some() {
                                return Err(serde::de::Error::duplicate_field("common"));
                            }
                            common__ = map_.next_value()?;
                        }
                        GeneratedField::BaseSchema => {
                            if base_schema__.is_some() {
                                return Err(serde::de::Error::duplicate_field("baseSchema"));
                            }
                            base_schema__ = map_.next_value()?;
                        }
                        GeneratedField::Filter => {
                            if filter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("filter"));
                            }
                            filter__ = map_.next_value()?;
                        }
                        GeneratedField::BestEffortFilter => {
                            if best_effort_filter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bestEffortFilter"));
                            }
                            best_effort_filter__ = map_.next_value()?;
                        }
                        GeneratedField::Projection => {
                            if projection__.is_some() {
                                return Err(serde::de::Error::duplicate_field("projection"));
                            }
                            projection__ = map_.next_value()?;
                        }
                        GeneratedField::AdvancedExtension => {
                            if advanced_extension__.is_some() {
                                return Err(serde::de::Error::duplicate_field("advancedExtension"));
                            }
                            advanced_extension__ = map_.next_value()?;
                        }
                        GeneratedField::VirtualTable => {
                            if read_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("virtualTable"));
                            }
                            read_type__ = map_.next_value::<::std::option::Option<_>>()?.map(read_rel::ReadType::VirtualTable)
;
                        }
                        GeneratedField::LocalFiles => {
                            if read_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("localFiles"));
                            }
                            read_type__ = map_.next_value::<::std::option::Option<_>>()?.map(read_rel::ReadType::LocalFiles)
;
                        }
                        GeneratedField::NamedTable => {
                            if read_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("namedTable"));
                            }
                            read_type__ = map_.next_value::<::std::option::Option<_>>()?.map(read_rel::ReadType::NamedTable)
;
                        }
                        GeneratedField::ExtensionTable => {
                            if read_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("extensionTable"));
                            }
                            read_type__ = map_.next_value::<::std::option::Option<_>>()?.map(read_rel::ReadType::ExtensionTable)
;
                        }
                        GeneratedField::IcebergTable => {
                            if read_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("icebergTable"));
                            }
                            read_type__ = map_.next_value::<::std::option::Option<_>>()?.map(read_rel::ReadType::IcebergTable)
;
                        }
                    }
                }
                Ok(ReadRel {
                    common: common__,
                    base_schema: base_schema__,
                    filter: filter__,
                    best_effort_filter: best_effort_filter__,
                    projection: projection__,
                    advanced_extension: advanced_extension__,
                    read_type: read_type__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.ReadRel", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for read_rel::ExtensionTable {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.detail.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ReadRel.ExtensionTable", len)?;
        if let Some(v) = self.detail.as_ref() {
            struct_ser.serialize_field("detail", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for read_rel::ExtensionTable {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "detail",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Detail,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "detail" => Ok(GeneratedField::Detail),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = read_rel::ExtensionTable;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ReadRel.ExtensionTable")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<read_rel::ExtensionTable, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut detail__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Detail => {
                            if detail__.is_some() {
                                return Err(serde::de::Error::duplicate_field("detail"));
                            }
                            detail__ = map_.next_value()?;
                        }
                    }
                }
                Ok(read_rel::ExtensionTable {
                    detail: detail__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.ReadRel.ExtensionTable", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for read_rel::IcebergTable {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.table_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ReadRel.IcebergTable", len)?;
        if let Some(v) = self.table_type.as_ref() {
            match v {
                read_rel::iceberg_table::TableType::Direct(v) => {
                    struct_ser.serialize_field("direct", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for read_rel::IcebergTable {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "direct",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Direct,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "direct" => Ok(GeneratedField::Direct),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = read_rel::IcebergTable;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ReadRel.IcebergTable")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<read_rel::IcebergTable, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut table_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Direct => {
                            if table_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("direct"));
                            }
                            table_type__ = map_.next_value::<::std::option::Option<_>>()?.map(read_rel::iceberg_table::TableType::Direct)
;
                        }
                    }
                }
                Ok(read_rel::IcebergTable {
                    table_type: table_type__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.ReadRel.IcebergTable", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for read_rel::iceberg_table::MetadataFileRead {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.metadata_uri.is_empty() {
            len += 1;
        }
        if self.snapshot.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ReadRel.IcebergTable.MetadataFileRead", len)?;
        if !self.metadata_uri.is_empty() {
            struct_ser.serialize_field("metadataUri", &self.metadata_uri)?;
        }
        if let Some(v) = self.snapshot.as_ref() {
            match v {
                read_rel::iceberg_table::metadata_file_read::Snapshot::SnapshotId(v) => {
                    struct_ser.serialize_field("snapshotId", v)?;
                }
                read_rel::iceberg_table::metadata_file_read::Snapshot::SnapshotTimestamp(v) => {
                    #[allow(clippy::needless_borrow)]
                    #[allow(clippy::needless_borrows_for_generic_args)]
                    struct_ser.serialize_field("snapshotTimestamp", ToString::to_string(&v).as_str())?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for read_rel::iceberg_table::MetadataFileRead {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata_uri",
            "metadataUri",
            "snapshot_id",
            "snapshotId",
            "snapshot_timestamp",
            "snapshotTimestamp",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MetadataUri,
            SnapshotId,
            SnapshotTimestamp,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadataUri" | "metadata_uri" => Ok(GeneratedField::MetadataUri),
                            "snapshotId" | "snapshot_id" => Ok(GeneratedField::SnapshotId),
                            "snapshotTimestamp" | "snapshot_timestamp" => Ok(GeneratedField::SnapshotTimestamp),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = read_rel::iceberg_table::MetadataFileRead;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ReadRel.IcebergTable.MetadataFileRead")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<read_rel::iceberg_table::MetadataFileRead, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata_uri__ = None;
                let mut snapshot__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MetadataUri => {
                            if metadata_uri__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadataUri"));
                            }
                            metadata_uri__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SnapshotId => {
                            if snapshot__.is_some() {
                                return Err(serde::de::Error::duplicate_field("snapshotId"));
                            }
                            snapshot__ = map_.next_value::<::std::option::Option<_>>()?.map(read_rel::iceberg_table::metadata_file_read::Snapshot::SnapshotId);
                        }
                        GeneratedField::SnapshotTimestamp => {
                            if snapshot__.is_some() {
                                return Err(serde::de::Error::duplicate_field("snapshotTimestamp"));
                            }
                            snapshot__ = map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| read_rel::iceberg_table::metadata_file_read::Snapshot::SnapshotTimestamp(x.0));
                        }
                    }
                }
                Ok(read_rel::iceberg_table::MetadataFileRead {
                    metadata_uri: metadata_uri__.unwrap_or_default(),
                    snapshot: snapshot__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.ReadRel.IcebergTable.MetadataFileRead", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for read_rel::LocalFiles {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.items.is_empty() {
            len += 1;
        }
        if self.advanced_extension.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ReadRel.LocalFiles", len)?;
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        if let Some(v) = self.advanced_extension.as_ref() {
            struct_ser.serialize_field("advancedExtension", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for read_rel::LocalFiles {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "items",
            "advanced_extension",
            "advancedExtension",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Items,
            AdvancedExtension,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "items" => Ok(GeneratedField::Items),
                            "advancedExtension" | "advanced_extension" => Ok(GeneratedField::AdvancedExtension),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = read_rel::LocalFiles;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ReadRel.LocalFiles")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<read_rel::LocalFiles, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut items__ = None;
                let mut advanced_extension__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AdvancedExtension => {
                            if advanced_extension__.is_some() {
                                return Err(serde::de::Error::duplicate_field("advancedExtension"));
                            }
                            advanced_extension__ = map_.next_value()?;
                        }
                    }
                }
                Ok(read_rel::LocalFiles {
                    items: items__.unwrap_or_default(),
                    advanced_extension: advanced_extension__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.ReadRel.LocalFiles", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for read_rel::local_files::FileOrFiles {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.partition_index != 0 {
            len += 1;
        }
        if self.start != 0 {
            len += 1;
        }
        if self.length != 0 {
            len += 1;
        }
        if self.path_type.is_some() {
            len += 1;
        }
        if self.file_format.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ReadRel.LocalFiles.FileOrFiles", len)?;
        if self.partition_index != 0 {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("partitionIndex", ToString::to_string(&self.partition_index).as_str())?;
        }
        if self.start != 0 {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("start", ToString::to_string(&self.start).as_str())?;
        }
        if self.length != 0 {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("length", ToString::to_string(&self.length).as_str())?;
        }
        if let Some(v) = self.path_type.as_ref() {
            match v {
                read_rel::local_files::file_or_files::PathType::UriPath(v) => {
                    struct_ser.serialize_field("uriPath", v)?;
                }
                read_rel::local_files::file_or_files::PathType::UriPathGlob(v) => {
                    struct_ser.serialize_field("uriPathGlob", v)?;
                }
                read_rel::local_files::file_or_files::PathType::UriFile(v) => {
                    struct_ser.serialize_field("uriFile", v)?;
                }
                read_rel::local_files::file_or_files::PathType::UriFolder(v) => {
                    struct_ser.serialize_field("uriFolder", v)?;
                }
            }
        }
        if let Some(v) = self.file_format.as_ref() {
            match v {
                read_rel::local_files::file_or_files::FileFormat::Parquet(v) => {
                    struct_ser.serialize_field("parquet", v)?;
                }
                read_rel::local_files::file_or_files::FileFormat::Arrow(v) => {
                    struct_ser.serialize_field("arrow", v)?;
                }
                read_rel::local_files::file_or_files::FileFormat::Orc(v) => {
                    struct_ser.serialize_field("orc", v)?;
                }
                read_rel::local_files::file_or_files::FileFormat::Extension(v) => {
                    struct_ser.serialize_field("extension", v)?;
                }
                read_rel::local_files::file_or_files::FileFormat::Dwrf(v) => {
                    struct_ser.serialize_field("dwrf", v)?;
                }
                read_rel::local_files::file_or_files::FileFormat::Text(v) => {
                    struct_ser.serialize_field("text", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for read_rel::local_files::FileOrFiles {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "partition_index",
            "partitionIndex",
            "start",
            "length",
            "uri_path",
            "uriPath",
            "uri_path_glob",
            "uriPathGlob",
            "uri_file",
            "uriFile",
            "uri_folder",
            "uriFolder",
            "parquet",
            "arrow",
            "orc",
            "extension",
            "dwrf",
            "text",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PartitionIndex,
            Start,
            Length,
            UriPath,
            UriPathGlob,
            UriFile,
            UriFolder,
            Parquet,
            Arrow,
            Orc,
            Extension,
            Dwrf,
            Text,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "partitionIndex" | "partition_index" => Ok(GeneratedField::PartitionIndex),
                            "start" => Ok(GeneratedField::Start),
                            "length" => Ok(GeneratedField::Length),
                            "uriPath" | "uri_path" => Ok(GeneratedField::UriPath),
                            "uriPathGlob" | "uri_path_glob" => Ok(GeneratedField::UriPathGlob),
                            "uriFile" | "uri_file" => Ok(GeneratedField::UriFile),
                            "uriFolder" | "uri_folder" => Ok(GeneratedField::UriFolder),
                            "parquet" => Ok(GeneratedField::Parquet),
                            "arrow" => Ok(GeneratedField::Arrow),
                            "orc" => Ok(GeneratedField::Orc),
                            "extension" => Ok(GeneratedField::Extension),
                            "dwrf" => Ok(GeneratedField::Dwrf),
                            "text" => Ok(GeneratedField::Text),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = read_rel::local_files::FileOrFiles;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ReadRel.LocalFiles.FileOrFiles")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<read_rel::local_files::FileOrFiles, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut partition_index__ = None;
                let mut start__ = None;
                let mut length__ = None;
                let mut path_type__ = None;
                let mut file_format__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PartitionIndex => {
                            if partition_index__.is_some() {
                                return Err(serde::de::Error::duplicate_field("partitionIndex"));
                            }
                            partition_index__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Start => {
                            if start__.is_some() {
                                return Err(serde::de::Error::duplicate_field("start"));
                            }
                            start__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Length => {
                            if length__.is_some() {
                                return Err(serde::de::Error::duplicate_field("length"));
                            }
                            length__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::UriPath => {
                            if path_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("uriPath"));
                            }
                            path_type__ = map_.next_value::<::std::option::Option<_>>()?.map(read_rel::local_files::file_or_files::PathType::UriPath);
                        }
                        GeneratedField::UriPathGlob => {
                            if path_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("uriPathGlob"));
                            }
                            path_type__ = map_.next_value::<::std::option::Option<_>>()?.map(read_rel::local_files::file_or_files::PathType::UriPathGlob);
                        }
                        GeneratedField::UriFile => {
                            if path_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("uriFile"));
                            }
                            path_type__ = map_.next_value::<::std::option::Option<_>>()?.map(read_rel::local_files::file_or_files::PathType::UriFile);
                        }
                        GeneratedField::UriFolder => {
                            if path_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("uriFolder"));
                            }
                            path_type__ = map_.next_value::<::std::option::Option<_>>()?.map(read_rel::local_files::file_or_files::PathType::UriFolder);
                        }
                        GeneratedField::Parquet => {
                            if file_format__.is_some() {
                                return Err(serde::de::Error::duplicate_field("parquet"));
                            }
                            file_format__ = map_.next_value::<::std::option::Option<_>>()?.map(read_rel::local_files::file_or_files::FileFormat::Parquet)
;
                        }
                        GeneratedField::Arrow => {
                            if file_format__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arrow"));
                            }
                            file_format__ = map_.next_value::<::std::option::Option<_>>()?.map(read_rel::local_files::file_or_files::FileFormat::Arrow)
;
                        }
                        GeneratedField::Orc => {
                            if file_format__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orc"));
                            }
                            file_format__ = map_.next_value::<::std::option::Option<_>>()?.map(read_rel::local_files::file_or_files::FileFormat::Orc)
;
                        }
                        GeneratedField::Extension => {
                            if file_format__.is_some() {
                                return Err(serde::de::Error::duplicate_field("extension"));
                            }
                            file_format__ = map_.next_value::<::std::option::Option<_>>()?.map(read_rel::local_files::file_or_files::FileFormat::Extension)
;
                        }
                        GeneratedField::Dwrf => {
                            if file_format__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dwrf"));
                            }
                            file_format__ = map_.next_value::<::std::option::Option<_>>()?.map(read_rel::local_files::file_or_files::FileFormat::Dwrf)
;
                        }
                        GeneratedField::Text => {
                            if file_format__.is_some() {
                                return Err(serde::de::Error::duplicate_field("text"));
                            }
                            file_format__ = map_.next_value::<::std::option::Option<_>>()?.map(read_rel::local_files::file_or_files::FileFormat::Text)
;
                        }
                    }
                }
                Ok(read_rel::local_files::FileOrFiles {
                    partition_index: partition_index__.unwrap_or_default(),
                    start: start__.unwrap_or_default(),
                    length: length__.unwrap_or_default(),
                    path_type: path_type__,
                    file_format: file_format__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.ReadRel.LocalFiles.FileOrFiles", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for read_rel::local_files::file_or_files::ArrowReadOptions {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("substrait.ReadRel.LocalFiles.FileOrFiles.ArrowReadOptions", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for read_rel::local_files::file_or_files::ArrowReadOptions {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = read_rel::local_files::file_or_files::ArrowReadOptions;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ReadRel.LocalFiles.FileOrFiles.ArrowReadOptions")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<read_rel::local_files::file_or_files::ArrowReadOptions, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(read_rel::local_files::file_or_files::ArrowReadOptions {
                })
            }
        }
        deserializer.deserialize_struct("substrait.ReadRel.LocalFiles.FileOrFiles.ArrowReadOptions", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for read_rel::local_files::file_or_files::DelimiterSeparatedTextReadOptions {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.field_delimiter.is_empty() {
            len += 1;
        }
        if self.max_line_size != 0 {
            len += 1;
        }
        if !self.quote.is_empty() {
            len += 1;
        }
        if self.header_lines_to_skip != 0 {
            len += 1;
        }
        if !self.escape.is_empty() {
            len += 1;
        }
        if self.value_treated_as_null.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ReadRel.LocalFiles.FileOrFiles.DelimiterSeparatedTextReadOptions", len)?;
        if !self.field_delimiter.is_empty() {
            struct_ser.serialize_field("fieldDelimiter", &self.field_delimiter)?;
        }
        if self.max_line_size != 0 {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("maxLineSize", ToString::to_string(&self.max_line_size).as_str())?;
        }
        if !self.quote.is_empty() {
            struct_ser.serialize_field("quote", &self.quote)?;
        }
        if self.header_lines_to_skip != 0 {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("headerLinesToSkip", ToString::to_string(&self.header_lines_to_skip).as_str())?;
        }
        if !self.escape.is_empty() {
            struct_ser.serialize_field("escape", &self.escape)?;
        }
        if let Some(v) = self.value_treated_as_null.as_ref() {
            struct_ser.serialize_field("valueTreatedAsNull", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for read_rel::local_files::file_or_files::DelimiterSeparatedTextReadOptions {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "field_delimiter",
            "fieldDelimiter",
            "max_line_size",
            "maxLineSize",
            "quote",
            "header_lines_to_skip",
            "headerLinesToSkip",
            "escape",
            "value_treated_as_null",
            "valueTreatedAsNull",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            FieldDelimiter,
            MaxLineSize,
            Quote,
            HeaderLinesToSkip,
            Escape,
            ValueTreatedAsNull,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "fieldDelimiter" | "field_delimiter" => Ok(GeneratedField::FieldDelimiter),
                            "maxLineSize" | "max_line_size" => Ok(GeneratedField::MaxLineSize),
                            "quote" => Ok(GeneratedField::Quote),
                            "headerLinesToSkip" | "header_lines_to_skip" => Ok(GeneratedField::HeaderLinesToSkip),
                            "escape" => Ok(GeneratedField::Escape),
                            "valueTreatedAsNull" | "value_treated_as_null" => Ok(GeneratedField::ValueTreatedAsNull),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = read_rel::local_files::file_or_files::DelimiterSeparatedTextReadOptions;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ReadRel.LocalFiles.FileOrFiles.DelimiterSeparatedTextReadOptions")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<read_rel::local_files::file_or_files::DelimiterSeparatedTextReadOptions, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut field_delimiter__ = None;
                let mut max_line_size__ = None;
                let mut quote__ = None;
                let mut header_lines_to_skip__ = None;
                let mut escape__ = None;
                let mut value_treated_as_null__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::FieldDelimiter => {
                            if field_delimiter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fieldDelimiter"));
                            }
                            field_delimiter__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MaxLineSize => {
                            if max_line_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("maxLineSize"));
                            }
                            max_line_size__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Quote => {
                            if quote__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quote"));
                            }
                            quote__ = Some(map_.next_value()?);
                        }
                        GeneratedField::HeaderLinesToSkip => {
                            if header_lines_to_skip__.is_some() {
                                return Err(serde::de::Error::duplicate_field("headerLinesToSkip"));
                            }
                            header_lines_to_skip__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Escape => {
                            if escape__.is_some() {
                                return Err(serde::de::Error::duplicate_field("escape"));
                            }
                            escape__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ValueTreatedAsNull => {
                            if value_treated_as_null__.is_some() {
                                return Err(serde::de::Error::duplicate_field("valueTreatedAsNull"));
                            }
                            value_treated_as_null__ = map_.next_value()?;
                        }
                    }
                }
                Ok(read_rel::local_files::file_or_files::DelimiterSeparatedTextReadOptions {
                    field_delimiter: field_delimiter__.unwrap_or_default(),
                    max_line_size: max_line_size__.unwrap_or_default(),
                    quote: quote__.unwrap_or_default(),
                    header_lines_to_skip: header_lines_to_skip__.unwrap_or_default(),
                    escape: escape__.unwrap_or_default(),
                    value_treated_as_null: value_treated_as_null__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.ReadRel.LocalFiles.FileOrFiles.DelimiterSeparatedTextReadOptions", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for read_rel::local_files::file_or_files::DwrfReadOptions {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("substrait.ReadRel.LocalFiles.FileOrFiles.DwrfReadOptions", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for read_rel::local_files::file_or_files::DwrfReadOptions {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = read_rel::local_files::file_or_files::DwrfReadOptions;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ReadRel.LocalFiles.FileOrFiles.DwrfReadOptions")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<read_rel::local_files::file_or_files::DwrfReadOptions, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(read_rel::local_files::file_or_files::DwrfReadOptions {
                })
            }
        }
        deserializer.deserialize_struct("substrait.ReadRel.LocalFiles.FileOrFiles.DwrfReadOptions", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for read_rel::local_files::file_or_files::OrcReadOptions {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("substrait.ReadRel.LocalFiles.FileOrFiles.OrcReadOptions", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for read_rel::local_files::file_or_files::OrcReadOptions {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = read_rel::local_files::file_or_files::OrcReadOptions;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ReadRel.LocalFiles.FileOrFiles.OrcReadOptions")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<read_rel::local_files::file_or_files::OrcReadOptions, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(read_rel::local_files::file_or_files::OrcReadOptions {
                })
            }
        }
        deserializer.deserialize_struct("substrait.ReadRel.LocalFiles.FileOrFiles.OrcReadOptions", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for read_rel::local_files::file_or_files::ParquetReadOptions {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("substrait.ReadRel.LocalFiles.FileOrFiles.ParquetReadOptions", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for read_rel::local_files::file_or_files::ParquetReadOptions {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = read_rel::local_files::file_or_files::ParquetReadOptions;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ReadRel.LocalFiles.FileOrFiles.ParquetReadOptions")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<read_rel::local_files::file_or_files::ParquetReadOptions, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(read_rel::local_files::file_or_files::ParquetReadOptions {
                })
            }
        }
        deserializer.deserialize_struct("substrait.ReadRel.LocalFiles.FileOrFiles.ParquetReadOptions", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for read_rel::NamedTable {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.names.is_empty() {
            len += 1;
        }
        if self.advanced_extension.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ReadRel.NamedTable", len)?;
        if !self.names.is_empty() {
            struct_ser.serialize_field("names", &self.names)?;
        }
        if let Some(v) = self.advanced_extension.as_ref() {
            struct_ser.serialize_field("advancedExtension", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for read_rel::NamedTable {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "names",
            "advanced_extension",
            "advancedExtension",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Names,
            AdvancedExtension,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "names" => Ok(GeneratedField::Names),
                            "advancedExtension" | "advanced_extension" => Ok(GeneratedField::AdvancedExtension),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = read_rel::NamedTable;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ReadRel.NamedTable")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<read_rel::NamedTable, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut names__ = None;
                let mut advanced_extension__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Names => {
                            if names__.is_some() {
                                return Err(serde::de::Error::duplicate_field("names"));
                            }
                            names__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AdvancedExtension => {
                            if advanced_extension__.is_some() {
                                return Err(serde::de::Error::duplicate_field("advancedExtension"));
                            }
                            advanced_extension__ = map_.next_value()?;
                        }
                    }
                }
                Ok(read_rel::NamedTable {
                    names: names__.unwrap_or_default(),
                    advanced_extension: advanced_extension__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.ReadRel.NamedTable", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for read_rel::VirtualTable {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.values.is_empty() {
            len += 1;
        }
        if !self.expressions.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ReadRel.VirtualTable", len)?;
        if !self.values.is_empty() {
            struct_ser.serialize_field("values", &self.values)?;
        }
        if !self.expressions.is_empty() {
            struct_ser.serialize_field("expressions", &self.expressions)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for read_rel::VirtualTable {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "values",
            "expressions",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Values,
            Expressions,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "values" => Ok(GeneratedField::Values),
                            "expressions" => Ok(GeneratedField::Expressions),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = read_rel::VirtualTable;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ReadRel.VirtualTable")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<read_rel::VirtualTable, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut values__ = None;
                let mut expressions__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Values => {
                            if values__.is_some() {
                                return Err(serde::de::Error::duplicate_field("values"));
                            }
                            values__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Expressions => {
                            if expressions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expressions"));
                            }
                            expressions__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(read_rel::VirtualTable {
                    values: values__.unwrap_or_default(),
                    expressions: expressions__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.ReadRel.VirtualTable", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ReferenceRel {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.subtree_ordinal != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.ReferenceRel", len)?;
        if self.subtree_ordinal != 0 {
            struct_ser.serialize_field("subtreeOrdinal", &self.subtree_ordinal)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ReferenceRel {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "subtree_ordinal",
            "subtreeOrdinal",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SubtreeOrdinal,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "subtreeOrdinal" | "subtree_ordinal" => Ok(GeneratedField::SubtreeOrdinal),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ReferenceRel;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.ReferenceRel")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ReferenceRel, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut subtree_ordinal__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SubtreeOrdinal => {
                            if subtree_ordinal__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subtreeOrdinal"));
                            }
                            subtree_ordinal__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(ReferenceRel {
                    subtree_ordinal: subtree_ordinal__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.ReferenceRel", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Rel {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.rel_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Rel", len)?;
        if let Some(v) = self.rel_type.as_ref() {
            match v {
                rel::RelType::Read(v) => {
                    struct_ser.serialize_field("read", v)?;
                }
                rel::RelType::Filter(v) => {
                    struct_ser.serialize_field("filter", v)?;
                }
                rel::RelType::Fetch(v) => {
                    struct_ser.serialize_field("fetch", v)?;
                }
                rel::RelType::Aggregate(v) => {
                    struct_ser.serialize_field("aggregate", v)?;
                }
                rel::RelType::Sort(v) => {
                    struct_ser.serialize_field("sort", v)?;
                }
                rel::RelType::Join(v) => {
                    struct_ser.serialize_field("join", v)?;
                }
                rel::RelType::Project(v) => {
                    struct_ser.serialize_field("project", v)?;
                }
                rel::RelType::Set(v) => {
                    struct_ser.serialize_field("set", v)?;
                }
                rel::RelType::ExtensionSingle(v) => {
                    struct_ser.serialize_field("extensionSingle", v)?;
                }
                rel::RelType::ExtensionMulti(v) => {
                    struct_ser.serialize_field("extensionMulti", v)?;
                }
                rel::RelType::ExtensionLeaf(v) => {
                    struct_ser.serialize_field("extensionLeaf", v)?;
                }
                rel::RelType::Cross(v) => {
                    struct_ser.serialize_field("cross", v)?;
                }
                rel::RelType::Reference(v) => {
                    struct_ser.serialize_field("reference", v)?;
                }
                rel::RelType::Write(v) => {
                    struct_ser.serialize_field("write", v)?;
                }
                rel::RelType::Ddl(v) => {
                    struct_ser.serialize_field("ddl", v)?;
                }
                rel::RelType::Update(v) => {
                    struct_ser.serialize_field("update", v)?;
                }
                rel::RelType::HashJoin(v) => {
                    struct_ser.serialize_field("hashJoin", v)?;
                }
                rel::RelType::MergeJoin(v) => {
                    struct_ser.serialize_field("mergeJoin", v)?;
                }
                rel::RelType::NestedLoopJoin(v) => {
                    struct_ser.serialize_field("nestedLoopJoin", v)?;
                }
                rel::RelType::Window(v) => {
                    struct_ser.serialize_field("window", v)?;
                }
                rel::RelType::Exchange(v) => {
                    struct_ser.serialize_field("exchange", v)?;
                }
                rel::RelType::Expand(v) => {
                    struct_ser.serialize_field("expand", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Rel {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "read",
            "filter",
            "fetch",
            "aggregate",
            "sort",
            "join",
            "project",
            "set",
            "extension_single",
            "extensionSingle",
            "extension_multi",
            "extensionMulti",
            "extension_leaf",
            "extensionLeaf",
            "cross",
            "reference",
            "write",
            "ddl",
            "update",
            "hash_join",
            "hashJoin",
            "merge_join",
            "mergeJoin",
            "nested_loop_join",
            "nestedLoopJoin",
            "window",
            "exchange",
            "expand",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Read,
            Filter,
            Fetch,
            Aggregate,
            Sort,
            Join,
            Project,
            Set,
            ExtensionSingle,
            ExtensionMulti,
            ExtensionLeaf,
            Cross,
            Reference,
            Write,
            Ddl,
            Update,
            HashJoin,
            MergeJoin,
            NestedLoopJoin,
            Window,
            Exchange,
            Expand,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "read" => Ok(GeneratedField::Read),
                            "filter" => Ok(GeneratedField::Filter),
                            "fetch" => Ok(GeneratedField::Fetch),
                            "aggregate" => Ok(GeneratedField::Aggregate),
                            "sort" => Ok(GeneratedField::Sort),
                            "join" => Ok(GeneratedField::Join),
                            "project" => Ok(GeneratedField::Project),
                            "set" => Ok(GeneratedField::Set),
                            "extensionSingle" | "extension_single" => Ok(GeneratedField::ExtensionSingle),
                            "extensionMulti" | "extension_multi" => Ok(GeneratedField::ExtensionMulti),
                            "extensionLeaf" | "extension_leaf" => Ok(GeneratedField::ExtensionLeaf),
                            "cross" => Ok(GeneratedField::Cross),
                            "reference" => Ok(GeneratedField::Reference),
                            "write" => Ok(GeneratedField::Write),
                            "ddl" => Ok(GeneratedField::Ddl),
                            "update" => Ok(GeneratedField::Update),
                            "hashJoin" | "hash_join" => Ok(GeneratedField::HashJoin),
                            "mergeJoin" | "merge_join" => Ok(GeneratedField::MergeJoin),
                            "nestedLoopJoin" | "nested_loop_join" => Ok(GeneratedField::NestedLoopJoin),
                            "window" => Ok(GeneratedField::Window),
                            "exchange" => Ok(GeneratedField::Exchange),
                            "expand" => Ok(GeneratedField::Expand),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Rel;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Rel")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Rel, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut rel_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Read => {
                            if rel_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("read"));
                            }
                            rel_type__ = map_.next_value::<::std::option::Option<_>>()?.map(rel::RelType::Read)
;
                        }
                        GeneratedField::Filter => {
                            if rel_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("filter"));
                            }
                            rel_type__ = map_.next_value::<::std::option::Option<_>>()?.map(rel::RelType::Filter)
;
                        }
                        GeneratedField::Fetch => {
                            if rel_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fetch"));
                            }
                            rel_type__ = map_.next_value::<::std::option::Option<_>>()?.map(rel::RelType::Fetch)
;
                        }
                        GeneratedField::Aggregate => {
                            if rel_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aggregate"));
                            }
                            rel_type__ = map_.next_value::<::std::option::Option<_>>()?.map(rel::RelType::Aggregate)
;
                        }
                        GeneratedField::Sort => {
                            if rel_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sort"));
                            }
                            rel_type__ = map_.next_value::<::std::option::Option<_>>()?.map(rel::RelType::Sort)
;
                        }
                        GeneratedField::Join => {
                            if rel_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("join"));
                            }
                            rel_type__ = map_.next_value::<::std::option::Option<_>>()?.map(rel::RelType::Join)
;
                        }
                        GeneratedField::Project => {
                            if rel_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("project"));
                            }
                            rel_type__ = map_.next_value::<::std::option::Option<_>>()?.map(rel::RelType::Project)
;
                        }
                        GeneratedField::Set => {
                            if rel_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("set"));
                            }
                            rel_type__ = map_.next_value::<::std::option::Option<_>>()?.map(rel::RelType::Set)
;
                        }
                        GeneratedField::ExtensionSingle => {
                            if rel_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("extensionSingle"));
                            }
                            rel_type__ = map_.next_value::<::std::option::Option<_>>()?.map(rel::RelType::ExtensionSingle)
;
                        }
                        GeneratedField::ExtensionMulti => {
                            if rel_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("extensionMulti"));
                            }
                            rel_type__ = map_.next_value::<::std::option::Option<_>>()?.map(rel::RelType::ExtensionMulti)
;
                        }
                        GeneratedField::ExtensionLeaf => {
                            if rel_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("extensionLeaf"));
                            }
                            rel_type__ = map_.next_value::<::std::option::Option<_>>()?.map(rel::RelType::ExtensionLeaf)
;
                        }
                        GeneratedField::Cross => {
                            if rel_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cross"));
                            }
                            rel_type__ = map_.next_value::<::std::option::Option<_>>()?.map(rel::RelType::Cross)
;
                        }
                        GeneratedField::Reference => {
                            if rel_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reference"));
                            }
                            rel_type__ = map_.next_value::<::std::option::Option<_>>()?.map(rel::RelType::Reference)
;
                        }
                        GeneratedField::Write => {
                            if rel_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("write"));
                            }
                            rel_type__ = map_.next_value::<::std::option::Option<_>>()?.map(rel::RelType::Write)
;
                        }
                        GeneratedField::Ddl => {
                            if rel_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ddl"));
                            }
                            rel_type__ = map_.next_value::<::std::option::Option<_>>()?.map(rel::RelType::Ddl)
;
                        }
                        GeneratedField::Update => {
                            if rel_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("update"));
                            }
                            rel_type__ = map_.next_value::<::std::option::Option<_>>()?.map(rel::RelType::Update)
;
                        }
                        GeneratedField::HashJoin => {
                            if rel_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hashJoin"));
                            }
                            rel_type__ = map_.next_value::<::std::option::Option<_>>()?.map(rel::RelType::HashJoin)
;
                        }
                        GeneratedField::MergeJoin => {
                            if rel_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mergeJoin"));
                            }
                            rel_type__ = map_.next_value::<::std::option::Option<_>>()?.map(rel::RelType::MergeJoin)
;
                        }
                        GeneratedField::NestedLoopJoin => {
                            if rel_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nestedLoopJoin"));
                            }
                            rel_type__ = map_.next_value::<::std::option::Option<_>>()?.map(rel::RelType::NestedLoopJoin)
;
                        }
                        GeneratedField::Window => {
                            if rel_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("window"));
                            }
                            rel_type__ = map_.next_value::<::std::option::Option<_>>()?.map(rel::RelType::Window)
;
                        }
                        GeneratedField::Exchange => {
                            if rel_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("exchange"));
                            }
                            rel_type__ = map_.next_value::<::std::option::Option<_>>()?.map(rel::RelType::Exchange)
;
                        }
                        GeneratedField::Expand => {
                            if rel_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expand"));
                            }
                            rel_type__ = map_.next_value::<::std::option::Option<_>>()?.map(rel::RelType::Expand)
;
                        }
                    }
                }
                Ok(Rel {
                    rel_type: rel_type__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Rel", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RelCommon {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.hint.is_some() {
            len += 1;
        }
        if self.advanced_extension.is_some() {
            len += 1;
        }
        if self.emit_kind.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.RelCommon", len)?;
        if let Some(v) = self.hint.as_ref() {
            struct_ser.serialize_field("hint", v)?;
        }
        if let Some(v) = self.advanced_extension.as_ref() {
            struct_ser.serialize_field("advancedExtension", v)?;
        }
        if let Some(v) = self.emit_kind.as_ref() {
            match v {
                rel_common::EmitKind::Direct(v) => {
                    struct_ser.serialize_field("direct", v)?;
                }
                rel_common::EmitKind::Emit(v) => {
                    struct_ser.serialize_field("emit", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RelCommon {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "hint",
            "advanced_extension",
            "advancedExtension",
            "direct",
            "emit",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Hint,
            AdvancedExtension,
            Direct,
            Emit,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "hint" => Ok(GeneratedField::Hint),
                            "advancedExtension" | "advanced_extension" => Ok(GeneratedField::AdvancedExtension),
                            "direct" => Ok(GeneratedField::Direct),
                            "emit" => Ok(GeneratedField::Emit),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RelCommon;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.RelCommon")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RelCommon, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut hint__ = None;
                let mut advanced_extension__ = None;
                let mut emit_kind__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Hint => {
                            if hint__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hint"));
                            }
                            hint__ = map_.next_value()?;
                        }
                        GeneratedField::AdvancedExtension => {
                            if advanced_extension__.is_some() {
                                return Err(serde::de::Error::duplicate_field("advancedExtension"));
                            }
                            advanced_extension__ = map_.next_value()?;
                        }
                        GeneratedField::Direct => {
                            if emit_kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("direct"));
                            }
                            emit_kind__ = map_.next_value::<::std::option::Option<_>>()?.map(rel_common::EmitKind::Direct)
;
                        }
                        GeneratedField::Emit => {
                            if emit_kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("emit"));
                            }
                            emit_kind__ = map_.next_value::<::std::option::Option<_>>()?.map(rel_common::EmitKind::Emit)
;
                        }
                    }
                }
                Ok(RelCommon {
                    hint: hint__,
                    advanced_extension: advanced_extension__,
                    emit_kind: emit_kind__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.RelCommon", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for rel_common::Direct {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("substrait.RelCommon.Direct", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for rel_common::Direct {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = rel_common::Direct;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.RelCommon.Direct")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<rel_common::Direct, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(rel_common::Direct {
                })
            }
        }
        deserializer.deserialize_struct("substrait.RelCommon.Direct", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for rel_common::Emit {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.output_mapping.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.RelCommon.Emit", len)?;
        if !self.output_mapping.is_empty() {
            struct_ser.serialize_field("outputMapping", &self.output_mapping)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for rel_common::Emit {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "output_mapping",
            "outputMapping",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            OutputMapping,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "outputMapping" | "output_mapping" => Ok(GeneratedField::OutputMapping),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = rel_common::Emit;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.RelCommon.Emit")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<rel_common::Emit, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut output_mapping__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::OutputMapping => {
                            if output_mapping__.is_some() {
                                return Err(serde::de::Error::duplicate_field("outputMapping"));
                            }
                            output_mapping__ =
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(rel_common::Emit {
                    output_mapping: output_mapping__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.RelCommon.Emit", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for rel_common::Hint {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.stats.is_some() {
            len += 1;
        }
        if self.constraint.is_some() {
            len += 1;
        }
        if !self.alias.is_empty() {
            len += 1;
        }
        if !self.output_names.is_empty() {
            len += 1;
        }
        if self.advanced_extension.is_some() {
            len += 1;
        }
        if !self.saved_computations.is_empty() {
            len += 1;
        }
        if !self.loaded_computations.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.RelCommon.Hint", len)?;
        if let Some(v) = self.stats.as_ref() {
            struct_ser.serialize_field("stats", v)?;
        }
        if let Some(v) = self.constraint.as_ref() {
            struct_ser.serialize_field("constraint", v)?;
        }
        if !self.alias.is_empty() {
            struct_ser.serialize_field("alias", &self.alias)?;
        }
        if !self.output_names.is_empty() {
            struct_ser.serialize_field("outputNames", &self.output_names)?;
        }
        if let Some(v) = self.advanced_extension.as_ref() {
            struct_ser.serialize_field("advancedExtension", v)?;
        }
        if !self.saved_computations.is_empty() {
            struct_ser.serialize_field("savedComputations", &self.saved_computations)?;
        }
        if !self.loaded_computations.is_empty() {
            struct_ser.serialize_field("loadedComputations", &self.loaded_computations)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for rel_common::Hint {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "stats",
            "constraint",
            "alias",
            "output_names",
            "outputNames",
            "advanced_extension",
            "advancedExtension",
            "saved_computations",
            "savedComputations",
            "loaded_computations",
            "loadedComputations",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Stats,
            Constraint,
            Alias,
            OutputNames,
            AdvancedExtension,
            SavedComputations,
            LoadedComputations,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "stats" => Ok(GeneratedField::Stats),
                            "constraint" => Ok(GeneratedField::Constraint),
                            "alias" => Ok(GeneratedField::Alias),
                            "outputNames" | "output_names" => Ok(GeneratedField::OutputNames),
                            "advancedExtension" | "advanced_extension" => Ok(GeneratedField::AdvancedExtension),
                            "savedComputations" | "saved_computations" => Ok(GeneratedField::SavedComputations),
                            "loadedComputations" | "loaded_computations" => Ok(GeneratedField::LoadedComputations),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = rel_common::Hint;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.RelCommon.Hint")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<rel_common::Hint, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut stats__ = None;
                let mut constraint__ = None;
                let mut alias__ = None;
                let mut output_names__ = None;
                let mut advanced_extension__ = None;
                let mut saved_computations__ = None;
                let mut loaded_computations__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Stats => {
                            if stats__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stats"));
                            }
                            stats__ = map_.next_value()?;
                        }
                        GeneratedField::Constraint => {
                            if constraint__.is_some() {
                                return Err(serde::de::Error::duplicate_field("constraint"));
                            }
                            constraint__ = map_.next_value()?;
                        }
                        GeneratedField::Alias => {
                            if alias__.is_some() {
                                return Err(serde::de::Error::duplicate_field("alias"));
                            }
                            alias__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OutputNames => {
                            if output_names__.is_some() {
                                return Err(serde::de::Error::duplicate_field("outputNames"));
                            }
                            output_names__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AdvancedExtension => {
                            if advanced_extension__.is_some() {
                                return Err(serde::de::Error::duplicate_field("advancedExtension"));
                            }
                            advanced_extension__ = map_.next_value()?;
                        }
                        GeneratedField::SavedComputations => {
                            if saved_computations__.is_some() {
                                return Err(serde::de::Error::duplicate_field("savedComputations"));
                            }
                            saved_computations__ = Some(map_.next_value()?);
                        }
                        GeneratedField::LoadedComputations => {
                            if loaded_computations__.is_some() {
                                return Err(serde::de::Error::duplicate_field("loadedComputations"));
                            }
                            loaded_computations__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(rel_common::Hint {
                    stats: stats__,
                    constraint: constraint__,
                    alias: alias__.unwrap_or_default(),
                    output_names: output_names__.unwrap_or_default(),
                    advanced_extension: advanced_extension__,
                    saved_computations: saved_computations__.unwrap_or_default(),
                    loaded_computations: loaded_computations__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.RelCommon.Hint", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for rel_common::hint::ComputationType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unspecified => "COMPUTATION_TYPE_UNSPECIFIED",
            Self::Hashtable => "COMPUTATION_TYPE_HASHTABLE",
            Self::BloomFilter => "COMPUTATION_TYPE_BLOOM_FILTER",
            Self::Unknown => "COMPUTATION_TYPE_UNKNOWN",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for rel_common::hint::ComputationType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "COMPUTATION_TYPE_UNSPECIFIED",
            "COMPUTATION_TYPE_HASHTABLE",
            "COMPUTATION_TYPE_BLOOM_FILTER",
            "COMPUTATION_TYPE_UNKNOWN",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = rel_common::hint::ComputationType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "COMPUTATION_TYPE_UNSPECIFIED" => Ok(rel_common::hint::ComputationType::Unspecified),
                    "COMPUTATION_TYPE_HASHTABLE" => Ok(rel_common::hint::ComputationType::Hashtable),
                    "COMPUTATION_TYPE_BLOOM_FILTER" => Ok(rel_common::hint::ComputationType::BloomFilter),
                    "COMPUTATION_TYPE_UNKNOWN" => Ok(rel_common::hint::ComputationType::Unknown),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for rel_common::hint::LoadedComputation {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.computation_id_reference != 0 {
            len += 1;
        }
        if self.r#type != 0 {
            len += 1;
        }
        if self.advanced_extension.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.RelCommon.Hint.LoadedComputation", len)?;
        if self.computation_id_reference != 0 {
            struct_ser.serialize_field("computationIdReference", &self.computation_id_reference)?;
        }
        if self.r#type != 0 {
            let v = rel_common::hint::ComputationType::try_from(self.r#type)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
            struct_ser.serialize_field("type", &v)?;
        }
        if let Some(v) = self.advanced_extension.as_ref() {
            struct_ser.serialize_field("advancedExtension", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for rel_common::hint::LoadedComputation {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "computation_id_reference",
            "computationIdReference",
            "type",
            "advanced_extension",
            "advancedExtension",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ComputationIdReference,
            Type,
            AdvancedExtension,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "computationIdReference" | "computation_id_reference" => Ok(GeneratedField::ComputationIdReference),
                            "type" => Ok(GeneratedField::Type),
                            "advancedExtension" | "advanced_extension" => Ok(GeneratedField::AdvancedExtension),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = rel_common::hint::LoadedComputation;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.RelCommon.Hint.LoadedComputation")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<rel_common::hint::LoadedComputation, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut computation_id_reference__ = None;
                let mut r#type__ = None;
                let mut advanced_extension__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ComputationIdReference => {
                            if computation_id_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("computationIdReference"));
                            }
                            computation_id_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<rel_common::hint::ComputationType>()? as i32);
                        }
                        GeneratedField::AdvancedExtension => {
                            if advanced_extension__.is_some() {
                                return Err(serde::de::Error::duplicate_field("advancedExtension"));
                            }
                            advanced_extension__ = map_.next_value()?;
                        }
                    }
                }
                Ok(rel_common::hint::LoadedComputation {
                    computation_id_reference: computation_id_reference__.unwrap_or_default(),
                    r#type: r#type__.unwrap_or_default(),
                    advanced_extension: advanced_extension__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.RelCommon.Hint.LoadedComputation", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for rel_common::hint::RuntimeConstraint {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.advanced_extension.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.RelCommon.Hint.RuntimeConstraint", len)?;
        if let Some(v) = self.advanced_extension.as_ref() {
            struct_ser.serialize_field("advancedExtension", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for rel_common::hint::RuntimeConstraint {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "advanced_extension",
            "advancedExtension",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AdvancedExtension,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "advancedExtension" | "advanced_extension" => Ok(GeneratedField::AdvancedExtension),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = rel_common::hint::RuntimeConstraint;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.RelCommon.Hint.RuntimeConstraint")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<rel_common::hint::RuntimeConstraint, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut advanced_extension__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AdvancedExtension => {
                            if advanced_extension__.is_some() {
                                return Err(serde::de::Error::duplicate_field("advancedExtension"));
                            }
                            advanced_extension__ = map_.next_value()?;
                        }
                    }
                }
                Ok(rel_common::hint::RuntimeConstraint {
                    advanced_extension: advanced_extension__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.RelCommon.Hint.RuntimeConstraint", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for rel_common::hint::SavedComputation {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.computation_id != 0 {
            len += 1;
        }
        if self.r#type != 0 {
            len += 1;
        }
        if self.advanced_extension.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.RelCommon.Hint.SavedComputation", len)?;
        if self.computation_id != 0 {
            struct_ser.serialize_field("computationId", &self.computation_id)?;
        }
        if self.r#type != 0 {
            let v = rel_common::hint::ComputationType::try_from(self.r#type)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
            struct_ser.serialize_field("type", &v)?;
        }
        if let Some(v) = self.advanced_extension.as_ref() {
            struct_ser.serialize_field("advancedExtension", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for rel_common::hint::SavedComputation {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "computation_id",
            "computationId",
            "type",
            "advanced_extension",
            "advancedExtension",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ComputationId,
            Type,
            AdvancedExtension,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "computationId" | "computation_id" => Ok(GeneratedField::ComputationId),
                            "type" => Ok(GeneratedField::Type),
                            "advancedExtension" | "advanced_extension" => Ok(GeneratedField::AdvancedExtension),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = rel_common::hint::SavedComputation;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.RelCommon.Hint.SavedComputation")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<rel_common::hint::SavedComputation, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut computation_id__ = None;
                let mut r#type__ = None;
                let mut advanced_extension__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ComputationId => {
                            if computation_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("computationId"));
                            }
                            computation_id__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<rel_common::hint::ComputationType>()? as i32);
                        }
                        GeneratedField::AdvancedExtension => {
                            if advanced_extension__.is_some() {
                                return Err(serde::de::Error::duplicate_field("advancedExtension"));
                            }
                            advanced_extension__ = map_.next_value()?;
                        }
                    }
                }
                Ok(rel_common::hint::SavedComputation {
                    computation_id: computation_id__.unwrap_or_default(),
                    r#type: r#type__.unwrap_or_default(),
                    advanced_extension: advanced_extension__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.RelCommon.Hint.SavedComputation", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for rel_common::hint::Stats {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.row_count != 0. {
            len += 1;
        }
        if self.record_size != 0. {
            len += 1;
        }
        if self.advanced_extension.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.RelCommon.Hint.Stats", len)?;
        if self.row_count != 0. {
            struct_ser.serialize_field("rowCount", &self.row_count)?;
        }
        if self.record_size != 0. {
            struct_ser.serialize_field("recordSize", &self.record_size)?;
        }
        if let Some(v) = self.advanced_extension.as_ref() {
            struct_ser.serialize_field("advancedExtension", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for rel_common::hint::Stats {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "row_count",
            "rowCount",
            "record_size",
            "recordSize",
            "advanced_extension",
            "advancedExtension",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            RowCount,
            RecordSize,
            AdvancedExtension,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "rowCount" | "row_count" => Ok(GeneratedField::RowCount),
                            "recordSize" | "record_size" => Ok(GeneratedField::RecordSize),
                            "advancedExtension" | "advanced_extension" => Ok(GeneratedField::AdvancedExtension),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = rel_common::hint::Stats;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.RelCommon.Hint.Stats")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<rel_common::hint::Stats, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut row_count__ = None;
                let mut record_size__ = None;
                let mut advanced_extension__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::RowCount => {
                            if row_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rowCount"));
                            }
                            row_count__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::RecordSize => {
                            if record_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("recordSize"));
                            }
                            record_size__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::AdvancedExtension => {
                            if advanced_extension__.is_some() {
                                return Err(serde::de::Error::duplicate_field("advancedExtension"));
                            }
                            advanced_extension__ = map_.next_value()?;
                        }
                    }
                }
                Ok(rel_common::hint::Stats {
                    row_count: row_count__.unwrap_or_default(),
                    record_size: record_size__.unwrap_or_default(),
                    advanced_extension: advanced_extension__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.RelCommon.Hint.Stats", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RelRoot {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.input.is_some() {
            len += 1;
        }
        if !self.names.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.RelRoot", len)?;
        if let Some(v) = self.input.as_ref() {
            struct_ser.serialize_field("input", v)?;
        }
        if !self.names.is_empty() {
            struct_ser.serialize_field("names", &self.names)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RelRoot {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "input",
            "names",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Input,
            Names,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "input" => Ok(GeneratedField::Input),
                            "names" => Ok(GeneratedField::Names),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RelRoot;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.RelRoot")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RelRoot, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut input__ = None;
                let mut names__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Input => {
                            if input__.is_some() {
                                return Err(serde::de::Error::duplicate_field("input"));
                            }
                            input__ = map_.next_value()?;
                        }
                        GeneratedField::Names => {
                            if names__.is_some() {
                                return Err(serde::de::Error::duplicate_field("names"));
                            }
                            names__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(RelRoot {
                    input: input__,
                    names: names__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.RelRoot", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SetRel {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.common.is_some() {
            len += 1;
        }
        if !self.inputs.is_empty() {
            len += 1;
        }
        if self.op != 0 {
            len += 1;
        }
        if self.advanced_extension.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.SetRel", len)?;
        if let Some(v) = self.common.as_ref() {
            struct_ser.serialize_field("common", v)?;
        }
        if !self.inputs.is_empty() {
            struct_ser.serialize_field("inputs", &self.inputs)?;
        }
        if self.op != 0 {
            let v = set_rel::SetOp::try_from(self.op)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.op)))?;
            struct_ser.serialize_field("op", &v)?;
        }
        if let Some(v) = self.advanced_extension.as_ref() {
            struct_ser.serialize_field("advancedExtension", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SetRel {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "common",
            "inputs",
            "op",
            "advanced_extension",
            "advancedExtension",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Common,
            Inputs,
            Op,
            AdvancedExtension,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "common" => Ok(GeneratedField::Common),
                            "inputs" => Ok(GeneratedField::Inputs),
                            "op" => Ok(GeneratedField::Op),
                            "advancedExtension" | "advanced_extension" => Ok(GeneratedField::AdvancedExtension),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SetRel;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.SetRel")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SetRel, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut common__ = None;
                let mut inputs__ = None;
                let mut op__ = None;
                let mut advanced_extension__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Common => {
                            if common__.is_some() {
                                return Err(serde::de::Error::duplicate_field("common"));
                            }
                            common__ = map_.next_value()?;
                        }
                        GeneratedField::Inputs => {
                            if inputs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inputs"));
                            }
                            inputs__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Op => {
                            if op__.is_some() {
                                return Err(serde::de::Error::duplicate_field("op"));
                            }
                            op__ = Some(map_.next_value::<set_rel::SetOp>()? as i32);
                        }
                        GeneratedField::AdvancedExtension => {
                            if advanced_extension__.is_some() {
                                return Err(serde::de::Error::duplicate_field("advancedExtension"));
                            }
                            advanced_extension__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SetRel {
                    common: common__,
                    inputs: inputs__.unwrap_or_default(),
                    op: op__.unwrap_or_default(),
                    advanced_extension: advanced_extension__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.SetRel", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for set_rel::SetOp {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unspecified => "SET_OP_UNSPECIFIED",
            Self::MinusPrimary => "SET_OP_MINUS_PRIMARY",
            Self::MinusPrimaryAll => "SET_OP_MINUS_PRIMARY_ALL",
            Self::MinusMultiset => "SET_OP_MINUS_MULTISET",
            Self::IntersectionPrimary => "SET_OP_INTERSECTION_PRIMARY",
            Self::IntersectionMultiset => "SET_OP_INTERSECTION_MULTISET",
            Self::IntersectionMultisetAll => "SET_OP_INTERSECTION_MULTISET_ALL",
            Self::UnionDistinct => "SET_OP_UNION_DISTINCT",
            Self::UnionAll => "SET_OP_UNION_ALL",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for set_rel::SetOp {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SET_OP_UNSPECIFIED",
            "SET_OP_MINUS_PRIMARY",
            "SET_OP_MINUS_PRIMARY_ALL",
            "SET_OP_MINUS_MULTISET",
            "SET_OP_INTERSECTION_PRIMARY",
            "SET_OP_INTERSECTION_MULTISET",
            "SET_OP_INTERSECTION_MULTISET_ALL",
            "SET_OP_UNION_DISTINCT",
            "SET_OP_UNION_ALL",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = set_rel::SetOp;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SET_OP_UNSPECIFIED" => Ok(set_rel::SetOp::Unspecified),
                    "SET_OP_MINUS_PRIMARY" => Ok(set_rel::SetOp::MinusPrimary),
                    "SET_OP_MINUS_PRIMARY_ALL" => Ok(set_rel::SetOp::MinusPrimaryAll),
                    "SET_OP_MINUS_MULTISET" => Ok(set_rel::SetOp::MinusMultiset),
                    "SET_OP_INTERSECTION_PRIMARY" => Ok(set_rel::SetOp::IntersectionPrimary),
                    "SET_OP_INTERSECTION_MULTISET" => Ok(set_rel::SetOp::IntersectionMultiset),
                    "SET_OP_INTERSECTION_MULTISET_ALL" => Ok(set_rel::SetOp::IntersectionMultisetAll),
                    "SET_OP_UNION_DISTINCT" => Ok(set_rel::SetOp::UnionDistinct),
                    "SET_OP_UNION_ALL" => Ok(set_rel::SetOp::UnionAll),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for SortField {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.expr.is_some() {
            len += 1;
        }
        if self.sort_kind.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.SortField", len)?;
        if let Some(v) = self.expr.as_ref() {
            struct_ser.serialize_field("expr", v)?;
        }
        if let Some(v) = self.sort_kind.as_ref() {
            match v {
                sort_field::SortKind::Direction(v) => {
                    let v = sort_field::SortDirection::try_from(*v)
                        .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
                    struct_ser.serialize_field("direction", &v)?;
                }
                sort_field::SortKind::ComparisonFunctionReference(v) => {
                    struct_ser.serialize_field("comparisonFunctionReference", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SortField {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "expr",
            "direction",
            "comparison_function_reference",
            "comparisonFunctionReference",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Expr,
            Direction,
            ComparisonFunctionReference,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "expr" => Ok(GeneratedField::Expr),
                            "direction" => Ok(GeneratedField::Direction),
                            "comparisonFunctionReference" | "comparison_function_reference" => Ok(GeneratedField::ComparisonFunctionReference),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SortField;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.SortField")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SortField, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut expr__ = None;
                let mut sort_kind__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Expr => {
                            if expr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expr"));
                            }
                            expr__ = map_.next_value()?;
                        }
                        GeneratedField::Direction => {
                            if sort_kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("direction"));
                            }
                            sort_kind__ = map_.next_value::<::std::option::Option<sort_field::SortDirection>>()?.map(|x| sort_field::SortKind::Direction(x as i32));
                        }
                        GeneratedField::ComparisonFunctionReference => {
                            if sort_kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("comparisonFunctionReference"));
                            }
                            sort_kind__ = map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| sort_field::SortKind::ComparisonFunctionReference(x.0));
                        }
                    }
                }
                Ok(SortField {
                    expr: expr__,
                    sort_kind: sort_kind__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.SortField", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for sort_field::SortDirection {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unspecified => "SORT_DIRECTION_UNSPECIFIED",
            Self::AscNullsFirst => "SORT_DIRECTION_ASC_NULLS_FIRST",
            Self::AscNullsLast => "SORT_DIRECTION_ASC_NULLS_LAST",
            Self::DescNullsFirst => "SORT_DIRECTION_DESC_NULLS_FIRST",
            Self::DescNullsLast => "SORT_DIRECTION_DESC_NULLS_LAST",
            Self::Clustered => "SORT_DIRECTION_CLUSTERED",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for sort_field::SortDirection {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SORT_DIRECTION_UNSPECIFIED",
            "SORT_DIRECTION_ASC_NULLS_FIRST",
            "SORT_DIRECTION_ASC_NULLS_LAST",
            "SORT_DIRECTION_DESC_NULLS_FIRST",
            "SORT_DIRECTION_DESC_NULLS_LAST",
            "SORT_DIRECTION_CLUSTERED",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = sort_field::SortDirection;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SORT_DIRECTION_UNSPECIFIED" => Ok(sort_field::SortDirection::Unspecified),
                    "SORT_DIRECTION_ASC_NULLS_FIRST" => Ok(sort_field::SortDirection::AscNullsFirst),
                    "SORT_DIRECTION_ASC_NULLS_LAST" => Ok(sort_field::SortDirection::AscNullsLast),
                    "SORT_DIRECTION_DESC_NULLS_FIRST" => Ok(sort_field::SortDirection::DescNullsFirst),
                    "SORT_DIRECTION_DESC_NULLS_LAST" => Ok(sort_field::SortDirection::DescNullsLast),
                    "SORT_DIRECTION_CLUSTERED" => Ok(sort_field::SortDirection::Clustered),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for SortRel {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.common.is_some() {
            len += 1;
        }
        if self.input.is_some() {
            len += 1;
        }
        if !self.sorts.is_empty() {
            len += 1;
        }
        if self.advanced_extension.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.SortRel", len)?;
        if let Some(v) = self.common.as_ref() {
            struct_ser.serialize_field("common", v)?;
        }
        if let Some(v) = self.input.as_ref() {
            struct_ser.serialize_field("input", v)?;
        }
        if !self.sorts.is_empty() {
            struct_ser.serialize_field("sorts", &self.sorts)?;
        }
        if let Some(v) = self.advanced_extension.as_ref() {
            struct_ser.serialize_field("advancedExtension", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SortRel {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "common",
            "input",
            "sorts",
            "advanced_extension",
            "advancedExtension",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Common,
            Input,
            Sorts,
            AdvancedExtension,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "common" => Ok(GeneratedField::Common),
                            "input" => Ok(GeneratedField::Input),
                            "sorts" => Ok(GeneratedField::Sorts),
                            "advancedExtension" | "advanced_extension" => Ok(GeneratedField::AdvancedExtension),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SortRel;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.SortRel")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SortRel, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut common__ = None;
                let mut input__ = None;
                let mut sorts__ = None;
                let mut advanced_extension__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Common => {
                            if common__.is_some() {
                                return Err(serde::de::Error::duplicate_field("common"));
                            }
                            common__ = map_.next_value()?;
                        }
                        GeneratedField::Input => {
                            if input__.is_some() {
                                return Err(serde::de::Error::duplicate_field("input"));
                            }
                            input__ = map_.next_value()?;
                        }
                        GeneratedField::Sorts => {
                            if sorts__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sorts"));
                            }
                            sorts__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AdvancedExtension => {
                            if advanced_extension__.is_some() {
                                return Err(serde::de::Error::duplicate_field("advancedExtension"));
                            }
                            advanced_extension__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SortRel {
                    common: common__,
                    input: input__,
                    sorts: sorts__.unwrap_or_default(),
                    advanced_extension: advanced_extension__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.SortRel", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Type {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.kind.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Type", len)?;
        if let Some(v) = self.kind.as_ref() {
            match v {
                r#type::Kind::Bool(v) => {
                    struct_ser.serialize_field("bool", v)?;
                }
                r#type::Kind::I8(v) => {
                    struct_ser.serialize_field("i8", v)?;
                }
                r#type::Kind::I16(v) => {
                    struct_ser.serialize_field("i16", v)?;
                }
                r#type::Kind::I32(v) => {
                    struct_ser.serialize_field("i32", v)?;
                }
                r#type::Kind::I64(v) => {
                    struct_ser.serialize_field("i64", v)?;
                }
                r#type::Kind::Fp32(v) => {
                    struct_ser.serialize_field("fp32", v)?;
                }
                r#type::Kind::Fp64(v) => {
                    struct_ser.serialize_field("fp64", v)?;
                }
                r#type::Kind::String(v) => {
                    struct_ser.serialize_field("string", v)?;
                }
                r#type::Kind::Binary(v) => {
                    struct_ser.serialize_field("binary", v)?;
                }
                r#type::Kind::Timestamp(v) => {
                    struct_ser.serialize_field("timestamp", v)?;
                }
                r#type::Kind::Date(v) => {
                    struct_ser.serialize_field("date", v)?;
                }
                r#type::Kind::Time(v) => {
                    struct_ser.serialize_field("time", v)?;
                }
                r#type::Kind::IntervalYear(v) => {
                    struct_ser.serialize_field("intervalYear", v)?;
                }
                r#type::Kind::IntervalDay(v) => {
                    struct_ser.serialize_field("intervalDay", v)?;
                }
                r#type::Kind::IntervalCompound(v) => {
                    struct_ser.serialize_field("intervalCompound", v)?;
                }
                r#type::Kind::TimestampTz(v) => {
                    struct_ser.serialize_field("timestampTz", v)?;
                }
                r#type::Kind::Uuid(v) => {
                    struct_ser.serialize_field("uuid", v)?;
                }
                r#type::Kind::FixedChar(v) => {
                    struct_ser.serialize_field("fixedChar", v)?;
                }
                r#type::Kind::Varchar(v) => {
                    struct_ser.serialize_field("varchar", v)?;
                }
                r#type::Kind::FixedBinary(v) => {
                    struct_ser.serialize_field("fixedBinary", v)?;
                }
                r#type::Kind::Decimal(v) => {
                    struct_ser.serialize_field("decimal", v)?;
                }
                r#type::Kind::PrecisionTime(v) => {
                    struct_ser.serialize_field("precisionTime", v)?;
                }
                r#type::Kind::PrecisionTimestamp(v) => {
                    struct_ser.serialize_field("precisionTimestamp", v)?;
                }
                r#type::Kind::PrecisionTimestampTz(v) => {
                    struct_ser.serialize_field("precisionTimestampTz", v)?;
                }
                r#type::Kind::Struct(v) => {
                    struct_ser.serialize_field("struct", v)?;
                }
                r#type::Kind::List(v) => {
                    struct_ser.serialize_field("list", v)?;
                }
                r#type::Kind::Map(v) => {
                    struct_ser.serialize_field("map", v)?;
                }
                r#type::Kind::UserDefined(v) => {
                    struct_ser.serialize_field("userDefined", v)?;
                }
                r#type::Kind::UserDefinedTypeReference(v) => {
                    struct_ser.serialize_field("userDefinedTypeReference", v)?;
                }
                r#type::Kind::Alias(v) => {
                    struct_ser.serialize_field("alias", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Type {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "bool",
            "i8",
            "i16",
            "i32",
            "i64",
            "fp32",
            "fp64",
            "string",
            "binary",
            "timestamp",
            "date",
            "time",
            "interval_year",
            "intervalYear",
            "interval_day",
            "intervalDay",
            "interval_compound",
            "intervalCompound",
            "timestamp_tz",
            "timestampTz",
            "uuid",
            "fixed_char",
            "fixedChar",
            "varchar",
            "fixed_binary",
            "fixedBinary",
            "decimal",
            "precision_time",
            "precisionTime",
            "precision_timestamp",
            "precisionTimestamp",
            "precision_timestamp_tz",
            "precisionTimestampTz",
            "struct",
            "list",
            "map",
            "user_defined",
            "userDefined",
            "user_defined_type_reference",
            "userDefinedTypeReference",
            "alias",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Bool,
            I8,
            I16,
            I32,
            I64,
            Fp32,
            Fp64,
            String,
            Binary,
            Timestamp,
            Date,
            Time,
            IntervalYear,
            IntervalDay,
            IntervalCompound,
            TimestampTz,
            Uuid,
            FixedChar,
            Varchar,
            FixedBinary,
            Decimal,
            PrecisionTime,
            PrecisionTimestamp,
            PrecisionTimestampTz,
            Struct,
            List,
            Map,
            UserDefined,
            UserDefinedTypeReference,
            Alias,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "bool" => Ok(GeneratedField::Bool),
                            "i8" => Ok(GeneratedField::I8),
                            "i16" => Ok(GeneratedField::I16),
                            "i32" => Ok(GeneratedField::I32),
                            "i64" => Ok(GeneratedField::I64),
                            "fp32" => Ok(GeneratedField::Fp32),
                            "fp64" => Ok(GeneratedField::Fp64),
                            "string" => Ok(GeneratedField::String),
                            "binary" => Ok(GeneratedField::Binary),
                            "timestamp" => Ok(GeneratedField::Timestamp),
                            "date" => Ok(GeneratedField::Date),
                            "time" => Ok(GeneratedField::Time),
                            "intervalYear" | "interval_year" => Ok(GeneratedField::IntervalYear),
                            "intervalDay" | "interval_day" => Ok(GeneratedField::IntervalDay),
                            "intervalCompound" | "interval_compound" => Ok(GeneratedField::IntervalCompound),
                            "timestampTz" | "timestamp_tz" => Ok(GeneratedField::TimestampTz),
                            "uuid" => Ok(GeneratedField::Uuid),
                            "fixedChar" | "fixed_char" => Ok(GeneratedField::FixedChar),
                            "varchar" => Ok(GeneratedField::Varchar),
                            "fixedBinary" | "fixed_binary" => Ok(GeneratedField::FixedBinary),
                            "decimal" => Ok(GeneratedField::Decimal),
                            "precisionTime" | "precision_time" => Ok(GeneratedField::PrecisionTime),
                            "precisionTimestamp" | "precision_timestamp" => Ok(GeneratedField::PrecisionTimestamp),
                            "precisionTimestampTz" | "precision_timestamp_tz" => Ok(GeneratedField::PrecisionTimestampTz),
                            "struct" => Ok(GeneratedField::Struct),
                            "list" => Ok(GeneratedField::List),
                            "map" => Ok(GeneratedField::Map),
                            "userDefined" | "user_defined" => Ok(GeneratedField::UserDefined),
                            "userDefinedTypeReference" | "user_defined_type_reference" => Ok(GeneratedField::UserDefinedTypeReference),
                            "alias" => Ok(GeneratedField::Alias),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Type;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Type")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Type, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut kind__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Bool => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bool"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::Kind::Bool)
;
                        }
                        GeneratedField::I8 => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("i8"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::Kind::I8)
;
                        }
                        GeneratedField::I16 => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("i16"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::Kind::I16)
;
                        }
                        GeneratedField::I32 => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("i32"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::Kind::I32)
;
                        }
                        GeneratedField::I64 => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("i64"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::Kind::I64)
;
                        }
                        GeneratedField::Fp32 => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fp32"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::Kind::Fp32)
;
                        }
                        GeneratedField::Fp64 => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fp64"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::Kind::Fp64)
;
                        }
                        GeneratedField::String => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("string"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::Kind::String)
;
                        }
                        GeneratedField::Binary => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("binary"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::Kind::Binary)
;
                        }
                        GeneratedField::Timestamp => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestamp"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::Kind::Timestamp)
;
                        }
                        GeneratedField::Date => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("date"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::Kind::Date)
;
                        }
                        GeneratedField::Time => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("time"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::Kind::Time)
;
                        }
                        GeneratedField::IntervalYear => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("intervalYear"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::Kind::IntervalYear)
;
                        }
                        GeneratedField::IntervalDay => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("intervalDay"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::Kind::IntervalDay)
;
                        }
                        GeneratedField::IntervalCompound => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("intervalCompound"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::Kind::IntervalCompound)
;
                        }
                        GeneratedField::TimestampTz => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestampTz"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::Kind::TimestampTz)
;
                        }
                        GeneratedField::Uuid => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("uuid"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::Kind::Uuid)
;
                        }
                        GeneratedField::FixedChar => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fixedChar"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::Kind::FixedChar)
;
                        }
                        GeneratedField::Varchar => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("varchar"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::Kind::Varchar)
;
                        }
                        GeneratedField::FixedBinary => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fixedBinary"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::Kind::FixedBinary)
;
                        }
                        GeneratedField::Decimal => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("decimal"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::Kind::Decimal)
;
                        }
                        GeneratedField::PrecisionTime => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precisionTime"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::Kind::PrecisionTime)
;
                        }
                        GeneratedField::PrecisionTimestamp => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precisionTimestamp"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::Kind::PrecisionTimestamp)
;
                        }
                        GeneratedField::PrecisionTimestampTz => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precisionTimestampTz"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::Kind::PrecisionTimestampTz)
;
                        }
                        GeneratedField::Struct => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("struct"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::Kind::Struct)
;
                        }
                        GeneratedField::List => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::Kind::List)
;
                        }
                        GeneratedField::Map => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("map"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::Kind::Map)
;
                        }
                        GeneratedField::UserDefined => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("userDefined"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::Kind::UserDefined)
;
                        }
                        GeneratedField::UserDefinedTypeReference => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("userDefinedTypeReference"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| r#type::Kind::UserDefinedTypeReference(x.0));
                        }
                        GeneratedField::Alias => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("alias"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::Kind::Alias)
;
                        }
                    }
                }
                Ok(Type {
                    kind: kind__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Type", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for r#type::Binary {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.type_variation_reference != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Type.Binary", len)?;
        if self.type_variation_reference != 0 {
            struct_ser.serialize_field("typeVariationReference", &self.type_variation_reference)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for r#type::Binary {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type_variation_reference",
            "typeVariationReference",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TypeVariationReference,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "typeVariationReference" | "type_variation_reference" => Ok(GeneratedField::TypeVariationReference),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = r#type::Binary;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Type.Binary")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<r#type::Binary, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut type_variation_reference__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TypeVariationReference => {
                            if type_variation_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeVariationReference"));
                            }
                            type_variation_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(r#type::Binary {
                    type_variation_reference: type_variation_reference__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Type.Binary", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for r#type::Boolean {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.type_variation_reference != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Type.Boolean", len)?;
        if self.type_variation_reference != 0 {
            struct_ser.serialize_field("typeVariationReference", &self.type_variation_reference)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for r#type::Boolean {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type_variation_reference",
            "typeVariationReference",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TypeVariationReference,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "typeVariationReference" | "type_variation_reference" => Ok(GeneratedField::TypeVariationReference),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = r#type::Boolean;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Type.Boolean")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<r#type::Boolean, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut type_variation_reference__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TypeVariationReference => {
                            if type_variation_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeVariationReference"));
                            }
                            type_variation_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(r#type::Boolean {
                    type_variation_reference: type_variation_reference__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Type.Boolean", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for r#type::Date {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.type_variation_reference != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Type.Date", len)?;
        if self.type_variation_reference != 0 {
            struct_ser.serialize_field("typeVariationReference", &self.type_variation_reference)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for r#type::Date {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type_variation_reference",
            "typeVariationReference",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TypeVariationReference,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "typeVariationReference" | "type_variation_reference" => Ok(GeneratedField::TypeVariationReference),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = r#type::Date;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Type.Date")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<r#type::Date, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut type_variation_reference__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TypeVariationReference => {
                            if type_variation_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeVariationReference"));
                            }
                            type_variation_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(r#type::Date {
                    type_variation_reference: type_variation_reference__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Type.Date", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for r#type::Decimal {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.scale != 0 {
            len += 1;
        }
        if self.precision != 0 {
            len += 1;
        }
        if self.type_variation_reference != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Type.Decimal", len)?;
        if self.scale != 0 {
            struct_ser.serialize_field("scale", &self.scale)?;
        }
        if self.precision != 0 {
            struct_ser.serialize_field("precision", &self.precision)?;
        }
        if self.type_variation_reference != 0 {
            struct_ser.serialize_field("typeVariationReference", &self.type_variation_reference)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for r#type::Decimal {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "scale",
            "precision",
            "type_variation_reference",
            "typeVariationReference",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Scale,
            Precision,
            TypeVariationReference,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "scale" => Ok(GeneratedField::Scale),
                            "precision" => Ok(GeneratedField::Precision),
                            "typeVariationReference" | "type_variation_reference" => Ok(GeneratedField::TypeVariationReference),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = r#type::Decimal;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Type.Decimal")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<r#type::Decimal, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut scale__ = None;
                let mut precision__ = None;
                let mut type_variation_reference__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Scale => {
                            if scale__.is_some() {
                                return Err(serde::de::Error::duplicate_field("scale"));
                            }
                            scale__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Precision => {
                            if precision__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precision"));
                            }
                            precision__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::TypeVariationReference => {
                            if type_variation_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeVariationReference"));
                            }
                            type_variation_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(r#type::Decimal {
                    scale: scale__.unwrap_or_default(),
                    precision: precision__.unwrap_or_default(),
                    type_variation_reference: type_variation_reference__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Type.Decimal", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for r#type::Fp32 {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.type_variation_reference != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Type.FP32", len)?;
        if self.type_variation_reference != 0 {
            struct_ser.serialize_field("typeVariationReference", &self.type_variation_reference)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for r#type::Fp32 {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type_variation_reference",
            "typeVariationReference",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TypeVariationReference,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "typeVariationReference" | "type_variation_reference" => Ok(GeneratedField::TypeVariationReference),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = r#type::Fp32;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Type.FP32")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<r#type::Fp32, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut type_variation_reference__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TypeVariationReference => {
                            if type_variation_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeVariationReference"));
                            }
                            type_variation_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(r#type::Fp32 {
                    type_variation_reference: type_variation_reference__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Type.FP32", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for r#type::Fp64 {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.type_variation_reference != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Type.FP64", len)?;
        if self.type_variation_reference != 0 {
            struct_ser.serialize_field("typeVariationReference", &self.type_variation_reference)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for r#type::Fp64 {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type_variation_reference",
            "typeVariationReference",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TypeVariationReference,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "typeVariationReference" | "type_variation_reference" => Ok(GeneratedField::TypeVariationReference),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = r#type::Fp64;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Type.FP64")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<r#type::Fp64, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut type_variation_reference__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TypeVariationReference => {
                            if type_variation_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeVariationReference"));
                            }
                            type_variation_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(r#type::Fp64 {
                    type_variation_reference: type_variation_reference__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Type.FP64", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for r#type::FixedBinary {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.length != 0 {
            len += 1;
        }
        if self.type_variation_reference != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Type.FixedBinary", len)?;
        if self.length != 0 {
            struct_ser.serialize_field("length", &self.length)?;
        }
        if self.type_variation_reference != 0 {
            struct_ser.serialize_field("typeVariationReference", &self.type_variation_reference)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for r#type::FixedBinary {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "length",
            "type_variation_reference",
            "typeVariationReference",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Length,
            TypeVariationReference,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "length" => Ok(GeneratedField::Length),
                            "typeVariationReference" | "type_variation_reference" => Ok(GeneratedField::TypeVariationReference),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = r#type::FixedBinary;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Type.FixedBinary")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<r#type::FixedBinary, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut length__ = None;
                let mut type_variation_reference__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Length => {
                            if length__.is_some() {
                                return Err(serde::de::Error::duplicate_field("length"));
                            }
                            length__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::TypeVariationReference => {
                            if type_variation_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeVariationReference"));
                            }
                            type_variation_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(r#type::FixedBinary {
                    length: length__.unwrap_or_default(),
                    type_variation_reference: type_variation_reference__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Type.FixedBinary", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for r#type::FixedChar {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.length != 0 {
            len += 1;
        }
        if self.type_variation_reference != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Type.FixedChar", len)?;
        if self.length != 0 {
            struct_ser.serialize_field("length", &self.length)?;
        }
        if self.type_variation_reference != 0 {
            struct_ser.serialize_field("typeVariationReference", &self.type_variation_reference)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for r#type::FixedChar {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "length",
            "type_variation_reference",
            "typeVariationReference",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Length,
            TypeVariationReference,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "length" => Ok(GeneratedField::Length),
                            "typeVariationReference" | "type_variation_reference" => Ok(GeneratedField::TypeVariationReference),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = r#type::FixedChar;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Type.FixedChar")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<r#type::FixedChar, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut length__ = None;
                let mut type_variation_reference__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Length => {
                            if length__.is_some() {
                                return Err(serde::de::Error::duplicate_field("length"));
                            }
                            length__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::TypeVariationReference => {
                            if type_variation_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeVariationReference"));
                            }
                            type_variation_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(r#type::FixedChar {
                    length: length__.unwrap_or_default(),
                    type_variation_reference: type_variation_reference__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Type.FixedChar", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for r#type::I16 {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.type_variation_reference != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Type.I16", len)?;
        if self.type_variation_reference != 0 {
            struct_ser.serialize_field("typeVariationReference", &self.type_variation_reference)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for r#type::I16 {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type_variation_reference",
            "typeVariationReference",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TypeVariationReference,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "typeVariationReference" | "type_variation_reference" => Ok(GeneratedField::TypeVariationReference),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = r#type::I16;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Type.I16")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<r#type::I16, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut type_variation_reference__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TypeVariationReference => {
                            if type_variation_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeVariationReference"));
                            }
                            type_variation_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(r#type::I16 {
                    type_variation_reference: type_variation_reference__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Type.I16", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for r#type::I32 {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.type_variation_reference != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Type.I32", len)?;
        if self.type_variation_reference != 0 {
            struct_ser.serialize_field("typeVariationReference", &self.type_variation_reference)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for r#type::I32 {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type_variation_reference",
            "typeVariationReference",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TypeVariationReference,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "typeVariationReference" | "type_variation_reference" => Ok(GeneratedField::TypeVariationReference),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = r#type::I32;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Type.I32")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<r#type::I32, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut type_variation_reference__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TypeVariationReference => {
                            if type_variation_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeVariationReference"));
                            }
                            type_variation_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(r#type::I32 {
                    type_variation_reference: type_variation_reference__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Type.I32", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for r#type::I64 {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.type_variation_reference != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Type.I64", len)?;
        if self.type_variation_reference != 0 {
            struct_ser.serialize_field("typeVariationReference", &self.type_variation_reference)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for r#type::I64 {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type_variation_reference",
            "typeVariationReference",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TypeVariationReference,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "typeVariationReference" | "type_variation_reference" => Ok(GeneratedField::TypeVariationReference),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = r#type::I64;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Type.I64")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<r#type::I64, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut type_variation_reference__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TypeVariationReference => {
                            if type_variation_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeVariationReference"));
                            }
                            type_variation_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(r#type::I64 {
                    type_variation_reference: type_variation_reference__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Type.I64", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for r#type::I8 {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.type_variation_reference != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Type.I8", len)?;
        if self.type_variation_reference != 0 {
            struct_ser.serialize_field("typeVariationReference", &self.type_variation_reference)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for r#type::I8 {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type_variation_reference",
            "typeVariationReference",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TypeVariationReference,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "typeVariationReference" | "type_variation_reference" => Ok(GeneratedField::TypeVariationReference),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = r#type::I8;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Type.I8")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<r#type::I8, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut type_variation_reference__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TypeVariationReference => {
                            if type_variation_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeVariationReference"));
                            }
                            type_variation_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(r#type::I8 {
                    type_variation_reference: type_variation_reference__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Type.I8", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for r#type::IntervalCompound {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.type_variation_reference != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        if self.precision != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Type.IntervalCompound", len)?;
        if self.type_variation_reference != 0 {
            struct_ser.serialize_field("typeVariationReference", &self.type_variation_reference)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        if self.precision != 0 {
            struct_ser.serialize_field("precision", &self.precision)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for r#type::IntervalCompound {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type_variation_reference",
            "typeVariationReference",
            "nullability",
            "precision",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TypeVariationReference,
            Nullability,
            Precision,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "typeVariationReference" | "type_variation_reference" => Ok(GeneratedField::TypeVariationReference),
                            "nullability" => Ok(GeneratedField::Nullability),
                            "precision" => Ok(GeneratedField::Precision),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = r#type::IntervalCompound;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Type.IntervalCompound")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<r#type::IntervalCompound, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut type_variation_reference__ = None;
                let mut nullability__ = None;
                let mut precision__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TypeVariationReference => {
                            if type_variation_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeVariationReference"));
                            }
                            type_variation_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                        GeneratedField::Precision => {
                            if precision__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precision"));
                            }
                            precision__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(r#type::IntervalCompound {
                    type_variation_reference: type_variation_reference__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                    precision: precision__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Type.IntervalCompound", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for r#type::IntervalDay {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.type_variation_reference != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        if self.precision.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Type.IntervalDay", len)?;
        if self.type_variation_reference != 0 {
            struct_ser.serialize_field("typeVariationReference", &self.type_variation_reference)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        if let Some(v) = self.precision.as_ref() {
            struct_ser.serialize_field("precision", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for r#type::IntervalDay {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type_variation_reference",
            "typeVariationReference",
            "nullability",
            "precision",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TypeVariationReference,
            Nullability,
            Precision,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "typeVariationReference" | "type_variation_reference" => Ok(GeneratedField::TypeVariationReference),
                            "nullability" => Ok(GeneratedField::Nullability),
                            "precision" => Ok(GeneratedField::Precision),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = r#type::IntervalDay;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Type.IntervalDay")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<r#type::IntervalDay, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut type_variation_reference__ = None;
                let mut nullability__ = None;
                let mut precision__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TypeVariationReference => {
                            if type_variation_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeVariationReference"));
                            }
                            type_variation_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                        GeneratedField::Precision => {
                            if precision__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precision"));
                            }
                            precision__ =
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(r#type::IntervalDay {
                    type_variation_reference: type_variation_reference__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                    precision: precision__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Type.IntervalDay", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for r#type::IntervalYear {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.type_variation_reference != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Type.IntervalYear", len)?;
        if self.type_variation_reference != 0 {
            struct_ser.serialize_field("typeVariationReference", &self.type_variation_reference)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for r#type::IntervalYear {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type_variation_reference",
            "typeVariationReference",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TypeVariationReference,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "typeVariationReference" | "type_variation_reference" => Ok(GeneratedField::TypeVariationReference),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = r#type::IntervalYear;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Type.IntervalYear")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<r#type::IntervalYear, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut type_variation_reference__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TypeVariationReference => {
                            if type_variation_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeVariationReference"));
                            }
                            type_variation_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(r#type::IntervalYear {
                    type_variation_reference: type_variation_reference__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Type.IntervalYear", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for r#type::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.r#type.is_some() {
            len += 1;
        }
        if self.type_variation_reference != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Type.List", len)?;
        if let Some(v) = self.r#type.as_ref() {
            struct_ser.serialize_field("type", v)?;
        }
        if self.type_variation_reference != 0 {
            struct_ser.serialize_field("typeVariationReference", &self.type_variation_reference)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for r#type::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "type_variation_reference",
            "typeVariationReference",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            TypeVariationReference,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "typeVariationReference" | "type_variation_reference" => Ok(GeneratedField::TypeVariationReference),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = r#type::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Type.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<r#type::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut type_variation_reference__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = map_.next_value()?;
                        }
                        GeneratedField::TypeVariationReference => {
                            if type_variation_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeVariationReference"));
                            }
                            type_variation_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(r#type::List {
                    r#type: r#type__,
                    type_variation_reference: type_variation_reference__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Type.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for r#type::Map {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.key.is_some() {
            len += 1;
        }
        if self.value.is_some() {
            len += 1;
        }
        if self.type_variation_reference != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Type.Map", len)?;
        if let Some(v) = self.key.as_ref() {
            struct_ser.serialize_field("key", v)?;
        }
        if let Some(v) = self.value.as_ref() {
            struct_ser.serialize_field("value", v)?;
        }
        if self.type_variation_reference != 0 {
            struct_ser.serialize_field("typeVariationReference", &self.type_variation_reference)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for r#type::Map {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "key",
            "value",
            "type_variation_reference",
            "typeVariationReference",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Key,
            Value,
            TypeVariationReference,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "key" => Ok(GeneratedField::Key),
                            "value" => Ok(GeneratedField::Value),
                            "typeVariationReference" | "type_variation_reference" => Ok(GeneratedField::TypeVariationReference),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = r#type::Map;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Type.Map")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<r#type::Map, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut key__ = None;
                let mut value__ = None;
                let mut type_variation_reference__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Key => {
                            if key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("key"));
                            }
                            key__ = map_.next_value()?;
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ = map_.next_value()?;
                        }
                        GeneratedField::TypeVariationReference => {
                            if type_variation_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeVariationReference"));
                            }
                            type_variation_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(r#type::Map {
                    key: key__,
                    value: value__,
                    type_variation_reference: type_variation_reference__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Type.Map", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for r#type::Nullability {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unspecified => "NULLABILITY_UNSPECIFIED",
            Self::Nullable => "NULLABILITY_NULLABLE",
            Self::Required => "NULLABILITY_REQUIRED",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for r#type::Nullability {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "NULLABILITY_UNSPECIFIED",
            "NULLABILITY_NULLABLE",
            "NULLABILITY_REQUIRED",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = r#type::Nullability;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "NULLABILITY_UNSPECIFIED" => Ok(r#type::Nullability::Unspecified),
                    "NULLABILITY_NULLABLE" => Ok(r#type::Nullability::Nullable),
                    "NULLABILITY_REQUIRED" => Ok(r#type::Nullability::Required),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for r#type::Parameter {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.parameter.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Type.Parameter", len)?;
        if let Some(v) = self.parameter.as_ref() {
            match v {
                r#type::parameter::Parameter::Null(v) => {
                    struct_ser.serialize_field("null", v)?;
                }
                r#type::parameter::Parameter::DataType(v) => {
                    struct_ser.serialize_field("dataType", v)?;
                }
                r#type::parameter::Parameter::Boolean(v) => {
                    struct_ser.serialize_field("boolean", v)?;
                }
                r#type::parameter::Parameter::Integer(v) => {
                    #[allow(clippy::needless_borrow)]
                    #[allow(clippy::needless_borrows_for_generic_args)]
                    struct_ser.serialize_field("integer", ToString::to_string(&v).as_str())?;
                }
                r#type::parameter::Parameter::Enum(v) => {
                    struct_ser.serialize_field("enum", v)?;
                }
                r#type::parameter::Parameter::String(v) => {
                    struct_ser.serialize_field("string", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for r#type::Parameter {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "null",
            "data_type",
            "dataType",
            "boolean",
            "integer",
            "enum",
            "string",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Null,
            DataType,
            Boolean,
            Integer,
            Enum,
            String,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "null" => Ok(GeneratedField::Null),
                            "dataType" | "data_type" => Ok(GeneratedField::DataType),
                            "boolean" => Ok(GeneratedField::Boolean),
                            "integer" => Ok(GeneratedField::Integer),
                            "enum" => Ok(GeneratedField::Enum),
                            "string" => Ok(GeneratedField::String),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = r#type::Parameter;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Type.Parameter")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<r#type::Parameter, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut parameter__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Null => {
                            if parameter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("null"));
                            }
                            parameter__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::parameter::Parameter::Null)
;
                        }
                        GeneratedField::DataType => {
                            if parameter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dataType"));
                            }
                            parameter__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::parameter::Parameter::DataType)
;
                        }
                        GeneratedField::Boolean => {
                            if parameter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("boolean"));
                            }
                            parameter__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::parameter::Parameter::Boolean);
                        }
                        GeneratedField::Integer => {
                            if parameter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("integer"));
                            }
                            parameter__ = map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| r#type::parameter::Parameter::Integer(x.0));
                        }
                        GeneratedField::Enum => {
                            if parameter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("enum"));
                            }
                            parameter__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::parameter::Parameter::Enum);
                        }
                        GeneratedField::String => {
                            if parameter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("string"));
                            }
                            parameter__ = map_.next_value::<::std::option::Option<_>>()?.map(r#type::parameter::Parameter::String);
                        }
                    }
                }
                Ok(r#type::Parameter {
                    parameter: parameter__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.Type.Parameter", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for r#type::PrecisionTime {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.precision != 0 {
            len += 1;
        }
        if self.type_variation_reference != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Type.PrecisionTime", len)?;
        if self.precision != 0 {
            struct_ser.serialize_field("precision", &self.precision)?;
        }
        if self.type_variation_reference != 0 {
            struct_ser.serialize_field("typeVariationReference", &self.type_variation_reference)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for r#type::PrecisionTime {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "precision",
            "type_variation_reference",
            "typeVariationReference",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Precision,
            TypeVariationReference,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "precision" => Ok(GeneratedField::Precision),
                            "typeVariationReference" | "type_variation_reference" => Ok(GeneratedField::TypeVariationReference),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = r#type::PrecisionTime;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Type.PrecisionTime")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<r#type::PrecisionTime, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut precision__ = None;
                let mut type_variation_reference__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Precision => {
                            if precision__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precision"));
                            }
                            precision__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::TypeVariationReference => {
                            if type_variation_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeVariationReference"));
                            }
                            type_variation_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(r#type::PrecisionTime {
                    precision: precision__.unwrap_or_default(),
                    type_variation_reference: type_variation_reference__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Type.PrecisionTime", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for r#type::PrecisionTimestamp {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.precision != 0 {
            len += 1;
        }
        if self.type_variation_reference != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Type.PrecisionTimestamp", len)?;
        if self.precision != 0 {
            struct_ser.serialize_field("precision", &self.precision)?;
        }
        if self.type_variation_reference != 0 {
            struct_ser.serialize_field("typeVariationReference", &self.type_variation_reference)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for r#type::PrecisionTimestamp {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "precision",
            "type_variation_reference",
            "typeVariationReference",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Precision,
            TypeVariationReference,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "precision" => Ok(GeneratedField::Precision),
                            "typeVariationReference" | "type_variation_reference" => Ok(GeneratedField::TypeVariationReference),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = r#type::PrecisionTimestamp;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Type.PrecisionTimestamp")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<r#type::PrecisionTimestamp, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut precision__ = None;
                let mut type_variation_reference__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Precision => {
                            if precision__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precision"));
                            }
                            precision__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::TypeVariationReference => {
                            if type_variation_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeVariationReference"));
                            }
                            type_variation_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(r#type::PrecisionTimestamp {
                    precision: precision__.unwrap_or_default(),
                    type_variation_reference: type_variation_reference__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Type.PrecisionTimestamp", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for r#type::PrecisionTimestampTz {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.precision != 0 {
            len += 1;
        }
        if self.type_variation_reference != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Type.PrecisionTimestampTZ", len)?;
        if self.precision != 0 {
            struct_ser.serialize_field("precision", &self.precision)?;
        }
        if self.type_variation_reference != 0 {
            struct_ser.serialize_field("typeVariationReference", &self.type_variation_reference)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for r#type::PrecisionTimestampTz {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "precision",
            "type_variation_reference",
            "typeVariationReference",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Precision,
            TypeVariationReference,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "precision" => Ok(GeneratedField::Precision),
                            "typeVariationReference" | "type_variation_reference" => Ok(GeneratedField::TypeVariationReference),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = r#type::PrecisionTimestampTz;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Type.PrecisionTimestampTZ")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<r#type::PrecisionTimestampTz, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut precision__ = None;
                let mut type_variation_reference__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Precision => {
                            if precision__.is_some() {
                                return Err(serde::de::Error::duplicate_field("precision"));
                            }
                            precision__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::TypeVariationReference => {
                            if type_variation_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeVariationReference"));
                            }
                            type_variation_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(r#type::PrecisionTimestampTz {
                    precision: precision__.unwrap_or_default(),
                    type_variation_reference: type_variation_reference__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Type.PrecisionTimestampTZ", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for r#type::String {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.type_variation_reference != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Type.String", len)?;
        if self.type_variation_reference != 0 {
            struct_ser.serialize_field("typeVariationReference", &self.type_variation_reference)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for r#type::String {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type_variation_reference",
            "typeVariationReference",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TypeVariationReference,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "typeVariationReference" | "type_variation_reference" => Ok(GeneratedField::TypeVariationReference),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = r#type::String;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Type.String")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<r#type::String, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut type_variation_reference__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TypeVariationReference => {
                            if type_variation_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeVariationReference"));
                            }
                            type_variation_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(r#type::String {
                    type_variation_reference: type_variation_reference__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Type.String", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for r#type::Struct {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.types.is_empty() {
            len += 1;
        }
        if self.type_variation_reference != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Type.Struct", len)?;
        if !self.types.is_empty() {
            struct_ser.serialize_field("types", &self.types)?;
        }
        if self.type_variation_reference != 0 {
            struct_ser.serialize_field("typeVariationReference", &self.type_variation_reference)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for r#type::Struct {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "types",
            "type_variation_reference",
            "typeVariationReference",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Types,
            TypeVariationReference,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "types" => Ok(GeneratedField::Types),
                            "typeVariationReference" | "type_variation_reference" => Ok(GeneratedField::TypeVariationReference),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = r#type::Struct;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Type.Struct")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<r#type::Struct, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut types__ = None;
                let mut type_variation_reference__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Types => {
                            if types__.is_some() {
                                return Err(serde::de::Error::duplicate_field("types"));
                            }
                            types__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TypeVariationReference => {
                            if type_variation_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeVariationReference"));
                            }
                            type_variation_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(r#type::Struct {
                    types: types__.unwrap_or_default(),
                    type_variation_reference: type_variation_reference__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Type.Struct", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for r#type::Time {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.type_variation_reference != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Type.Time", len)?;
        if self.type_variation_reference != 0 {
            struct_ser.serialize_field("typeVariationReference", &self.type_variation_reference)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for r#type::Time {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type_variation_reference",
            "typeVariationReference",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TypeVariationReference,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "typeVariationReference" | "type_variation_reference" => Ok(GeneratedField::TypeVariationReference),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = r#type::Time;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Type.Time")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<r#type::Time, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut type_variation_reference__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TypeVariationReference => {
                            if type_variation_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeVariationReference"));
                            }
                            type_variation_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(r#type::Time {
                    type_variation_reference: type_variation_reference__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Type.Time", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for r#type::Timestamp {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.type_variation_reference != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Type.Timestamp", len)?;
        if self.type_variation_reference != 0 {
            struct_ser.serialize_field("typeVariationReference", &self.type_variation_reference)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for r#type::Timestamp {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type_variation_reference",
            "typeVariationReference",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TypeVariationReference,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "typeVariationReference" | "type_variation_reference" => Ok(GeneratedField::TypeVariationReference),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = r#type::Timestamp;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Type.Timestamp")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<r#type::Timestamp, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut type_variation_reference__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TypeVariationReference => {
                            if type_variation_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeVariationReference"));
                            }
                            type_variation_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(r#type::Timestamp {
                    type_variation_reference: type_variation_reference__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Type.Timestamp", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for r#type::TimestampTz {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.type_variation_reference != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Type.TimestampTZ", len)?;
        if self.type_variation_reference != 0 {
            struct_ser.serialize_field("typeVariationReference", &self.type_variation_reference)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for r#type::TimestampTz {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type_variation_reference",
            "typeVariationReference",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TypeVariationReference,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "typeVariationReference" | "type_variation_reference" => Ok(GeneratedField::TypeVariationReference),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = r#type::TimestampTz;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Type.TimestampTZ")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<r#type::TimestampTz, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut type_variation_reference__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TypeVariationReference => {
                            if type_variation_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeVariationReference"));
                            }
                            type_variation_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(r#type::TimestampTz {
                    type_variation_reference: type_variation_reference__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Type.TimestampTZ", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for r#type::TypeAliasReference {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.type_alias_reference != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Type.TypeAliasReference", len)?;
        if self.type_alias_reference != 0 {
            struct_ser.serialize_field("typeAliasReference", &self.type_alias_reference)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for r#type::TypeAliasReference {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type_alias_reference",
            "typeAliasReference",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TypeAliasReference,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "typeAliasReference" | "type_alias_reference" => Ok(GeneratedField::TypeAliasReference),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = r#type::TypeAliasReference;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Type.TypeAliasReference")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<r#type::TypeAliasReference, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut type_alias_reference__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TypeAliasReference => {
                            if type_alias_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeAliasReference"));
                            }
                            type_alias_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(r#type::TypeAliasReference {
                    type_alias_reference: type_alias_reference__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Type.TypeAliasReference", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for r#type::Uuid {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.type_variation_reference != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Type.UUID", len)?;
        if self.type_variation_reference != 0 {
            struct_ser.serialize_field("typeVariationReference", &self.type_variation_reference)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for r#type::Uuid {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type_variation_reference",
            "typeVariationReference",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TypeVariationReference,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "typeVariationReference" | "type_variation_reference" => Ok(GeneratedField::TypeVariationReference),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = r#type::Uuid;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Type.UUID")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<r#type::Uuid, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut type_variation_reference__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TypeVariationReference => {
                            if type_variation_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeVariationReference"));
                            }
                            type_variation_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(r#type::Uuid {
                    type_variation_reference: type_variation_reference__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Type.UUID", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for r#type::UserDefined {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.type_reference != 0 {
            len += 1;
        }
        if self.type_variation_reference != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        if !self.type_parameters.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Type.UserDefined", len)?;
        if self.type_reference != 0 {
            struct_ser.serialize_field("typeReference", &self.type_reference)?;
        }
        if self.type_variation_reference != 0 {
            struct_ser.serialize_field("typeVariationReference", &self.type_variation_reference)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        if !self.type_parameters.is_empty() {
            struct_ser.serialize_field("typeParameters", &self.type_parameters)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for r#type::UserDefined {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type_reference",
            "typeReference",
            "type_variation_reference",
            "typeVariationReference",
            "nullability",
            "type_parameters",
            "typeParameters",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TypeReference,
            TypeVariationReference,
            Nullability,
            TypeParameters,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "typeReference" | "type_reference" => Ok(GeneratedField::TypeReference),
                            "typeVariationReference" | "type_variation_reference" => Ok(GeneratedField::TypeVariationReference),
                            "nullability" => Ok(GeneratedField::Nullability),
                            "typeParameters" | "type_parameters" => Ok(GeneratedField::TypeParameters),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = r#type::UserDefined;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Type.UserDefined")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<r#type::UserDefined, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut type_reference__ = None;
                let mut type_variation_reference__ = None;
                let mut nullability__ = None;
                let mut type_parameters__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TypeReference => {
                            if type_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeReference"));
                            }
                            type_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::TypeVariationReference => {
                            if type_variation_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeVariationReference"));
                            }
                            type_variation_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                        GeneratedField::TypeParameters => {
                            if type_parameters__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeParameters"));
                            }
                            type_parameters__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(r#type::UserDefined {
                    type_reference: type_reference__.unwrap_or_default(),
                    type_variation_reference: type_variation_reference__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                    type_parameters: type_parameters__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Type.UserDefined", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for r#type::VarChar {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.length != 0 {
            len += 1;
        }
        if self.type_variation_reference != 0 {
            len += 1;
        }
        if self.nullability != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Type.VarChar", len)?;
        if self.length != 0 {
            struct_ser.serialize_field("length", &self.length)?;
        }
        if self.type_variation_reference != 0 {
            struct_ser.serialize_field("typeVariationReference", &self.type_variation_reference)?;
        }
        if self.nullability != 0 {
            let v = r#type::Nullability::try_from(self.nullability)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.nullability)))?;
            struct_ser.serialize_field("nullability", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for r#type::VarChar {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "length",
            "type_variation_reference",
            "typeVariationReference",
            "nullability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Length,
            TypeVariationReference,
            Nullability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "length" => Ok(GeneratedField::Length),
                            "typeVariationReference" | "type_variation_reference" => Ok(GeneratedField::TypeVariationReference),
                            "nullability" => Ok(GeneratedField::Nullability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = r#type::VarChar;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Type.VarChar")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<r#type::VarChar, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut length__ = None;
                let mut type_variation_reference__ = None;
                let mut nullability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Length => {
                            if length__.is_some() {
                                return Err(serde::de::Error::duplicate_field("length"));
                            }
                            length__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::TypeVariationReference => {
                            if type_variation_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeVariationReference"));
                            }
                            type_variation_reference__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nullability => {
                            if nullability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nullability"));
                            }
                            nullability__ = Some(map_.next_value::<r#type::Nullability>()? as i32);
                        }
                    }
                }
                Ok(r#type::VarChar {
                    length: length__.unwrap_or_default(),
                    type_variation_reference: type_variation_reference__.unwrap_or_default(),
                    nullability: nullability__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Type.VarChar", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TypeAlias {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.type_alias_anchor != 0 {
            len += 1;
        }
        if self.r#type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.TypeAlias", len)?;
        if self.type_alias_anchor != 0 {
            struct_ser.serialize_field("typeAliasAnchor", &self.type_alias_anchor)?;
        }
        if let Some(v) = self.r#type.as_ref() {
            struct_ser.serialize_field("type", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TypeAlias {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type_alias_anchor",
            "typeAliasAnchor",
            "type",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TypeAliasAnchor,
            Type,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "typeAliasAnchor" | "type_alias_anchor" => Ok(GeneratedField::TypeAliasAnchor),
                            "type" => Ok(GeneratedField::Type),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TypeAlias;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.TypeAlias")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TypeAlias, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut type_alias_anchor__ = None;
                let mut r#type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TypeAliasAnchor => {
                            if type_alias_anchor__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeAliasAnchor"));
                            }
                            type_alias_anchor__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = map_.next_value()?;
                        }
                    }
                }
                Ok(TypeAlias {
                    type_alias_anchor: type_alias_anchor__.unwrap_or_default(),
                    r#type: r#type__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.TypeAlias", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UpdateRel {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.table_schema.is_some() {
            len += 1;
        }
        if self.condition.is_some() {
            len += 1;
        }
        if !self.transformations.is_empty() {
            len += 1;
        }
        if self.advanced_extension.is_some() {
            len += 1;
        }
        if self.update_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.UpdateRel", len)?;
        if let Some(v) = self.table_schema.as_ref() {
            struct_ser.serialize_field("tableSchema", v)?;
        }
        if let Some(v) = self.condition.as_ref() {
            struct_ser.serialize_field("condition", v)?;
        }
        if !self.transformations.is_empty() {
            struct_ser.serialize_field("transformations", &self.transformations)?;
        }
        if let Some(v) = self.advanced_extension.as_ref() {
            struct_ser.serialize_field("advancedExtension", v)?;
        }
        if let Some(v) = self.update_type.as_ref() {
            match v {
                update_rel::UpdateType::NamedTable(v) => {
                    struct_ser.serialize_field("namedTable", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UpdateRel {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "table_schema",
            "tableSchema",
            "condition",
            "transformations",
            "advanced_extension",
            "advancedExtension",
            "named_table",
            "namedTable",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TableSchema,
            Condition,
            Transformations,
            AdvancedExtension,
            NamedTable,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "tableSchema" | "table_schema" => Ok(GeneratedField::TableSchema),
                            "condition" => Ok(GeneratedField::Condition),
                            "transformations" => Ok(GeneratedField::Transformations),
                            "advancedExtension" | "advanced_extension" => Ok(GeneratedField::AdvancedExtension),
                            "namedTable" | "named_table" => Ok(GeneratedField::NamedTable),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UpdateRel;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.UpdateRel")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UpdateRel, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut table_schema__ = None;
                let mut condition__ = None;
                let mut transformations__ = None;
                let mut advanced_extension__ = None;
                let mut update_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TableSchema => {
                            if table_schema__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tableSchema"));
                            }
                            table_schema__ = map_.next_value()?;
                        }
                        GeneratedField::Condition => {
                            if condition__.is_some() {
                                return Err(serde::de::Error::duplicate_field("condition"));
                            }
                            condition__ = map_.next_value()?;
                        }
                        GeneratedField::Transformations => {
                            if transformations__.is_some() {
                                return Err(serde::de::Error::duplicate_field("transformations"));
                            }
                            transformations__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AdvancedExtension => {
                            if advanced_extension__.is_some() {
                                return Err(serde::de::Error::duplicate_field("advancedExtension"));
                            }
                            advanced_extension__ = map_.next_value()?;
                        }
                        GeneratedField::NamedTable => {
                            if update_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("namedTable"));
                            }
                            update_type__ = map_.next_value::<::std::option::Option<_>>()?.map(update_rel::UpdateType::NamedTable)
;
                        }
                    }
                }
                Ok(UpdateRel {
                    table_schema: table_schema__,
                    condition: condition__,
                    transformations: transformations__.unwrap_or_default(),
                    advanced_extension: advanced_extension__,
                    update_type: update_type__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.UpdateRel", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for update_rel::TransformExpression {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.transformation.is_some() {
            len += 1;
        }
        if self.column_target != 0 {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.UpdateRel.TransformExpression", len)?;
        if let Some(v) = self.transformation.as_ref() {
            struct_ser.serialize_field("transformation", v)?;
        }
        if self.column_target != 0 {
            struct_ser.serialize_field("columnTarget", &self.column_target)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for update_rel::TransformExpression {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "transformation",
            "column_target",
            "columnTarget",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Transformation,
            ColumnTarget,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "transformation" => Ok(GeneratedField::Transformation),
                            "columnTarget" | "column_target" => Ok(GeneratedField::ColumnTarget),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = update_rel::TransformExpression;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.UpdateRel.TransformExpression")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<update_rel::TransformExpression, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut transformation__ = None;
                let mut column_target__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Transformation => {
                            if transformation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("transformation"));
                            }
                            transformation__ = map_.next_value()?;
                        }
                        GeneratedField::ColumnTarget => {
                            if column_target__.is_some() {
                                return Err(serde::de::Error::duplicate_field("columnTarget"));
                            }
                            column_target__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(update_rel::TransformExpression {
                    transformation: transformation__,
                    column_target: column_target__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.UpdateRel.TransformExpression", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Version {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.major_number != 0 {
            len += 1;
        }
        if self.minor_number != 0 {
            len += 1;
        }
        if self.patch_number != 0 {
            len += 1;
        }
        if !self.git_hash.is_empty() {
            len += 1;
        }
        if !self.producer.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.Version", len)?;
        if self.major_number != 0 {
            struct_ser.serialize_field("majorNumber", &self.major_number)?;
        }
        if self.minor_number != 0 {
            struct_ser.serialize_field("minorNumber", &self.minor_number)?;
        }
        if self.patch_number != 0 {
            struct_ser.serialize_field("patchNumber", &self.patch_number)?;
        }
        if !self.git_hash.is_empty() {
            struct_ser.serialize_field("gitHash", &self.git_hash)?;
        }
        if !self.producer.is_empty() {
            struct_ser.serialize_field("producer", &self.producer)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Version {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "major_number",
            "majorNumber",
            "minor_number",
            "minorNumber",
            "patch_number",
            "patchNumber",
            "git_hash",
            "gitHash",
            "producer",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MajorNumber,
            MinorNumber,
            PatchNumber,
            GitHash,
            Producer,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "majorNumber" | "major_number" => Ok(GeneratedField::MajorNumber),
                            "minorNumber" | "minor_number" => Ok(GeneratedField::MinorNumber),
                            "patchNumber" | "patch_number" => Ok(GeneratedField::PatchNumber),
                            "gitHash" | "git_hash" => Ok(GeneratedField::GitHash),
                            "producer" => Ok(GeneratedField::Producer),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Version;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.Version")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Version, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut major_number__ = None;
                let mut minor_number__ = None;
                let mut patch_number__ = None;
                let mut git_hash__ = None;
                let mut producer__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MajorNumber => {
                            if major_number__.is_some() {
                                return Err(serde::de::Error::duplicate_field("majorNumber"));
                            }
                            major_number__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::MinorNumber => {
                            if minor_number__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minorNumber"));
                            }
                            minor_number__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::PatchNumber => {
                            if patch_number__.is_some() {
                                return Err(serde::de::Error::duplicate_field("patchNumber"));
                            }
                            patch_number__ =
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::GitHash => {
                            if git_hash__.is_some() {
                                return Err(serde::de::Error::duplicate_field("gitHash"));
                            }
                            git_hash__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Producer => {
                            if producer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("producer"));
                            }
                            producer__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(Version {
                    major_number: major_number__.unwrap_or_default(),
                    minor_number: minor_number__.unwrap_or_default(),
                    patch_number: patch_number__.unwrap_or_default(),
                    git_hash: git_hash__.unwrap_or_default(),
                    producer: producer__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("substrait.Version", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WriteRel {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.table_schema.is_some() {
            len += 1;
        }
        if self.op != 0 {
            len += 1;
        }
        if self.input.is_some() {
            len += 1;
        }
        if self.create_mode != 0 {
            len += 1;
        }
        if self.output != 0 {
            len += 1;
        }
        if self.common.is_some() {
            len += 1;
        }
        if self.advanced_extension.is_some() {
            len += 1;
        }
        if self.write_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("substrait.WriteRel", len)?;
        if let Some(v) = self.table_schema.as_ref() {
            struct_ser.serialize_field("tableSchema", v)?;
        }
        if self.op != 0 {
            let v = write_rel::WriteOp::try_from(self.op)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.op)))?;
            struct_ser.serialize_field("op", &v)?;
        }
        if let Some(v) = self.input.as_ref() {
            struct_ser.serialize_field("input", v)?;
        }
        if self.create_mode != 0 {
            let v = write_rel::CreateMode::try_from(self.create_mode)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.create_mode)))?;
            struct_ser.serialize_field("createMode", &v)?;
        }
        if self.output != 0 {
            let v = write_rel::OutputMode::try_from(self.output)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.output)))?;
            struct_ser.serialize_field("output", &v)?;
        }
        if let Some(v) = self.common.as_ref() {
            struct_ser.serialize_field("common", v)?;
        }
        if let Some(v) = self.advanced_extension.as_ref() {
            struct_ser.serialize_field("advancedExtension", v)?;
        }
        if let Some(v) = self.write_type.as_ref() {
            match v {
                write_rel::WriteType::NamedTable(v) => {
                    struct_ser.serialize_field("namedTable", v)?;
                }
                write_rel::WriteType::ExtensionTable(v) => {
                    struct_ser.serialize_field("extensionTable", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WriteRel {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "table_schema",
            "tableSchema",
            "op",
            "input",
            "create_mode",
            "createMode",
            "output",
            "common",
            "advanced_extension",
            "advancedExtension",
            "named_table",
            "namedTable",
            "extension_table",
            "extensionTable",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TableSchema,
            Op,
            Input,
            CreateMode,
            Output,
            Common,
            AdvancedExtension,
            NamedTable,
            ExtensionTable,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "tableSchema" | "table_schema" => Ok(GeneratedField::TableSchema),
                            "op" => Ok(GeneratedField::Op),
                            "input" => Ok(GeneratedField::Input),
                            "createMode" | "create_mode" => Ok(GeneratedField::CreateMode),
                            "output" => Ok(GeneratedField::Output),
                            "common" => Ok(GeneratedField::Common),
                            "advancedExtension" | "advanced_extension" => Ok(GeneratedField::AdvancedExtension),
                            "namedTable" | "named_table" => Ok(GeneratedField::NamedTable),
                            "extensionTable" | "extension_table" => Ok(GeneratedField::ExtensionTable),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WriteRel;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct substrait.WriteRel")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WriteRel, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut table_schema__ = None;
                let mut op__ = None;
                let mut input__ = None;
                let mut create_mode__ = None;
                let mut output__ = None;
                let mut common__ = None;
                let mut advanced_extension__ = None;
                let mut write_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TableSchema => {
                            if table_schema__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tableSchema"));
                            }
                            table_schema__ = map_.next_value()?;
                        }
                        GeneratedField::Op => {
                            if op__.is_some() {
                                return Err(serde::de::Error::duplicate_field("op"));
                            }
                            op__ = Some(map_.next_value::<write_rel::WriteOp>()? as i32);
                        }
                        GeneratedField::Input => {
                            if input__.is_some() {
                                return Err(serde::de::Error::duplicate_field("input"));
                            }
                            input__ = map_.next_value()?;
                        }
                        GeneratedField::CreateMode => {
                            if create_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("createMode"));
                            }
                            create_mode__ = Some(map_.next_value::<write_rel::CreateMode>()? as i32);
                        }
                        GeneratedField::Output => {
                            if output__.is_some() {
                                return Err(serde::de::Error::duplicate_field("output"));
                            }
                            output__ = Some(map_.next_value::<write_rel::OutputMode>()? as i32);
                        }
                        GeneratedField::Common => {
                            if common__.is_some() {
                                return Err(serde::de::Error::duplicate_field("common"));
                            }
                            common__ = map_.next_value()?;
                        }
                        GeneratedField::AdvancedExtension => {
                            if advanced_extension__.is_some() {
                                return Err(serde::de::Error::duplicate_field("advancedExtension"));
                            }
                            advanced_extension__ = map_.next_value()?;
                        }
                        GeneratedField::NamedTable => {
                            if write_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("namedTable"));
                            }
                            write_type__ = map_.next_value::<::std::option::Option<_>>()?.map(write_rel::WriteType::NamedTable)
;
                        }
                        GeneratedField::ExtensionTable => {
                            if write_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("extensionTable"));
                            }
                            write_type__ = map_.next_value::<::std::option::Option<_>>()?.map(write_rel::WriteType::ExtensionTable)
;
                        }
                    }
                }
                Ok(WriteRel {
                    table_schema: table_schema__,
                    op: op__.unwrap_or_default(),
                    input: input__,
                    create_mode: create_mode__.unwrap_or_default(),
                    output: output__.unwrap_or_default(),
                    common: common__,
                    advanced_extension: advanced_extension__,
                    write_type: write_type__,
                })
            }
        }
        deserializer.deserialize_struct("substrait.WriteRel", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for write_rel::CreateMode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unspecified => "CREATE_MODE_UNSPECIFIED",
            Self::AppendIfExists => "CREATE_MODE_APPEND_IF_EXISTS",
            Self::ReplaceIfExists => "CREATE_MODE_REPLACE_IF_EXISTS",
            Self::IgnoreIfExists => "CREATE_MODE_IGNORE_IF_EXISTS",
            Self::ErrorIfExists => "CREATE_MODE_ERROR_IF_EXISTS",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for write_rel::CreateMode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CREATE_MODE_UNSPECIFIED",
            "CREATE_MODE_APPEND_IF_EXISTS",
            "CREATE_MODE_REPLACE_IF_EXISTS",
            "CREATE_MODE_IGNORE_IF_EXISTS",
            "CREATE_MODE_ERROR_IF_EXISTS",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = write_rel::CreateMode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "CREATE_MODE_UNSPECIFIED" => Ok(write_rel::CreateMode::Unspecified),
                    "CREATE_MODE_APPEND_IF_EXISTS" => Ok(write_rel::CreateMode::AppendIfExists),
                    "CREATE_MODE_REPLACE_IF_EXISTS" => Ok(write_rel::CreateMode::ReplaceIfExists),
                    "CREATE_MODE_IGNORE_IF_EXISTS" => Ok(write_rel::CreateMode::IgnoreIfExists),
                    "CREATE_MODE_ERROR_IF_EXISTS" => Ok(write_rel::CreateMode::ErrorIfExists),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for write_rel::OutputMode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unspecified => "OUTPUT_MODE_UNSPECIFIED",
            Self::NoOutput => "OUTPUT_MODE_NO_OUTPUT",
            Self::ModifiedRecords => "OUTPUT_MODE_MODIFIED_RECORDS",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for write_rel::OutputMode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "OUTPUT_MODE_UNSPECIFIED",
            "OUTPUT_MODE_NO_OUTPUT",
            "OUTPUT_MODE_MODIFIED_RECORDS",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = write_rel::OutputMode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "OUTPUT_MODE_UNSPECIFIED" => Ok(write_rel::OutputMode::Unspecified),
                    "OUTPUT_MODE_NO_OUTPUT" => Ok(write_rel::OutputMode::NoOutput),
                    "OUTPUT_MODE_MODIFIED_RECORDS" => Ok(write_rel::OutputMode::ModifiedRecords),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for write_rel::WriteOp {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unspecified => "WRITE_OP_UNSPECIFIED",
            Self::Insert => "WRITE_OP_INSERT",
            Self::Delete => "WRITE_OP_DELETE",
            Self::Update => "WRITE_OP_UPDATE",
            Self::Ctas => "WRITE_OP_CTAS",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for write_rel::WriteOp {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "WRITE_OP_UNSPECIFIED",
            "WRITE_OP_INSERT",
            "WRITE_OP_DELETE",
            "WRITE_OP_UPDATE",
            "WRITE_OP_CTAS",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = write_rel::WriteOp;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "WRITE_OP_UNSPECIFIED" => Ok(write_rel::WriteOp::Unspecified),
                    "WRITE_OP_INSERT" => Ok(write_rel::WriteOp::Insert),
                    "WRITE_OP_DELETE" => Ok(write_rel::WriteOp::Delete),
                    "WRITE_OP_UPDATE" => Ok(write_rel::WriteOp::Update),
                    "WRITE_OP_CTAS" => Ok(write_rel::WriteOp::Ctas),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
